{"meta":{"title":"Mayue‘s Blog","subtitle":null,"description":"专注移动开发的技术博客","author":"Ma Yue","url":"http://xamarin.xyz"},"pages":[{"title":"关于","date":"2017-11-02T13:39:48.000Z","updated":"2017-11-03T07:50:41.000Z","comments":true,"path":"about/index.html","permalink":"http://xamarin.xyz/about/index.html","excerpt":"","text":"一个半吊子Coder,C#开发者却钟情于移动应用开发，故走上了Xamarin这条不归路。 QQ交流群:235110157 微信公众号：XamarinTop"}],"posts":[{"title":"Xamarin.Forms 界面适应介绍","slug":"Xamarin.Forms 界面适应介绍","date":"2017-11-04T05:19:00.000Z","updated":"2017-11-05T03:12:12.260Z","comments":true,"path":"2017/11/04/Xamarin.Forms 界面适应介绍/","link":"","permalink":"http://xamarin.xyz/2017/11/04/Xamarin.Forms 界面适应介绍/","excerpt":"Android 和iOS原生都提供了横竖屏切换的解决方案，这些方法同样可以用于Xamarin.Android和Xamarin.iOS，对于Forms项目而言横竖屏的切换有什么好的解决方案？强制竖屏显示一劳永逸但这不能给用户最好的体验。","text":"Android 和iOS原生都提供了横竖屏切换的解决方案，这些方法同样可以用于Xamarin.Android和Xamarin.iOS，对于Forms项目而言横竖屏的切换有什么好的解决方案？强制竖屏显示一劳永逸但这不能给用户最好的体验。 Android 和iOS原生都提供了横竖屏切换的解决方案，这些方法同样可以用于Xamarin.Android和Xamarin.iOS，对于Forms项目而言横竖屏的切换有什么好的解决方案？强制竖屏显示一劳永逸但这不能给用户最好的体验。 Page的SizeChanged事件Forms中Page类提供了SizeChanged,SizeChanged事件\b可以帮助我们在运行时获取Page大小的变化,如屏幕旋转时。触发SizeChanged事件时，通过比较Page的Width和Height来判断当前横竖屏的显示方式。 SizeChanged会在页面第一次创建显示时出触发该事件 1234567891011121314public AdaptiveUIPage()&#123; InitializeComponent(); SizeChanged += Page_SizeChanged;&#125;void Page_SizeChanged(object sender, System.EventArgs e)&#123; System.Diagnostics.Debug.WriteLine(nameof(Page_SizeChanged)); var isPortrait = Height &gt; Width; layout.Orientation = (isPortrait ? StackOrientation.Vertical : StackOrientation.Horizontal);&#125; 判断设备类型 以下部分没有敲过代码，直接抄袭过来的 除了考虑横竖屏的情况，有时我们\b还要根据不同的设备显示不同的效果，最简单的例子就是手机和平板界面显示的差异。 \bForms提供了Device.Idiom可以帮助我们判断当前设备的类型:1234567891011switch (Device.Idiom)&#123; case TargetIdiom.Desktop: break; case TargetIdiom.Phone: break; case TargetIdiom.Tablet: break; case TargetIdiom.TV: break;&#125; 如果只是简单界面的调整可以在界面初始化时直接通过代码挑战界面布局。12345678910if (Device.Idiom == TargetIdiom.Desktop)&#123; buttonAbout.HeightRequest = 25; buttonAbout.WidthRequest = 40;&#125;else&#123; buttonAbout.HeightRequest = 40; buttonAbout.WidthRequest = 70;&#125; 界面有较大调整时可以直接通过对\bContentView的更换实现想要的效果。1234if (Device.Idiom == TargetIdiom.Desktop) colorPicker = new ColorPickerMouseView();else colorPicker = new ColorPickerTouchView(); 甚至可以为不同设备定义不同页面，在Push Page时判断设备类型调整到不同页面,再结合MVVM模式可以最大限度的减少我们代码12345678910ContentPage page; if(Device.Idiom == TargetIdiom.Desktop) page = new DetailsDesktopPage(new MyDetailViewModel(...));else if(Device.Idiom == TargetIdiom.TV) page = new DetailsTVPage(new MyDetailViewModel(...));else //Phone or Tablet page = new DetailsMobilePage(new MyDetailViewModel(...)); Navigation.PushAsync(page);","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms 图表Microcharts介绍","slug":"Xamarin-Forms-图表Microcharts介绍","date":"2017-10-14T17:46:00.000Z","updated":"2017-11-04T02:39:46.830Z","comments":true,"path":"2017/10/15/Xamarin-Forms-图表Microcharts介绍/","link":"","permalink":"http://xamarin.xyz/2017/10/15/Xamarin-Forms-图表Microcharts介绍/","excerpt":"Microcharts是一个优秀的开源项目,基于SkiaSharp实现，项目地址 。可以帮助我们实现各种图表功能，如不能满足需求可以尝试oxyplot。此文只是一个简单的译文，原文地址：https://blog.xamarin.com/microcharts-elegant-cross-platform-charts-for-any-app/","text":"Microcharts是一个优秀的开源项目,基于SkiaSharp实现，项目地址 。可以帮助我们实现各种图表功能，如不能满足需求可以尝试oxyplot。此文只是一个简单的译文，原文地址：https://blog.xamarin.com/microcharts-elegant-cross-platform-charts-for-any-app/ Microcharts是一个优秀的开源项目,基于SkiaSharp实现，项目地址 。可以帮助我们实现各种图表功能，如不能满足需求可以尝试oxyplot。此文只是一个简单的译文，原文地址：https://blog.xamarin.com/microcharts-elegant-cross-platform-charts-for-any-app/ Microcharts 提供了对Android、iOS、macOS、UWP和Xamarin.Forms支持，在任何平台中你都可以方便的使用它。 Data EntriesMicrocharts通过Entry加载数据以显示成各种类型图表。Entry包含哪些值： 一个float类型值（必须的） Label关联Entry的描述文本 ValueLabel格式化显示的值 Color关联Entry显示的颜色 示例代码：1234567891011121314151617181920212223242526var entries = new [] &#123; new Entry(212) &#123; Label = &quot;UWP&quot;, ValueLabel = &quot;212&quot;, Color = SKColor.Parse(&quot;#2c3e50&quot;) &#125;, new Entry(248) &#123; Label = &quot;Android&quot;, ValueLabel = &quot;248&quot;, Color = SKColor.Parse(&quot;#77d065&quot;) &#125;, new Entry(128) &#123; Label = &quot;iOS&quot;, ValueLabel = &quot;128&quot;, Color = SKColor.Parse(&quot;#b455b6&quot;) &#125;, new Entry(514) &#123; Label = &quot;Shared&quot;, ValueLabel = &quot;514&quot;, Color = SKColor.Parse(&quot;#3498db&quot;)&#125; &#125;; Chart Types下面会列出Microcharts目前支持的图表类型（这是一个开源项目将来可能会增加新的图表） BarChart(柱形图)1var chart = new BarChart() &#123; Entries = entries &#125;; LineChart(线形图)1var chart = new LineChart() &#123; Entries = entries &#125;; PointChart(散点图[单点])1var chart = new PointChart() &#123; Entries = entries &#125;; RadialGauge(径向仪表盘)1var chart = new RadialGaugeChart() &#123; Entries = entries &#125;; Donut(饼图)1var chart = new DonutChart() &#123; Entries = entries &#125;; Radar(雷达图)1var chart = new RadarChart() &#123; Entries = entries &#125;; Displaying a Chart接下来要做的就是显示图表。12345678&lt;ContentPage&gt; xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:microcharts=&quot;clr-namespace:Microcharts.Forms;assembly=Microcharts.Forms&quot; xmlns:local=&quot;clr-namespace:Microcharts.Samples.Forms&quot; x:Class=&quot;Microcharts.Samples.Forms.MainPage&quot;&gt; &lt;microcharts:ChartView x:Name=&quot;chartView&quot; /&gt;&lt;/ContentPage&gt; 声明命名空间xmlns:microcharts=&quot;clr-namespace:Microcharts.Forms;assembly=Microcharts.Forms&quot;，其次定义ChartView对象。在cs文件中对ChartView的Chart属性进行赋值：this.chartView.Chart = chart; Chart属性是一个bindable属性,所以我们可以使用绑定的形式实现同样的效果。 Tweaking the Visual Aspect对于每种图表我们可以进行简单的修改渲染出不同额效果，如LineChart默认显示为： 对线条和点的属性做些修改：12345678var chart = new LineChart() &#123; Entries = entries, LineMode = LineMode.Straight, LineSize = 8, PointMode = PointMode.Square, PointSize = 18,&#125;; 会呈现如下效果： 更多使用请参考示例代码，最后要说明的是Microcharts是一个活跃的开源项目，会持续增加更多图表支持，如果你有能力或问题你可以为它做更多贡献。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Chart","slug":"Chart","permalink":"http://xamarin.xyz/tags/Chart/"}]},{"title":"Xamarin Forms DataTemplateSelector介绍","slug":"Xamarin-Forms-DataTemplateSelector介绍","date":"2017-09-19T14:06:00.000Z","updated":"2017-11-02T14:17:01.000Z","comments":true,"path":"2017/09/19/Xamarin-Forms-DataTemplateSelector介绍/","link":"","permalink":"http://xamarin.xyz/2017/09/19/Xamarin-Forms-DataTemplateSelector介绍/","excerpt":"DataTemplateSelector可以帮助我们实现动态选择数据绑定的模版，如通过ListView+DataTemplateSelector实现微信朋友圈或聊天列表效果。Github已有聊天效果图,喜欢阅读代码请直接移步：https://github.com/nishanil/Xamarin.Forms-Samples/tree/master/DataTemplateSelector","text":"DataTemplateSelector可以帮助我们实现动态选择数据绑定的模版，如通过ListView+DataTemplateSelector实现微信朋友圈或聊天列表效果。Github已有聊天效果图,喜欢阅读代码请直接移步：https://github.com/nishanil/Xamarin.Forms-Samples/tree/master/DataTemplateSelector DataTemplateSelector可以帮助我们实现动态选择数据绑定的模版，如通过ListView+DataTemplateSelector实现微信朋友圈或聊天列表效果。 Github已有聊天效果图 喜欢阅读代码请直接移步：https://github.com/nishanil/Xamarin.Forms-Samples/tree/master/DataTemplateSelector 本文通过一个简单的Demo练习DataTemplateSelector的使用。首先在新建的空项目中添加三个Model类： 其中BaseModel作基类，表示数据源类型，TitleModel和DescribeModel分别是BaseModel的子类表示数据源的不同情况。作为练习BaseModel中仅定义了一个String类型属性Title，TitleModel只是单纯的继承BaseModel，DescribeModel继承BaseModel的同时增加了一个String类型属性Describe。 接下来开始为本文的主角编码，声明一个MyDataTemplateSelector继承DataTemplateSelector。 其中TitleTemplate和DescribeTemplate是我们根据情况定义的两个数据模版，TitleTemplate对应TitleModel，DescribeTemplate对应DescribeModel。OnSelectTemplate方法是我们必须重写的一个方法，在OnSelectTemplate方法中判断item的类型或某个属性值返回对应的DataTemplate。 接下来主要介绍DataTemplateSelector在Xaml中的使用。 首先在Resources中定义我们需要的两个DataTemplate。 为了方便用TextCell代替自定义Cell，两个DataTemplate 的Key值方便使用区分分别定义为TitleTemplate和DescribeTemplate，可以定义你自己的任意值。 定义了需要的DataTemplate后再定义我们的MyDataTemplateSelector。并将提前定义好的DataTemplate通过StaticResource赋值给MyDataTemplateSelector的TitleTemplate和DescribeTemplate属性。 Demo中所有内容都定义在了ContentPage.Resources内，完整定义代码。 定义ListView时再将我们定义好的MyDataTemplateSelector对象赋值给ListView的ItemTemplate属性 模拟数据源并绑定到ListView： Demo效果图：","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"DataTemplateSelector","slug":"DataTemplateSelector","permalink":"http://xamarin.xyz/tags/DataTemplateSelector/"}]},{"title":"Xamarin.Forms Realm 使用入门","slug":"Xamarin-Forms-Realm-使用入门","date":"2017-07-21T01:12:00.000Z","updated":"2017-11-04T02:23:43.650Z","comments":true,"path":"2017/07/21/Xamarin-Forms-Realm-使用入门/","link":"","permalink":"http://xamarin.xyz/2017/07/21/Xamarin-Forms-Realm-使用入门/","excerpt":"Realm是一个移动端数据库，用来代替SQLite和ORMs。支持跨平台，本文简单介绍Realm在Xamarin.Forms中使用简单的实现一个任务列表增删改的Demo。","text":"Realm是一个移动端数据库，用来代替SQLite和ORMs。支持跨平台，本文简单介绍Realm在Xamarin.Forms中使用简单的实现一个任务列表增删改的Demo。 Realm是一个移动端数据库，用来代替SQLite和ORMs。支持跨平台，本文简单介绍Realm在Xamarin.Forms中使用简单的实现一个任务列表增删改的Demo。 添加Realm包Nuget中搜索Realm，选择对应包添加到项目中，其中Fody作为依赖包添加到项目中。 成功添加包后会在项目中生成一个FodyWeavers.xml文件（前提是你项目中没有引用过Fody包）。对FodyWeavers.xml文件做如下修改： PCL项目需要分别为平台项目和PCL添加Realm包，Shared项目则只在平台项目中添加Realm包即可 Model的定义Realm中定义Model需要继承RealmObject类，在Model类中可以像普通的C#类一样定义自己方法和事件，需要注意的是你只能在对象的创建线程中使用它，并为属性提供getters和setters。Realm中Model类必须要有一个无参数的构造函数，在Model中没有定义任何的构造函数时，编译器会自动为你添加，如果你定义了任何一个包含参数的构造函数，同时必须定义一个无参数构造函数。 Realm中Model必须直接继承RealmObject，不支持对RealmObject子类的继承 支持类型Realm提供了对基础无符号值类型的支持(bool,char,byte, short,int,long,float和double) ，以及string 和DateTimeOffset。同时支持类似int?形式的可空类型。定义Realm的Model时间类型应该用DateTimeOffset代替DateTime。IList&lt;RealmObject&gt;和IQueryable&lt;RealmObject&gt;集合类型支持，定义该集合类型时，应只定义get操作否则会编译报错： 用 IList 和 RealmObject 建立诸如一对多、一对一的关系模型，使用IList时不需要初始化，Realm SDK会帮我们完成这项工作。 特性说明Backlink,Ignored,Indexed,MapTo,PrimaryKey,Required Backlink—— Backlink标记的属性必须是IQueryable类型。当两个Model存在一对一或一对多关系时，通过Backlink实现反向链接避免手动同步出错。 Ignored——Model与表映射时忽略该属性，即在表中不会生成相应字段。 Indexed——索引属性，目前只有string,int,bool和DateTimeOffset可以设置为索引属性。查询时把索引属性作为查询条件会加快查询速度。 MapTo——当Model属性与表字段名不同时可以通过MapTo匹配。 PrimaryKey——主键，可以指定Model中唯一属性为主键且只有char，int和string类型属性可以作为主键，主键的值具有唯一性。 Required——表示该属性不能为空。 For objects where you have specified a [PrimaryKey], you can pass in update: true in realm.Addto add the passed in object or update the existing one Create、Update、Delete操作Realm中所有增删改的操作都必须在事物中完成(a write transaction)。Realm提供了两种创建事务的方法Realm.BeginWrite()和Realm.Write()。 Realm.BeginWrite()返回Transaction对象，Transaction实现了Dispose接口，所以Realm.BeginWrite()通常与using代码块一起使用自动释放Transaction对象。所有操作结束后应手动调用Transaction的Commit方法提交事务。使用方式如下： Realm.Write()参数为一个Action对象，通常传入一个lambda表达式，当lambda主体中代码执行完成没有异常时会自动提交事务。使用方式如下： 更多介绍见Demo。 Demo介绍TaskUser实体定义 TaskRecord实体定义 AddPage布局中使用DatePicker控件bindingTaskRecord的日期，DatePicker绑定的值为DateTime类型，Realm中用DateTimeOffset类型表示时间，所以必须增加一个Ignored特性标记的DateTime类型作为中间转换值。 任务列表页定义 任务列表页CS文件代码 任务添加（修改）页定义 任务添加（修改）页CS文件定义 Demo效果图","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Realm","slug":"Realm","permalink":"http://xamarin.xyz/tags/Realm/"}]},{"title":"5种方法提高Xamarn.Forms应用启动速度","slug":"5种方法提高Xamarn-Forms应用启动速度","date":"2017-06-17T14:13:00.000Z","updated":"2017-11-04T02:17:33.000Z","comments":true,"path":"2017/06/17/5种方法提高Xamarn-Forms应用启动速度/","link":"","permalink":"http://xamarin.xyz/2017/06/17/5种方法提高Xamarn-Forms应用启动速度/","excerpt":"此篇为译文，原文地址：https://blog.xamarin.com/5-ways-boost-xamarin-forms-app-startup-time/","text":"此篇为译文，原文地址：https://blog.xamarin.com/5-ways-boost-xamarin-forms-app-startup-time/ 1.优先加载本地缓存数据应用程序第一次加载数据应该提供Loading提示，对必要数据进行本地缓存，应用程序下次启动时优先加载本地缓存数据，再合适时间在获取服务器最新数据。同时对数据的处理等耗时操作在服务器端进行。 2.资源文件优化为不同尺寸设备提供不同资源尺寸，避免操作系统帮助我们处理资源尺寸，加快渲染速度。 Android多屏幕支持介绍 ldpi (low) ~120dpi mdpi (medium) ~160dpi hdpi (high) ~240dpi xhdpi (extra-high) ~320dpi xxhdpi (extra-extra-high) ~480dpi xxxhdpi (extra-extra-extra-high) ~640dpi Xamarin.Android 7.0提供了AndroidExplicitCrunch资源属性，加快项目编译速度。开启该功能，打开Android的csproj文件对PropertyGroup节点做如下修改： iOS图标、图片尺寸 下面是网上找的一个关于iOS和Android设计规范的一个总结尺寸 3.延迟加载一些统一样式和字体为了方便调用我们通常会将这些资源放在App.xaml Resources中，App.xaml中的资源在应用程序启动时会全部加载，如果想进一步加快应用程序启动，应将不必要的资源放到单独的页面中。 4.编译XAMLForms中有C#和XAML两种方式定义界面，使用C#代码定义界面，定义界面的代码会随着其他代码一起编译，加快编译速度。XAML Compilation(XAMLC)可以帮助我们在使用XAML定义界面时达到同样的效果，并提供编译时检查。XAMLC把XAML转换成Intermediate Language (IL) 添加到程序集中，加快启动速度和提高运行效率。 XAMLC有两种声明方式： 1.程序集级启用XAMLC，影响整个应用程序 2.类级别启用XAMLC，只对当前累起作用 5.减少程序集的引用当我们的应用程序添加了过多的引用会拖慢应用程序的执行速度。 Xamarin.Forms for example inspects all assemblies for [ExportRenderer] attributes and currently has no method to opt-in or opt-out. This is something we’re working to improve.这句话是不是说还没有好的解决办法！英语太差，没懂！！！ 技巧1:Ahead of Time Compilation (AOT)预编译（AOT）功能目前仅适用于Android，iOS 默认启用 AOT 和 LLVM compiler。 如下图方式开启Android AOT功能，开启该功能能改善启动速度和减少即时编译的开销，代价是会增加应用程序大小，所以应综合考虑是否启用该功能。 Note: AOT is available on Xamarin Android 5.1 and 7.0+ 技巧2:加快生成速度来自Xamarin工程师分享的一些经验，地址：https://github.com/brminnick/ImproveXamarinBuildTimes 更多优化信息请阅读：https://developer.xamarin.com/guides/xamarin-forms/deployment-testing/performance/ 获取最新咨询请关注公众号：XamarinTop或扫描如下二维码","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms 录屏介绍","slug":"Xamarin-Forms-录屏介绍","date":"2017-06-13T00:45:00.000Z","updated":"2017-11-04T02:40:01.720Z","comments":true,"path":"2017/06/13/Xamarin-Forms-录屏介绍/","link":"","permalink":"http://xamarin.xyz/2017/06/13/Xamarin-Forms-录屏介绍/","excerpt":"Android原生项目中涉及到录屏相关的内容（MediaProjectionManager），就尝试写了Forms版本的录屏功能，系统要求Android 5.0+，iOS 9.0+。iOS下实现录屏比较简单，通过RPScreenRecorder.SharedRecorder.StartRecording方法调用iOS9.0中加入的录屏功能。","text":"Android原生项目中涉及到录屏相关的内容（MediaProjectionManager），就尝试写了Forms版本的录屏功能，系统要求Android 5.0+，iOS 9.0+。iOS下实现录屏比较简单，通过RPScreenRecorder.SharedRecorder.StartRecording方法调用iOS9.0中加入的录屏功能。 Android原生项目中涉及到录屏相关的内容（MediaProjectionManager），就尝试写了Forms版本的录屏功能，系统要求Android 5.0+，iOS 9.0+。 iOS录屏实现iOS下实现录屏比较简单，通过RPScreenRecorder.SharedRecorder.StartRecording方法调用iOS9.0中加入的录屏功能。 首次调用录屏会提示用户是否允许录屏，用户允许后接下来的8分钟都不会再提示。 调用RPScreenRecorder.SharedRecorder.StopRecording停止录屏，录屏结束后可以通过RPPreviewViewController来预览录制的视频内容，也可以调用RPScreenRecorder.SharedRecorder.DiscardRecording丢弃录制的视频。 结束录屏后的预览界面： 预览界面点击Cancel或者Save都会调用iOS中RPPreviewViewControllerDelegate委托 的两个DidFinish方法。点击Cancel操作调用DidFinish(RPPreviewViewController previewController)方法，保存和分享操作调用重载方法DidFinish(RPPreviewViewController previewController, Foundation.NSSet&lt;Foundation.NSString&gt; activityTypes)。 Android录屏原生参考：http://www.truiton.com/2015/05/capture-record-android-screen-using-mediaprojection-apis/ 初始化MediaProjectionManager对象，调用MediaProjectionManager对象的CreateScreenCaptureIntent方法创建意图，通过StartActivityForResult方法启动系统提供的录屏功能。 屏蔽麦克风声音没有实现 在Activity的OnActivityResult方法中接收录屏数据。 Android项目中通过继承DialogFragment自定义了两个Dialog，PromptDialog和PreviewDialog，PromptDialog用来确认用户的操作，是否放弃以录制视频。PreviewDialog模仿iOS端实现的视频预览，以达到相似的用户体验。 目前已知的问题是VideoView被Toolbar遮挡，布局无效。MediaController播放控制不能显示。 项目地址：https://github.com/MyueX/ScreenRecorder 获取最新咨询请关注公众号：XamarinTop或扫描如下二维码","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms 3.0初体验(一)","slug":"Xamarin-Forms-3-0初体验(一)","date":"2017-06-09T01:19:00.000Z","updated":"2017-11-04T02:41:04.000Z","comments":true,"path":"2017/06/09/Xamarin-Forms-3-0初体验(一)/","link":"","permalink":"http://xamarin.xyz/2017/06/09/Xamarin-Forms-3-0初体验(一)/","excerpt":"关于Xamarin.Forms 的roadmap可以参考：https://forums.xamarin.com/discussion/85747/xamarin-forms-feature-roadmap/p1","text":"关于Xamarin.Forms 的roadmap可以参考：https://forums.xamarin.com/discussion/85747/xamarin-forms-feature-roadmap/p1 更新Forms3.0包 Add a new source to your NuGet Manager: https://www.myget.org/F/xamarinforms-dev/api/v3/index.json Check Pre-Release Select and install the package with the feature name “Embedding” – 3.0.0.100-embeddingpreview Xamarin.Forms 是建立在Xamarin.iOS 和 Xamarin.Android基础上的，所以Xamarin.Forms 的页面和Xamarin.iOS、Xamarin.Android的页面应该是可以相互调用的。Xamarin.iOS、Xamarin.Android中嵌入Forms页面是Forms3.0的一个新功能。 Xamarin Native页面和Forms页面相互跳转 新建一个Blank Native App在公共项目中定义一个Forms Page Button的Click响应代码为： 通过MessagingCenter.Send发送消息通知。 核心介绍Forms 页面嵌入到Xamarin.iOS或Xamarin.Android原生项目中核心代码是调用Forms.Init()方法初始化，后续再调用Forms Page对象的扩展方法创建对应实例。iOS中为CreateViewController方法创建对应的UIViewController。Android中为CreateFragment方法创建对应的Fragment，再次说明Xamarin.Forms的Android程序只有一个Activity，每个页面都是一个Fragment。UWP中为CreateFrameworkElement方法。 修改iOS Native项目代码核心代码为先调用Forms.Init()方法初始化，后续再调用Forms Page对象的CreateViewController方法创建对应的UIViewController。在AppDelegate中增加如下代码： 通过MessagingCenter.Subscribe订阅消息以响应Forms Page中的按钮点击事件。 同时增加一个ShowFormsPage方法： Native Page 跳转到Forms Page： Storyboard中布局和iOS原生开发相关知识不做过多介绍。 修改Android Native项目代码首先修改MainActivity中布局由FrameLayout实现。 修改MainActivity中的OnCreate方法： MainActivity中增加代码： 文中只给出了部分代码片段，完整项目地址：https://github.com/MyueX/forms3.0_1 获取最新咨询请关注公众号：XamarinTop或扫描如下二维码","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms 新版本中Device.OS过时和OnPlatform使用的改变","slug":"Xamarin-Forms-新版本中Device-OS过时和OnPlatform使用的改变","date":"2017-05-15T14:13:00.000Z","updated":"2017-11-02T14:01:43.000Z","comments":true,"path":"2017/05/15/Xamarin-Forms-新版本中Device-OS过时和OnPlatform使用的改变/","link":"","permalink":"http://xamarin.xyz/2017/05/15/Xamarin-Forms-新版本中Device-OS过时和OnPlatform使用的改变/","excerpt":"","text":"太久没有写Xamarin的代码，更新到vs for mac 正式版后发现一下代码已经出现警告。新版本中一下代码已经提示警告： 大概就是这么个情况 Device.OS已经过时，使用RuntimePlatform代替。 RuntimePlatform定义为string类型，TargetPlatform并不能在提供枚举值用来判断当前运行时平台类型。 Device点智能提示已经给出了解决办法： 修改代码如下： 同样过时的还有OnPlatform的两个重载方法： 使用switch语句代替，查看OnPlatform实现代码可以发现，就是OnPlatform内封装的代码由我们自己来实现： Xaml中经常会用到OnPlatform类代替Device类在布局代码中对不同平台设置不同的值，典型的就是iOS中页面Padding属性的设置： 查看OnPlatform类定义，对应的Android、iOS等属性已经过时： 代替代码","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"OnPlatform","slug":"OnPlatform","permalink":"http://xamarin.xyz/tags/OnPlatform/"}]},{"title":"Xamarin.Forms 应用程序国际化","slug":"Xamarin-Forms-应用程序国际化","date":"2017-04-20T05:31:00.000Z","updated":"2017-11-04T02:38:45.000Z","comments":true,"path":"2017/04/20/Xamarin-Forms-应用程序国际化/","link":"","permalink":"http://xamarin.xyz/2017/04/20/Xamarin-Forms-应用程序国际化/","excerpt":"官网看到关于Forms应用程序国际化的相关内容，便一边练习一边总结一下，虽然这部分知识点很可能永远用不到！！！原文地址:https://developer.xamarin.com/zh-cn/guides/xamarin-forms/advanced/localization/","text":"官网看到关于Forms应用程序国际化的相关内容，便一边练习一边总结一下，虽然这部分知识点很可能永远用不到！！！原文地址:https://developer.xamarin.com/zh-cn/guides/xamarin-forms/advanced/localization/ 官网看到关于Forms应用程序国际化的相关内容，便一边练习一边总结一下，虽然这部分知识点很可能永远用不到！！！原文地址:https://developer.xamarin.com/zh-cn/guides/xamarin-forms/advanced/localization/ Xamarin.Forms PCL 国际化Forms PCL中的国际化借助资源文件（RESX）实现。 准备资源文件在可移植项目中添加资源文件： 会在项目中生成如下两个文件： 同时添加Resources.en.resx文件，提供英文环境下使用的字符串。记得修改文件的生成操作为EmbeddedResource。 Xamarin Studio添加名称为Resources.en资源文件时提示Resources文件已经存在,此时可以先添加名称为Resources1的资源文件，然后修改Resources1.resx和Resources1.Designer.resx文件的名称为Resources.en.resx和Resources.en.Designer.resx Designer.cs文件不做修改，编辑.resx文件。Resources.resx 添加如下data元素：1234&lt;data name=\"home\" xml:space=\"preserve\"&gt; &lt;value&gt;首页&lt;/value&gt; &lt;comment&gt;home page title&lt;/comment&gt;&lt;/data&gt; Resources.en.resx 添加如下data元素：1234&lt;data name=\"home\" xml:space=\"preserve\"&gt; &lt;value&gt;Home&lt;/value&gt; &lt;comment&gt;home page title&lt;/comment&gt;&lt;/data&gt; 生成项目Designer.cs文件生成如下代码： 为了获取name为home对应的值需要调用如下代码Resource.Resources.ResourceManager.GetString(&quot;home&quot;)其中Resource为resx文件所在文件夹，Resources为根据文件名生成的类。简化资源文件中字符串资源的获取，resx文件右键—&gt;属性。 修改自定义工具对应的属性值：ResXFileCodeGenerator修改为PublicResXFileCodeGenerator。 ResXFileCodeGenerator，PublicResXFileCodeGenerator，他们的区别是前者生成的Internal的，后者生成的是Public的资源。 重新生成项目，此时可以通过如下代码Resource.Resources.home获取home对应的值。 确定当前运行平台的语言环境Forms本身并没有提供获取运行平台语言环境的功能，我们需要借助dependency service 实现。 在可移植项目中定义如下接口：12345678910111213141516171819202122232425 /// &lt;summary&gt;/// Implementations of this interface MUST convert iOS and Android/// platform-specific locales to a value supported in .NET because/// ONLY valid .NET cultures can have their RESX resources loaded and used./// &lt;/summary&gt;/// &lt;remarks&gt;/// Lists of valid .NET cultures can be found here:/// http://www.localeplanet.com/dotnet//// http://www.csharp-examples.net/culture-names//// You should always test all the locales implemented in your application./// &lt;/remarks&gt;public interface ILocalize&#123; /// &lt;summary&gt; /// This method must evaluate platform-specific locale settings /// and convert them (when necessary) to a valid .NET locale. /// &lt;/summary&gt; CultureInfo GetCurrentCultureInfo(); /// &lt;summary&gt; /// CurrentCulture and CurrentUICulture must be set in the platform project, /// because the Thread object can&apos;t be accessed in a PCL. /// &lt;/summary&gt; void SetLocale(CultureInfo ci);&#125; 同时定义帮助类PlatformCulture： 1234567891011121314151617181920212223242526272829303132333435 /// &lt;summary&gt;/// Helper class for splitting locales like/// iOS: ms_MY, gsw_CH/// Android: in-ID/// into parts so we can create a .NET culture (or fallback culture)/// &lt;/summary&gt;public class PlatformCulture&#123; public PlatformCulture(string platformCultureString) &#123; if (String.IsNullOrEmpty(platformCultureString)) throw new ArgumentException(&quot;Expected culture identifier&quot;, &quot;platformCultureString&quot;); // in C# 6 use nameof(platformCultureString) PlatformString = platformCultureString.Replace(&quot;_&quot;, &quot;-&quot;); // .NET expects dash, not underscore var dashIndex = PlatformString.IndexOf(&quot;-&quot;, StringComparison.Ordinal); if (dashIndex &gt; 0) &#123; var parts = PlatformString.Split(&apos;-&apos;); LanguageCode = parts[0]; LocaleCode = parts[1]; &#125; else &#123; LanguageCode = PlatformString; LocaleCode = &quot;&quot;; &#125; &#125; public string PlatformString &#123; get; private set; &#125; public string LanguageCode &#123; get; private set; &#125; public string LocaleCode &#123; get; private set; &#125; public override string ToString() &#123; return PlatformString; &#125;&#125; 在App类中构造方法中添加如下代码，如果当前运行系统为ios或android需要获取当前系统对应.net表示的语言环境并设置为当前的语言环境： 1234567if (Device.RuntimePlatform == Device.iOS || Device.RuntimePlatform == Device.Android)&#123; var localize = DependencyService.Get&lt;ILocalize&gt;(); var ci = localize.GetCurrentCultureInfo(); //Resource.Resources.Culture = ci;// set the RESX for resource localization localize.SetLocale(ci); // set the Thread for locale-aware methods&#125; ios下 ILocalize 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596[assembly: Xamarin.Forms.Dependency(typeof(demo.iOS.Localize))]namespace demo.iOS&#123; public class Localize : ILocalize &#123; public void SetLocale(CultureInfo ci) &#123; Thread.CurrentThread.CurrentCulture = ci; Thread.CurrentThread.CurrentUICulture = ci; Console.WriteLine(&quot;CurrentCulture set: &quot; + ci.Name); &#125; public CultureInfo GetCurrentCultureInfo() &#123; var netLanguage = &quot;en&quot;; if (NSLocale.PreferredLanguages.Length &gt; 0) &#123; var pref = NSLocale.PreferredLanguages[0]; netLanguage = iOSToDotnetLanguage(pref); &#125; // this gets called a lot - try/catch can be expensive so consider caching or something System.Globalization.CultureInfo ci = null; try &#123; ci = new System.Globalization.CultureInfo(netLanguage); &#125; catch (CultureNotFoundException e1) &#123; // iOS locale not valid .NET culture (eg. &quot;en-ES&quot; : English in Spain) // fallback to first characters, in this case &quot;en&quot; try &#123; var fallback = ToDotnetFallbackLanguage(new PlatformCulture(netLanguage)); Console.WriteLine(netLanguage + &quot; failed, trying &quot; + fallback + &quot; (&quot; + e1.Message + &quot;)&quot;); ci = new System.Globalization.CultureInfo(fallback); &#125; catch (CultureNotFoundException e2) &#123; // iOS language not valid .NET culture, falling back to English Console.WriteLine(netLanguage + &quot; couldn&apos;t be set, using &apos;en&apos; (&quot; + e2.Message + &quot;)&quot;); ci = new System.Globalization.CultureInfo(&quot;en&quot;); &#125; &#125; return ci; &#125; string iOSToDotnetLanguage(string iOSLanguage) &#123; Console.WriteLine(&quot;iOS Language:&quot; + iOSLanguage); var netLanguage = iOSLanguage; //certain languages need to be converted to CultureInfo equivalent switch (iOSLanguage) &#123; case &quot;ms-MY&quot;: // &quot;Malaysian (Malaysia)&quot; not supported .NET culture case &quot;ms-SG&quot;: // &quot;Malaysian (Singapore)&quot; not supported .NET culture netLanguage = &quot;ms&quot;; // closest supported break; case &quot;gsw-CH&quot;: // &quot;Schwiizertüütsch (Swiss German)&quot; not supported .NET culture netLanguage = &quot;de-CH&quot;; // closest supported break; // add more application-specific cases here (if required) // ONLY use cultures that have been tested and known to work &#125; Console.WriteLine(&quot;.NET Language/Locale:&quot; + netLanguage); return netLanguage; &#125; string ToDotnetFallbackLanguage(PlatformCulture platCulture) &#123; Console.WriteLine(&quot;.NET Fallback Language:&quot; + platCulture.LanguageCode); var netLanguage = platCulture.LanguageCode; // use the first part of the identifier (two chars, usually); switch (platCulture.LanguageCode) &#123; // case &quot;pt&quot;: netLanguage = &quot;pt-PT&quot;; // fallback to Portuguese (Portugal) break; case &quot;gsw&quot;: netLanguage = &quot;de-CH&quot;; // equivalent to German (Switzerland) for this app break; // add more application-specific cases here (if required) // ONLY use cultures that have been tested and known to work &#125; Console.WriteLine(&quot;.NET Fallback Language/Locale:&quot; + netLanguage + &quot; (application-specific)&quot;); return netLanguage; &#125; &#125;&#125; Android下 ILocalize 实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293[assembly: Xamarin.Forms.Dependency(typeof(demo.Droid.Localize))]namespace demo.Droid&#123; public class Localize : ILocalize &#123; public void SetLocale(CultureInfo ci) &#123; Thread.CurrentThread.CurrentCulture = ci; Thread.CurrentThread.CurrentUICulture = ci; Console.WriteLine(&quot;CurrentCulture set: &quot; + ci.Name); &#125; public CultureInfo GetCurrentCultureInfo() &#123; var netLanguage = &quot;en&quot;; var androidLocale = Java.Util.Locale.Default; netLanguage = AndroidToDotnetLanguage(androidLocale.ToString().Replace(&quot;_&quot;, &quot;-&quot;)); // this gets called a lot - try/catch can be expensive so consider caching or something System.Globalization.CultureInfo ci = null; try &#123; ci = new System.Globalization.CultureInfo(netLanguage); &#125; catch (CultureNotFoundException e1) &#123; // iOS locale not valid .NET culture (eg. &quot;en-ES&quot; : English in Spain) // fallback to first characters, in this case &quot;en&quot; try &#123; var fallback = ToDotnetFallbackLanguage(new PlatformCulture(netLanguage)); Console.WriteLine(netLanguage + &quot; failed, trying &quot; + fallback + &quot; (&quot; + e1.Message + &quot;)&quot;); ci = new System.Globalization.CultureInfo(fallback); &#125; catch (CultureNotFoundException e2) &#123; // iOS language not valid .NET culture, falling back to English Console.WriteLine(netLanguage + &quot; couldn&apos;t be set, using &apos;en&apos; (&quot; + e2.Message + &quot;)&quot;); ci = new System.Globalization.CultureInfo(&quot;en&quot;); &#125; &#125; return ci; &#125; string AndroidToDotnetLanguage(string androidLanguage) &#123; Console.WriteLine(&quot;Android Language:&quot; + androidLanguage); var netLanguage = androidLanguage; //certain languages need to be converted to CultureInfo equivalent switch (androidLanguage) &#123; case &quot;ms-BN&quot;: // &quot;Malaysian (Brunei)&quot; not supported .NET culture case &quot;ms-MY&quot;: // &quot;Malaysian (Malaysia)&quot; not supported .NET culture case &quot;ms-SG&quot;: // &quot;Malaysian (Singapore)&quot; not supported .NET culture netLanguage = &quot;ms&quot;; // closest supported break; case &quot;in-ID&quot;: // &quot;Indonesian (Indonesia)&quot; has different code in .NET netLanguage = &quot;id-ID&quot;; // correct code for .NET break; case &quot;gsw-CH&quot;: // &quot;Schwiizertüütsch (Swiss German)&quot; not supported .NET culture netLanguage = &quot;de-CH&quot;; // closest supported break; // add more application-specific cases here (if required) // ONLY use cultures that have been tested and known to work &#125; Console.WriteLine(&quot;.NET Language/Locale:&quot; + netLanguage); return netLanguage; &#125; string ToDotnetFallbackLanguage(PlatformCulture platCulture) &#123; Console.WriteLine(&quot;.NET Fallback Language:&quot; + platCulture.LanguageCode); var netLanguage = platCulture.LanguageCode; // use the first part of the identifier (two chars, usually); switch (platCulture.LanguageCode) &#123; case &quot;gsw&quot;: netLanguage = &quot;de-CH&quot;; // equivalent to German (Switzerland) for this app break; // add more application-specific cases here (if required) // ONLY use cultures that have been tested and known to work &#125; Console.WriteLine(&quot;.NET Fallback Language/Locale:&quot; + netLanguage + &quot; (application-specific)&quot;); return netLanguage; &#125; &#125;&#125; 代码设置Page的Title属性Title = Resource.Resources.home;。 更改系统语言环境会有如下显示效果： Doesn’t work in DEBUG mode (Android only)If the translated strings are working in your RELEASE Android builds but not while debugging, right-click on the Android Project and select Options &gt; Build &gt; Android Build and ensure that the Fast assembly deployment is NOT ticked. This option causes problems with loading resources and should not be used if you are testing localized apps. XAML中实现国际化很多时候我们会直接在Xaml中设置文本值的显示，如：&lt;Label Text=&quot;Notes:&quot; /&gt;。但是Xaml并没有提供翻译功能，需要我们通过自定义扩展标记(markup extension)实现。 123456789101112131415161718192021222324252627282930313233343536373839 [ContentProperty(&quot;Text&quot;)] public class TranslateExtension : IMarkupExtension &#123; readonly CultureInfo ci; //指定为项目中默认资源文件ID const string ResourceId = &quot;demo.Resource.Resources&quot;; public TranslateExtension() &#123; if (Device.RuntimePlatform == Device.iOS || Device.RuntimePlatform == Device.Android) &#123; ci = DependencyService.Get&lt;ILocalize&gt;().GetCurrentCultureInfo(); &#125; &#125; public string Text &#123; get; set; &#125; public object ProvideValue(IServiceProvider serviceProvider) &#123; if (Text == null) return &quot;&quot;; ResourceManager resmgr = new ResourceManager(ResourceId, GetType().GetTypeInfo().Assembly); var translation = resmgr.GetString(Text, ci); if (translation == null) &#123;#if DEBUG throw new ArgumentException( String.Format(&quot;Key &apos;&#123;0&#125;&apos; was not found in resources &apos;&#123;1&#125;&apos; for culture &apos;&#123;2&#125;&apos;.&quot;, Text, ResourceId, ci.Name), &quot;Text&quot;);#else translation = Text; // HACK: returns the key, which GETS DISPLAYED TO THE USER#endif &#125; return translation; &#125; &#125; Xaml中通过如下代码设置标题：xmlns:local=&quot;clr-namespace:demo&quot; Title=&quot;{local:Translate home}&quot; 中英文显示效果： 平台元素国际化如应用程序的名称、图标和启动屏中涉及的元素国际化时需要在单独的平台项目中设置，不需要编写代码故不在记录。 参考：https://developer.xamarin.com/zh-cn/guides/xamarin-forms/advanced/localization/#Localizing_Platform-Specific_Elements http://blog.csdn.net/watermelon_/article/details/53418615 http://blog.csdn.net/chenliguan/article/details/50678678 项目地址：https://github.com/MyueX/xamarin.forms_news_demo","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Localizing","slug":"Localizing","permalink":"http://xamarin.xyz/tags/Localizing/"}]},{"title":"Xamarin.Forms 自定义布局介绍","slug":"Xamarin-Forms-自定义布局介绍","date":"2016-11-29T04:08:00.000Z","updated":"2017-11-04T02:38:11.280Z","comments":true,"path":"2016/11/29/Xamarin-Forms-自定义布局介绍/","link":"","permalink":"http://xamarin.xyz/2016/11/29/Xamarin-Forms-自定义布局介绍/","excerpt":"Xamarin.Forms中提供了StackLayout、AbsoluteLayout、RelativeLayout、Grid四个布局类，借助这四个类可以方便的管理程序的布局。当现有布局类不能满足我们的功能时，可以通过自定义布局实现想要的效果。 在讲解布局时提到过StackLayout等继承Layout类，可以管理多个子视图。如果继承Layout类，只能管理单一子视图，如ContentView、Frame、ScrollView等。","text":"Xamarin.Forms中提供了StackLayout、AbsoluteLayout、RelativeLayout、Grid四个布局类，借助这四个类可以方便的管理程序的布局。当现有布局类不能满足我们的功能时，可以通过自定义布局实现想要的效果。 在讲解布局时提到过StackLayout等继承Layout类，可以管理多个子视图。如果继承Layout类，只能管理单一子视图，如ContentView、Frame、ScrollView等。 Xamarin.Forms中提供了StackLayout、AbsoluteLayout、RelativeLayout、Grid四个布局类，借助这四个类可以方便的管理程序的布局。当现有布局类不能满足我们的功能时，可以通过自定义布局实现想要的效果。 在讲解布局时提到过StackLayout等继承Layout类，可以管理多个子视图。如果继承Layout类，只能管理单一子视图，如ContentView、Frame、ScrollView等。 布局概述布局类是如何管理子视图的（确定子视图的大小和位置）？ 先看一个简单示例，HorizontalOptions和VerticalOptions属性默认值为LayoutOptions.Fill。 显示效果，从红色外边框看出Frame大小为Page大小： 对Frame属性做如下修改： 对应显示效果 HorizontalOptions=&quot;Center&quot; VerticalOptions=&quot;Center&quot;属性用来确定子视图大小，Frame请求大小为内部Label大小，再通过指定WidthRequest=&quot;1000&quot;明确Frame的宽度。从效果图看出布局分配给子视图的大小由子视图请求决定但又不能超出布局大小。 布局（父元素）如何才能知道子元素的大小？子元素应提供一个公共方法由父元素调用，这个方法为Layout,Layout方法定义在VisualElement中。 Layout方法接收一个Rectangle类型参数bounds。查看Bounds属性定义 Bounds属性的Set操作声明为private，且通过Set内代码看出Bounds的值即元素的显示位置（X，Y）和大小（Width，Height）。 一个页面显示时首先会调用Page对象的Layout方法，Layout方法内在通过视图元素树（visual tree）依次调用子元素的Layout方法，这个过程称为布局的生命周期。旋转手机时会重新开始这个布局周期，这个布局周期也可以发生在元素树的一个子集内，如添加或移除子视图等操作都会调用父元素的Layout方法。 视图的X，Y，Width和Height等属性都是在布局的生命周期执行后被赋予一个有效值，视图的构造函数内无法获取有效值。X、Y的默认值为0，Width和Height的默认值为－1。 执行Layout方法会一次调用SetSize-&gt;SizeAllocated方法。SizeAllocated方法接收的width和htight参数为Bounds属性的Width和Heiht值，SizeAllocated方法内部又调用一个虚方法OnSizeAllocated。OnSizeAllocated执行完，此时视图的大小已经发生变化，同时出发SizeChanged事件。 OnSizeAllocated方法用virtual关键字声明，但是只允许Page和Layout两个类重写该方法进行特殊处理。 As an alternative to the SizeChanged event, it is possible for an application to override OnSizeAllocated in a ContentPage derivative to obtain the new size of the page. (If you do so, be sure to call the base class implementation of OnSizeAllocated.) You’ll find that OnSizeAllocated is sometimes called when the element’s size doesn’t actually change. The SizeChanged event is fired only when the size changes, and it’s better for size-specific handling on the application level. Page类内OnSizeAllocated方法实现(Layout内相同)，调用UpdateChildrenLayout： 查看UpdateChildrenLayout方法定义，UpdateChildrenLayout方法中调用LayoutChildren方法，并在方法结束前触发LayoutChanged事件。 LayoutChildren方法在Page和Layout中有了不同的处理，Page类中LayoutChildren方法定义为virtual方法，Layout类中LayoutChildren定义为abstract方法。 Page类中LayoutChildren的定义： Layout类中LayoutChildren的定义： LayoutChildren是一个很重要的方法。查看Page的LayoutChildren方法代码实现循环所有子元素进入LayoutChildIntoBoundingRegion方法。 LayoutChildIntoBoundingRegion是一个静态方法，方法内部判断当前元素是否为视图，传入元素不是视图（即布局）则调用子布局的Layout方法，此时再次回到Layout方法，从而完成布局生命周期的调用过程。当我们继承Layout编写自定义布局时应实现该方法以管理子视图。 Layout传值到LayoutChildren时应考虑Padding属性值。如下布局所示，在360＊640的设备上，Page的Layout方法接收到的X,Y,Width,Height为(0, 0, 360, 640)，此时没有设置Padding 值传到LayoutChildren方法接收的值同样是(0, 0, 360, 640)，LayoutChildren方法内调用ContentView的Layout方法，所以ContentView的Layout方法接收到Bound的X，Y，Width和Height值不变(0, 0, 360, 640)。在ContentView的Layout方法传值到LayoutChildren方法此时Padding值为15，所以Width和Height减少30（上下左右各减少15）并且X和Y的值增加15。LayoutChildren接收到的值为（15,15,330,610），LayoutChildren方法内调用Label的Layout，此时接收到的Bounds属性对应的X，Y，Width和Height分别为（15,15,330,610）。 在Page的LayoutChildIntoBoundingRegion方法中，传入child是一个View则调用子视图的Measure（过时方法为GetSizeRequest）方法计算子视图需要的大小，（此时child的Bounds属性或Width和Height属性还没有赋予有效值）。 调用子元素的Layout方法前会调用Measure方法，Layout方法的参数取决Measure返回的结果。 widthConstraint 和 heightConstraint表示宽高的约束值，表示父元素可以提供多少可用空间用来布局子元素。Measure方法内计算出所有子元素所需的大小与widthConstraint和heightConstraint比较，取较小值创建SizeRequest类型实例返回，SizeRequest包含Minimum和Request两个Size类型属性。Request表示元素需要的大小，Minimum表示元素的最小大小。 通常Minimum和Request两个属性赋予相同值，Xamarin.Forms中ListView和TabeView两个元素对应的Minimum和Request值不同，Minimum的值为(40,40)。然而Minimum的值并没什么用。 Measure内部调用已经过时的GetSizeRequest方法。 GetSizeRequest会调用OnMeasure方法，OnMeasure定义为虚方法。OnMeasure方法也是我们自定义布局时必须要重写的方法。 布局重绘当元素的某些属性改变时会影响元素的大小，此时会引起元素的重绘。VisualElement定义一个InvalidateMeasure方法重绘元素，InvalidateMeasure是一个受保护的方法。自定义View时有某个BindableProperty类型属性可能改变元素大小，应该在该属性的propertyChanged内调用InvalidateMeasure方法。 AnchorX, AnchorY, Rotation, RotationX, RotationY, Scale, TranslationX, TranslationY等属性影响的是元素的渲染大小并不能改变元素的布局大小，值的改变不会触发MeasureInvalidated事件。Bounds, X, Y, Width,Height等属性在Layout方法内被调用，这几个属性改变时同样不会调用InvalidateMeasure方法。 InvalidateMeasure方法会触发MeasureInvalidated事件，以通知外部元素布局发生改变，通常是父元素处理MeasureInvalidated事件。 Layout类提供了一个类似的方法InvalidateLayout,当布局内属性发生改变影响子元素的大小和位置时应调用InvalidateLayout方法，如Layout中Children属性的added和removed操作会调用InvalidateLayout方法。 如果想阻止增加或移除子元素时InvalidateLayout方法的调用可以重写ShouldInvalidateOnChildAdded和ShouldInvalidateOnChildRemoved方法，返回false即可。代码片段截图看出，还将OnChildMeasureInvalidated方法作为参数实例化EventHandler监听view的MeasureInvalidated事件，实际编码时可以重写OnChildMeasureInvalidated方法接收MeasureInvalidated触发的通知。 Layout类定义了OnAdded和OnRemoved两个虚方法，分别在重写Element类的OnChildAdded和OnChildRemoved方法时调用，自定义布局时可以根据自己需要重写这两个方法。 Grid类重写OnAdded方法,添加子元素PropertyChanged监听示例（重写OnRemoved卸载监听，附加属性改变时调用InvalidateLayout方法，有兴趣可查看OnItemPropertyChanged内部实现）： 当我们必须重新绘制布局时，该调用InvalidateLayout还是InvalidateMeasure？调用InvalidateLayout重新开始一个布局周期！！！InvalidateMeasure方法适合改变了布局的大小且不影响子布局排列时调用。 In most cases, the layout should call InvalidateLayout. This guarantees that the layout gets a call to its LayoutChildren method even if the layout is fully constrained in size. If the layout calls InvalidateMeasure, then a new layout pass will be generated only if the layout is not fully constrained in size. If the layout is constrained in size, then a call to InvalidateMeasure will do nothing. 自定义布局示例通过继承Layout实现瀑布流布局（只是简单示例）。如果想限制布局内子元素的类型可以T来指定，如Layout。但更多时候是继承Layout。 重写LayoutChildren和OnMeasure方法，方法内循环所有子元素（忽略IsVisible属性为false的子元素）。LayoutChildren方法内调用Xamarin.Forms提供的LayoutChildIntoBoundingRegion（代替子元素的Layout 方法）方法简化编码，不必考虑LayoutOptions的值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161public class FlowLayout : Layout&lt;View&gt; &#123; public static readonly BindableProperty ColumnSpacingProperty = BindableProperty.Create( &quot;ColumnSpacing&quot;, typeof(double), typeof(FlowLayout), 6.0, propertyChanged: (bindable, oldvalue, newvalue) =&gt; &#123; ((FlowLayout)bindable).InvalidateLayout(); &#125;); public static readonly BindableProperty RowSpacingProperty = BindableProperty.Create( &quot;RowSpacing&quot;, typeof(double), typeof(FlowLayout), 6.0, propertyChanged: (bindable, oldvalue, newvalue) =&gt; &#123; ((FlowLayout)bindable).InvalidateLayout(); &#125;); public double ColumnSpacing &#123; set &#123; SetValue(ColumnSpacingProperty, value); &#125; get &#123; return (double)GetValue(ColumnSpacingProperty); &#125; &#125; public double RowSpacing &#123; set &#123; SetValue(RowSpacingProperty, value); &#125; get &#123; return (double)GetValue(RowSpacingProperty); &#125; &#125; protected override void LayoutChildren(double x, double y, double width, double height) &#123; double xChild = 0, yChild = 0; //循环子视图 foreach (View child in Children) &#123; if (!child.IsVisible) &#123; continue; &#125; SizeRequest childSizeRequest = child.Measure(width, height); // Initialize child position and size. var childWidth = childSizeRequest.Request.Width; var childHeight = childSizeRequest.Request.Height; if (xChild + childWidth &gt; width) &#123; xChild = 0; yChild += childHeight + RowSpacing; &#125; //判断HorizontalOptions和VerticalOptions的值计算子视图 x,y,width,height的值 //switch (child.HorizontalOptions.Alignment) //&#123; // case LayoutAlignment.Start: // break; // case LayoutAlignment.Center: // //xChild += (width - childWidth) / 2; // break; // case LayoutAlignment.End: // //xChild += (width - childWidth); // break; // case LayoutAlignment.Fill: // //childWidth = width; // break; //&#125; // Layout the child. LayoutChildIntoBoundingRegion(child, new Rectangle(xChild, yChild, width, childHeight)); xChild = xChild + childWidth + ColumnSpacing; &#125; &#125; /// &lt;summary&gt; /// 计算出显示子元素所需大小 /// &lt;/summary&gt; /// &lt;returns&gt;The measure.&lt;/returns&gt; /// &lt;param name=&quot;widthConstraint&quot;&gt;Width constraint.&lt;/param&gt; /// &lt;param name=&quot;heightConstraint&quot;&gt;Height constraint.&lt;/param&gt; protected override SizeRequest OnMeasure(double widthConstraint, double heightConstraint) &#123; var size = new Size(); var width = 0.0; //循环子视图 foreach (View child in Children) &#123; if (!child.IsVisible) &#123; continue; &#125; // Get the child&apos;s requested size. SizeRequest childSizeRequest = child.Measure(widthConstraint, Double.PositiveInfinity); // Initialize child position and size. var childWidth = childSizeRequest.Request.Width; var childHeight = childSizeRequest.Request.Height; if (width + childWidth &gt;= widthConstraint) &#123; size.Height = size.Height + childHeight + RowSpacing; &#125; else &#123; width = width + childWidth + ColumnSpacing; size.Width = Math.Max(size.Width, width); &#125; &#125; //widthConstraint或heightConstraint的值可能为Double.PositiveInfinity， //但是OnMeasure不能返回Double.PositiveInfinity所以不能有如下代码 //return new SizeRequest(new Size(widthConstraint, heightConstraint)); return new SizeRequest(size); &#125; #region 测试时编写的无关代码 protected override bool ShouldInvalidateOnChildAdded(View child) &#123; return false; &#125; protected override bool ShouldInvalidateOnChildRemoved(View child) &#123; return base.ShouldInvalidateOnChildRemoved(child); &#125; protected override void OnAdded(View view) &#123; base.OnAdded(view); //根据自己需要编码 &#125; protected override void OnRemoved(View view) &#123; base.OnRemoved(view); //根据自己需要编码 &#125; protected override void OnChildMeasureInvalidated() &#123; base.OnChildMeasureInvalidated(); &#125; #endregion &#125; XAML使用示例： 运行效果： 更多自定义布局介绍情查看《Creating Mobile Apps with Xamarin.Forms》","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Layout","slug":"Layout","permalink":"http://xamarin.xyz/tags/Layout/"}]},{"title":"Xamarin.Forms Custom Renderer介绍","slug":"Xamarin-Forms-Custom-Renderer介绍","date":"2016-11-21T12:32:00.000Z","updated":"2017-11-04T02:37:47.860Z","comments":true,"path":"2016/11/21/Xamarin-Forms-Custom-Renderer介绍/","link":"","permalink":"http://xamarin.xyz/2016/11/21/Xamarin-Forms-Custom-Renderer介绍/","excerpt":"Xamarin.Forms 开发过程中需要平台特殊定制时可以同过Custom Renderer实现。定义自己的Custom Renderer应继承ViewRenderer类，ViewRenderer是一个泛型类。ViewRenderer单独定义在不同平台中，Android平台在Xamarin.Forms.Platform.Android下,iOS平台在Xamarin.Forms.Platform.iOS下。ViewRenderer包含的两个范型参数TView和TNativeView（UWP下为TElement和TNativeElement），TView对应的是Xamarin.Forms中定义的视图元素，TNativeView则对应的是平台中定义的视图元素。","text":"Xamarin.Forms 开发过程中需要平台特殊定制时可以同过Custom Renderer实现。定义自己的Custom Renderer应继承ViewRenderer类，ViewRenderer是一个泛型类。ViewRenderer单独定义在不同平台中，Android平台在Xamarin.Forms.Platform.Android下,iOS平台在Xamarin.Forms.Platform.iOS下。ViewRenderer包含的两个范型参数TView和TNativeView（UWP下为TElement和TNativeElement），TView对应的是Xamarin.Forms中定义的视图元素，TNativeView则对应的是平台中定义的视图元素。 Xamarin.Forms 开发过程中需要平台特殊定制时可以同过Custom Renderer实现。定义自己的Custom Renderer应继承ViewRenderer类，ViewRenderer是一个泛型类。ViewRenderer单独定义在不同平台中，Android平台在Xamarin.Forms.Platform.Android下,iOS平台在Xamarin.Forms.Platform.iOS下。ViewRenderer包含的两个范型参数TView和TNativeView（UWP下为TElement和TNativeElement），TView对应的是Xamarin.Forms中定义的视图元素，TNativeView则对应的是平台中定义的视图元素。 通过Renderer自定义Label借助Renderer实现下带划线、删除线的Label。 Custom Renderer学习更多实例参靠：https://github.com/XLabs/Xamarin-Forms-Labs 在PCL项目中添加CustomLabel定义，如下：123456789101112131415161718192021222324252627282930313233343536public class CustomLabel:Label&#123; public CustomLabel() &#123; &#125; public static readonly BindableProperty IsUnderlineProperty = BindableProperty.Create(&quot;IsUnderline&quot;,typeof(bool), typeof(CustomLabel), false); public static readonly BindableProperty IsStrikeThroughProperty = BindableProperty.Create(&quot;IsStrikeThrough&quot;, typeof(bool), typeof(CustomLabel), false); public bool IsUnderline &#123; get &#123; return (bool)GetValue(IsUnderlineProperty); &#125; set &#123; SetValue(IsUnderlineProperty, value); &#125; &#125; public bool IsStrikeThrough &#123; get &#123; return (bool)GetValue(IsStrikeThroughProperty); &#125; set &#123; SetValue(IsStrikeThroughProperty, value); &#125; &#125;&#125; 接下来就是在相应的平台定义Renderer。一定要为定义好的Renderer添加ExportRenderer特性，ExportRenderer同Dependency特性一样是程序集特性，需要标记在命名空间块之外。 When a Xamarin.Forms application starts up, Xamarin.Forms uses .NET reflection to search through the various assemblies that comprise the application, looking for assembly attributes named ExportRenderer. An ExportRenderer attribute indicates the presence of a custom renderer that can supply support for a Xamarin.Forms element. 本文示例会有如下特性定义在namespace上：1[assembly: ExportRenderer(typeof(renderer.CustomLabel), typeof(renderer.iOS.CustomLabelRenderer))] 继承ViewRenderer的同时一定要重写OnElementChanged方法。该方法的作用是创建平台视图元素，会在CustomLabel初始化时调用。ViewRenderer定义了一个TNativeView类型属性Control，本示例中为UILabel。OnElementChanged第一次调用时Control属性为null，应该在OnElementChanged中初始化一个TNativeView元素，通过SetNativeControl方法赋值给Control属性。每一个Renderer实例都管理着一个平台视图对象（native object）即Control属性。 ViewRenderer还定义了一个Element属性，Element是我们定义的Xamarin.Forms元素，本示例中为CustomLabel类型。 OnElementChanged方法传入一个ElementChangedEventArgs范型参数,ElementChangedEventArgs有两个OldElement和NewElement属性，类型由ElementChangedEventArgs传入的T决定。如果NewElement不为null，NewElement与ViewRenderer的Element属性表示同一对象,根据NewElement的属性，为Control（Natice）设置相应属性。而OldElement属性通常用作回收资源。 1234567if (e.OldElement != null) &#123; // Unsubscribe from event handlers and cleanup any resources&#125;if (e.NewElement != null) &#123; // Configure the native control and subscribe to event handlers&#125; Android 自定义Renderer中OnElementChanged方法 CustomLabel中属性定义为BindableProperty类型，当BindableProperty类型属性改变时会触发PropertyChanged事件。Renderer对象同样会接收到BindableProperty发生改变的通知调用OnElementPropertyChanged方法。在OnElementPropertyChanged方法中判断e.PropertyName的值，为Control对应的原生视图元素设置相应属性。 根据以上介绍写出Android下自定义Renderer：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[assembly: ExportRenderer(typeof(renderer.CustomLabel), typeof(renderer.Droid.CustomLabelRenderer))]namespace renderer.Droid&#123; public class CustomLabelRenderer : ViewRenderer&lt;CustomLabel, TextView&gt; &#123; public CustomLabelRenderer() &#123; &#125; protected override void OnElementChanged(ElementChangedEventArgs&lt;CustomLabel&gt; e) &#123; base.OnElementChanged(e); if (Control == null) &#123; SetNativeControl(new TextView(Context)); &#125; if (e.NewElement != null) &#123; Control.Text = e.NewElement.Text; if (e.NewElement.IsUnderline) &#123; Control.PaintFlags = Control.PaintFlags | PaintFlags.UnderlineText; &#125; if (e.NewElement.IsStrikeThrough) &#123; Control.PaintFlags = Control.PaintFlags | PaintFlags.StrikeThruText; &#125; &#125; &#125; protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) &#123; base.OnElementPropertyChanged(sender, e); if (e.PropertyName == CustomLabel.IsUnderlineProperty.PropertyName) &#123; Control.PaintFlags = Control.PaintFlags | PaintFlags.UnderlineText; &#125; else if (e.PropertyName == CustomLabel.IsStrikeThroughProperty.PropertyName) &#123; Control.PaintFlags = Control.PaintFlags | PaintFlags.StrikeThruText; &#125; else if (e.PropertyName == CustomLabel.TextProperty.PropertyName) &#123; Control.Text = Element.Text; &#125; &#125; &#125;&#125; iOS同理Android不再过多说明。iOS项目中自定义Renderer：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950[assembly: ExportRenderer(typeof(renderer.CustomLabel), typeof(renderer.iOS.CustomLabelRenderer))]namespace renderer.iOS&#123; public class CustomLabelRenderer : ViewRenderer&lt;CustomLabel, UILabel&gt; &#123; public CustomLabelRenderer() &#123; &#125; protected override void OnElementChanged(ElementChangedEventArgs&lt;CustomLabel&gt; e) &#123; base.OnElementChanged(e); if (Control == null) &#123; SetNativeControl(new UILabel()); &#125; if (e.NewElement != null) &#123; InitView(e.NewElement); &#125; &#125; protected override void OnElementPropertyChanged(object sender, System.ComponentModel.PropertyChangedEventArgs e) &#123; base.OnElementPropertyChanged(sender, e); if (e.PropertyName == CustomLabel.IsUnderlineProperty.PropertyName || e.PropertyName == CustomLabel.IsStrikeThroughProperty.PropertyName || e.PropertyName == CustomLabel.TextProperty.PropertyName) &#123; InitView(Element); &#125; &#125; private void InitView(CustomLabel element) &#123; var underline = element.IsUnderline ? NSUnderlineStyle.Single : NSUnderlineStyle.None; var strikethrough = element.IsStrikeThrough ? NSUnderlineStyle.Single : NSUnderlineStyle.None; Control.AttributedText = new NSMutableAttributedString(element.Text, Control.Font, underlineStyle: underline, strikethroughStyle: strikethrough); &#125; &#125;&#125; XAML测试代码，CustomLabel定义在项目内，所以直接用上文定义好的local命名空间： Android 和iOS的运行效果： 原本iOS和Android中很容易实现的功能，再Xamarin.Forms中却变得有些复杂。。。。。,考虑开发成本和维护成本，这点痛算什么！三方库支持完善起来时Xamarin.Forms开发应该会比较乐观吧。 Xamarin.Forms中的每个视图（page, layout, view）都对应一个原生视图渲染，我们自定义时可以直接使用Xamarin.Forms提供的Renderer类。对应关系查看：https://developer.xamarin.com/guides/xamarin-forms/custom-renderer/renderers/","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Renderer","slug":"Renderer","permalink":"http://xamarin.xyz/tags/Renderer/"}]},{"title":"Xamarin.Forms Platform-Specific API","slug":"Xamarin-Forms-Platform-Specific-API","date":"2016-11-14T05:41:00.000Z","updated":"2017-11-04T02:33:12.190Z","comments":true,"path":"2016/11/14/Xamarin-Forms-Platform-Specific-API/","link":"","permalink":"http://xamarin.xyz/2016/11/14/Xamarin-Forms-Platform-Specific-API/","excerpt":"Xamarin.Forms 并不能支持每个平台的所用功能，如声音、视频播放和文件读写等功能需要我们单独为每个平台编码，也可以添加第三方组件扩展实现我们需要的功能，第三方组件可以在 https://components.xamarin.com 搜索或者通过Github搜索，本文主要记录编码调用平台特有API。代码实现又分Use Portable Class Library（PCL）和Use Shared Library（SAP）两种方式。Use Portable Class Library以可移植库方式创建项目所有代码会编译成一个独立的DLL，Use Shared Library方式创建项目是一个共享项目，项目中的代码会被每个平台共享使用。","text":"Xamarin.Forms 并不能支持每个平台的所用功能，如声音、视频播放和文件读写等功能需要我们单独为每个平台编码，也可以添加第三方组件扩展实现我们需要的功能，第三方组件可以在 https://components.xamarin.com 搜索或者通过Github搜索，本文主要记录编码调用平台特有API。代码实现又分Use Portable Class Library（PCL）和Use Shared Library（SAP）两种方式。Use Portable Class Library以可移植库方式创建项目所有代码会编译成一个独立的DLL，Use Shared Library方式创建项目是一个共享项目，项目中的代码会被每个平台共享使用。 Xamarin.Forms 并不能支持每个平台的所用功能，如声音、视频播放和文件读写等功能需要我们单独为每个平台编码，也可以添加第三方组件扩展实现我们需要的功能，第三方组件可以在 https://components.xamarin.com 搜索或者通过Github搜索，本文主要记录编码调用平台特有API。代码实现又分Use Portable Class Library（PCL）和Use Shared Library（SAP）两种方式。Use Portable Class Library以可移植库方式创建项目所有代码会编译成一个独立的DLL，Use Shared Library方式创建项目是一个共享项目，项目中的代码会被每个平台共享使用。 hared Library 方式编码 新建项目，选择Use Shared Library方式创建项目。 预处理命令使用SAP可以使用C#提供的#if、#elif、 #else 和#endif等C#与处理命令。为每个平台定义符号，IOS项目默认定义了__IOS__： 手动为Android项目添加__ANDROID__符号 实现一个Label显示平台系统版本信息的示例，iOS通过UIKit命名空间下的UIDevice类获取信息、Android通过Android.OS命名空间下的Build类获取信息（需要Xamarin.Android和Xamarin.IOS知识）： 通过与处理命令判断引用不同命名空间（当前启动项目为iOS项目，所以Android项目代码为灰色） 获取系统信息实现代码：12345678910#if __IOS__ UIDevice device = new UIDevice(); label1.Text = String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, device.SystemName, device.SystemVersion);#elif __ANDROID__ label1.Text = String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, Build.Model,Build.VERSION.Release);#endif 运行后效果图： 同名类调用SAP是一个扩展共享项目，平台项目和SAP项目之间可以相互调用，将每个项目的实现代码放在一个同名类中，SAP调用该类即可。 IOS项目定义一个DeviceInfo类 再为Android项目添加DeviceInfo类 SAP添加对应命名空间，调用DeviceInfo类 Portable Class Library 方式编码PCL项目会编译成一个独立的DLL，所以不能直接调用平台项目提供的代码，但是可以通过.NET的反射机制在PCL项目中调用平台项目代码。Xamarin.Forms已经提供了DependencyService类帮助我们实现反射调用。 在PCL的项目中使用DependencyService类要先定义一个接口，声明要实现的方法签名。 新建Forms项目选中Use Portable Class Library，在PCL项目中添加IDeviceInfo接口：1234public interface IDeviceInfo&#123; string GetDeviceInfo();&#125; 在平台项目中定义一个类实现IDeviceInfo接口，该类所在命名空间和类名无特殊要求，且为该类添加一个Dependency特性，DependencyAttribute类由Xamarin.Forms提供与DependencyService结合使用，该特性应该标注在namespace外。123456789101112131415[assembly: Dependency(typeof(specific.iOS.DeviceInfo))]namespace specific.iOS&#123; public class DeviceInfo : IDeviceInfo &#123; public string GetDeviceInfo() &#123; UIDevice device = new UIDevice(); return String.Format(&quot;&#123;0&#125; &#123;1&#125;&quot;, device.SystemName, device.SystemVersion); &#125; &#125;&#125; Dependency接受的参数是Type类型，表示定义在平台项目中由PCL项目访问的类。如示例代码typeof接收的参数应该是类的完全限定名。 Android项目下DeviceInfo类代码不贴出。接下来在PCL项目中通过DependencyService访问特定平台的IDeviceInfo实现：12IDeviceInfo deviceInfo = DependencyService.Get&lt;IDeviceInfo&gt;();label.Text = deviceInfo.GetDeviceInfo();","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms Device类介绍","slug":"Xamarin-Forms-Device类介绍","date":"2016-11-10T11:37:00.000Z","updated":"2017-11-04T02:36:27.000Z","comments":true,"path":"2016/11/10/Xamarin-Forms-Device类介绍/","link":"","permalink":"http://xamarin.xyz/2016/11/10/Xamarin-Forms-Device类介绍/","excerpt":"Device是一个静态类，提供一些属性和方法帮助开发者判断平台类型、对不同平台提供不同处理。","text":"Device是一个静态类，提供一些属性和方法帮助开发者判断平台类型、对不同平台提供不同处理。 Device是一个静态类，提供一些属性和方法帮助开发者判断平台类型、对不同平台提供不同处理。 Device.IdiomIdiom属性，TargetIdiom枚举类型。可以根据Idiom判断当前设备的类型。 使用方式，移动端开发主要判断Phone和Tablet（平板）： Device.OSOS属性，TargetPlatform枚举类型。判断当前设备系统平台。 如单独设置iOS的Padding，解决页面与状态栏重叠问题： Device.OnPlatform Device提供了两个OnPlatform方法。一个是范型方法，根据不同不同平台，返回对应设置的值，内部通过判断Device.OS属性实现。 XAML使用示例：1234&lt;OnPlatform x:TypeArguments=&quot;Color&quot; iOS=&quot;Green&quot; Android=&quot;#738182&quot; WinPhone=&quot;Accent&quot; /&gt; 还提供了一个接收Action类型参数的OnPlatform方法,会根据不同平台执行不同的动作。 OnPlatform does not currently support differentiating the Windows 8.1, Windows Phone 8.1, and UWP/Windows 10 platforms. Device.Styles提供了定义好的适用于Label样式。包括： BodyStyle CaptionStyle ListItemDetailTextStyle ListItemTextStyle SubtitleStyle TitleStyle 不同平台效果图： XAML使用示例：12&lt;Label Text=&quot;TitleStyle&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot; Style=&quot;&#123;DynamicResource TitleStyle&#125;&quot; /&gt; C#使用示例：12345new Label&#123; Text = &quot;TitleStyle&quot;, Style = Device.Styles.TitleStyle&#125;; Device.GetNamedSize接收一个NamedSize类型参数和一个Type类型参数，根据传入的NamedSize返回当前平台Type类型对应最适合的值。12var label = new Label();label.FontSize = Device.GetNamedSize(NamedSize.Small, typeof(Label)); Device.OpenUri根据传入的Uri调用系统提供的内置功能。 打开网页：1Device.OpenUri(new Uri(&quot;https://www.baidu.com/&quot;)); 拨打电话:1Device.OpenUri(new Uri(&quot;tel:10086&quot;)); 打开地图定位：123456789if (Device.OS == TargetPlatform.iOS) &#123; //https://developer.apple.com/library/ios/featuredarticles/iPhoneURLScheme_Reference/MapLinks/MapLinks.html Device.OpenUri(new Uri(&quot;http://maps.apple.com/?q=394+Pacific+Ave+San+Francisco+CA&quot;));&#125; else if (Device.OS == TargetPlatform.Android) &#123; // opens the Maps app directly Device.OpenUri(new Uri(&quot;geo:0,0?q=394+Pacific+Ave+San+Francisco+CA&quot;));&#125; else if (Device.OS == TargetPlatform.Windows || Device.OS == TargetPlatform.WinPhone) &#123; Device.OpenUri(new Uri(&quot;bingmaps:?where=394 Pacific Ave San Francisco CA&quot;));&#125; Device.StartTimer启动一个简单的定时器，每隔TimeSpan时间会执行Func对应的动作。当Func返回false时，定时器停止。 创建一个周期为1秒的定时器：12345Device.StartTimer(new TimeSpan(0, 0, 1), () =&gt;&#123; label.Text = DateTime.Now.ToString(&quot;F&quot;); return true;&#125;); Device. BeginInvokeOnMainThread用户界面的相关操作是不允许在后台线程中执行。子线程中执行用户界面更新操作需要将代码放在BeginInvokeOnMainThread中执行，BeginInvokeOnMainThread作用类似于iOS中的InvokeOnMainThread, Android中的RunOnUiThread, Windows Phone中的Dispatcher.BeginInvoke。 123Device.BeginInvokeOnMainThread(() =&gt;&#123;&#125;);","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Device","slug":"Device","permalink":"http://xamarin.xyz/tags/Device/"}]},{"title":"Xamarin.Forms Page介绍","slug":"Xamarin-Forms-Page介绍","date":"2016-11-08T15:26:00.000Z","updated":"2017-11-04T02:34:07.000Z","comments":true,"path":"2016/11/08/Xamarin-Forms-Page介绍/","link":"","permalink":"http://xamarin.xyz/2016/11/08/Xamarin-Forms-Page介绍/","excerpt":"Forms中的Page表示App中的一个页面。作用类似Android中的Activity，用来呈现一个用户界面，通常不会直接使用Page类，更多是使用Page的子类，最常用的就是ContentPage.","text":"Forms中的Page表示App中的一个页面。作用类似Android中的Activity，用来呈现一个用户界面，通常不会直接使用Page类，更多是使用Page的子类，最常用的就是ContentPage. Forms中的Page表示App中的一个页面。作用类似Android中的Activity，用来呈现一个用户界面，通常不会直接使用Page类，更多是使用Page的子类，最常用的就是ContentPage. 继承关系图 ContentPage介绍Page的一个子类，只可以显示一个View（only one child），通常会将一个继承了Layout或Layout的子类作为ContentPage的子视图，如：StackLayout。新建项目中默认使用的就是ContentPage（ContentPage作为XAML文件的根结点）。 123&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:local=&quot;clr-namespace:page&quot; x:Class=&quot;page.pagePage&quot;&gt; &lt;Label Text=&quot;Welcome to Xamarin Forms!&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot; /&gt;&lt;/ContentPage&gt; 如何指定App显示的哪个Page？找到App.xaml文件，打开关联的App.xaml.cs文件，看到在App的构造方法中通过MainPage=new pagePage();指定要显示的Page，pagePage是我们布局文件对应的类名。 通过CS代码的方式定义Page并显示屏幕上：123456789MainPage = new ContentPage()&#123; Content = new Label() &#123; Text = &quot;Welcome to Xamarin Forms!&quot;, HorizontalOptions = LayoutOptions.Center, VerticalOptions = LayoutOptions.Center &#125;&#125;; 与默认提供的XAML布局样式相同。 MasterDetailPage 使用介绍MasterDetailPage管理两个页面，Master显示一个数据列表，Detail显示某一项详情。MasterDetailPage定义了两个Page类型属性Master和Detail，通常我们会将这两个属性赋值为ContentPage对象，但是目前为止，要使MasterDetailPage在Universal Windows Platform能正常使用，必须将Detail属性赋值为NavigationPage类型。MasterDetailPage会根据设备有（phone 或 tablet）不同的显示方式,显示方式由MasterBehavior属性决定，手机默认为Popover模式，平板或桌面设备默认为Split模式。 同时提供两个bool类型属性IsGestureEnabled和IsPresented,IsGestureEnabled表示是否支持滑动切换MasterPage的显示状态，而IsPresented表示MasterPage是否为显示状态。当IsPresented值改变时会触发IsPresentedChanged事件。 编写示例项目，新建三个Page页面，分别命名为MasterPage和DetailPage1、DetailPage2。MasterPage的CS文件中增加如下代码：12345678910111213141516171819202122232425262728public partial class MasterPage : ContentPage&#123; public ListView ListView &#123; get &#123; return menuListView; &#125; &#125; public MasterPage() &#123; InitializeComponent(); menuListView.ItemsSource = new List&lt;ListViewItem&gt;() &#123; new ListViewItem()&#123; Title=&quot;Detail 1&quot;, TargetPage=typeof(DetailPage1) &#125;, new ListViewItem()&#123; Title=&quot;Detail 2&quot;, TargetPage=typeof(DetailPage2) &#125; &#125;; &#125;&#125;public class ListViewItem&#123; public string Title &#123; get; set; &#125; public Type TargetPage &#123; get; set; &#125;&#125; 定义了一个Model类ListViewItem。MasterPage中除了设置ListView的ItemSource属性外还定义了一个只读属性ListView，方便在MasterDetailPage中访问。 DetailPage1、DetailPage2分别只包含了一个Label显示文本以区分Page。 修改创建项创建的Page文件。 修改根节点为MasterDetailPage，IsGestureEnabled和MasterBehavior默认值即刻,定义MasterDetailPage.Master和MasterDetailPage.Detail属性节点，根据需要定义Name属性。需要注意Detail属性赋值了一个NavigationPage实例。 CS文件继承的子类修改为MasterDetailPage，构造函数中增加如下代码：1234567891011masterPage.ListView.ItemSelected += (sender, e) =&gt;&#123; if (e.SelectedItem == null) &#123; return; &#125; var item = e.SelectedItem as ListViewItem; Detail = new NavigationPage((Page)Activator.CreateInstance(item.TargetPage)); masterPage.ListView.SelectedItem = null; IsPresented = false;&#125;; Activator.CreateInstance方法用来创建指定类型的实例，更多介绍：http://www.cnblogs.com/lmfeng/archive/2012/01/30/2331666.html 设置SelectedItem = null取消ListView的选中效果，IsPresented = false修改MasterPage的显示状态。 运行效果： 如果DetailPage中仅是数据的变化，可以直接在MasterDetailPage.Master和MasterDetailPage.Detail属性节点中定义Page。123456789101112131415&lt;MasterDetailPage.Master&gt; &lt;ContentPage&gt; &lt;!--页面定义--&gt; &lt;/ContentPage&gt;&lt;/MasterDetailPage.Master&gt;&lt;MasterDetailPage.Detail&gt; &lt;NavigationPage&gt; &lt;x:Arguments&gt; &lt;ContentPage&gt; &lt;!--页面定义--&gt; &lt;/ContentPage&gt; &lt;/x:Arguments&gt; &lt;/NavigationPage&gt;&lt;/MasterDetailPage.Detail&gt; tablet设备修改MasterBehavior属性为Split。会有不同效果：MasterBehavior值为Split时，不允许设置IsPresented的值为false。 TabbedPage 使用介绍TabbedPage继承抽象类MultiPage，管理一个Page类集合，每次只有一个Page显示,在TabbedPage的顶部（Android、WP）或底部（iOS）显示一个页卡标签标示每一个Page页面。MultiPage是一个抽象类，定义了TabbedPage的大多属性和事件。 iOS中使用TabbedPage必须为每个标签提供一个图标，由对应页面的Icon属性设置，否则App Store不会通过审核。 TabbedPage从MultiPage继承一个IList类型属性Children，表示TabbedPage标签页管理Page的集合。MultiPage还提供了ItemSource和ItemTemplate两个属性定义标签页的Page集合。 MultiPage定义了两个属性方便应用程序判断用户当前查看哪个页面：CurrentPage和SelectedItem。CurrentPage获取或设置当前显示的页面，SelectedItem表示ItemsSource当前的选中项。 MultiPage定义两个事件：PagesChanged和CurrentPageChanged。当ItemsSource属性改变时会触发PagesChanged事件，CurrentPage改变时触发CurrentPageChanged事件。 修改主页面XAML文件，根节点改为TabbedPage，同时修改继承子类为TabbedPage。 Children属性使用定义Children Page页面Tab1，Title属性赋值外，iOS平台还要对Icon属性赋值:12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; x:Class=&quot;pages.Tab1&quot; Title=&quot;Tab1&quot;&gt; &lt;ContentPage.Icon&gt; &lt;OnPlatform x:TypeArguments=&quot;FileImageSource&quot; iOS=&quot;ico.png&quot;/&gt; &lt;/ContentPage.Icon&gt; &lt;ContentPage.Padding&gt; &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot; iOS=&quot;0,20,0,0&quot;/&gt; &lt;/ContentPage.Padding&gt; &lt;ContentPage.Content&gt; &lt;Label Text=&quot;Tab1&quot;/&gt; &lt;/ContentPage.Content&gt;&lt;/ContentPage&gt; 类似方式定义Tab2和Tab3。TabbedPage页面XAML文件修改12345678910&lt;TabbedPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:local=&quot;clr-namespace:pages&quot; x:Class=&quot;pages.pagesPage&quot;&gt; &lt;local:Tab1/&gt; &lt;local:Tab2/&gt; &lt;local:Tab3/&gt; &lt;/TabbedPage&gt; 对应C#代码： ItemSource和ItemTemplate使用有ItemTemplate定义所以该方式用于多个TabPage页面想同时使用，结合Data Binding管理页面数据显示。 如下方式修改TabbedPage页面代码： 定义TabPageMode，初始化TabPageMode集合赋值给ItemsSource属性。新建Tab页面，根据Tab初始化DataTemplate实例赋值ItemTemplate属性。 定义Tab页：12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; x:Class=&quot;pages.Tab&quot; Title=&quot;&#123;Binding Title&#125;&quot; Icon=&quot;&#123;Binding Icon&#125;&quot;&gt; &lt;ContentPage.Padding&gt; &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot; iOS=&quot;0,20,0,0&quot;/&gt; &lt;/ContentPage.Padding&gt; &lt;ContentPage.Content&gt; &lt;Label Text=&quot;&#123;Binding Content&#125;&quot;/&gt; &lt;/ContentPage.Content&gt;&lt;/ContentPage&gt; 也可以省略Tab页面定义，TabbedPage的XAML中直接定义TabbedPage.ItemTemplate属性节点：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;TabbedPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:local=&quot;clr-namespace:pages&quot; x:Class=&quot;pages.pagesPage&quot;&gt; &lt;TabbedPage.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;ContentPage Title=&quot;&#123;Binding Title&#125;&quot; Icon=&quot;&#123;Binding Icon&#125;&quot;&gt; &lt;ContentPage.Padding&gt; &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot; iOS=&quot;0,20,0,0&quot;/&gt; &lt;/ContentPage.Padding&gt; &lt;ContentPage.Content&gt; &lt;Label Text=&quot;&#123;Binding Content&#125;&quot;/&gt; &lt;/ContentPage.Content&gt; &lt;/ContentPage&gt; &lt;/DataTemplate&gt; &lt;/TabbedPage.ItemTemplate&gt; &lt;/TabbedPage&gt; 效果图： Icon属性只对iOS有效，Android和Windows Phone只是简单的显示文本标签。 NavigationPage 使用介绍在Navigation中介绍 CarouselPage 介绍CarouselPage支持用户滑动手势的页面，类似gallery。推荐用CarouselView代替CarouselPage。CarouselView实现轮播图效果：https://blog.xamarin.com/flip-through-items-with-xamarin-forms-carouselview/","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Page","slug":"Page","permalink":"http://xamarin.xyz/tags/Page/"}]},{"title":"Xamarin.Forms Navigation介绍","slug":"Xamarin-Forms-Navigation介绍","date":"2016-11-08T15:11:00.000Z","updated":"2017-11-04T02:35:06.510Z","comments":true,"path":"2016/11/08/Xamarin-Forms-Navigation介绍/","link":"","permalink":"http://xamarin.xyz/2016/11/08/Xamarin-Forms-Navigation介绍/","excerpt":"一个常规的App是由多个Page组成的，出现多个Page就会涉及页面跳转问题。Xamarin.Forms页面之间的跳转通过Navigation Stack管理Page，如页面A跳转到页面B时，会将B压入栈定，此时页面B成为活动页面，执行Back操作时，页面B从栈定推出使页面A重新变为活动页面。每个应用程序都有一个特殊页作为应用程序的入口（main page, or the home page, or the start page），Xamarin.Forms中由App的MainPage属性设置。","text":"一个常规的App是由多个Page组成的，出现多个Page就会涉及页面跳转问题。Xamarin.Forms页面之间的跳转通过Navigation Stack管理Page，如页面A跳转到页面B时，会将B压入栈定，此时页面B成为活动页面，执行Back操作时，页面B从栈定推出使页面A重新变为活动页面。每个应用程序都有一个特殊页作为应用程序的入口（main page, or the home page, or the start page），Xamarin.Forms中由App的MainPage属性设置。 一个常规的App是由多个Page组成的，出现多个Page就会涉及页面跳转问题。Xamarin.Forms页面之间的跳转通过Navigation Stack管理Page，如页面A跳转到页面B时，会将B压入栈定，此时页面B成为活动页面，执行Back操作时，页面B从栈定推出使页面A重新变为活动页面。每个应用程序都有一个特殊页作为应用程序的入口（main page, or the home page, or the start page），Xamarin.Forms中由App的MainPage属性设置。 INavigation介绍Xamarin.Forms中页面分为Modal pages(模态页面) 和 modeless pages(非模态页面)，跳转到一个新的页面可以通过PushAsync和PushModalAsync两个方法实现，两个方法均传入一个Page对象作为参数。同样提供了PopAsync和PopModalAsync两个方法返回前一个页面。PushAsync和PopAsync是对非模态页面的操作，PushModalAsync和PopModalAsync操作的是模态页面。PopToRootAsync方法表示回到导航栈低页面。RemovePage方法从导航栈中删除一个页面。InserPageBefore方法将一个page插入到指定page之前。通过这些方法操作Navigation Stack可以在不同Page间跳转。 关于PopXXX和Push方法定义返回Task类型介绍参考（涉及的OnDisappearing和OnAppearing不在本文不再说明）：http://www.cnblogs.com/qiandi/p/5598742.html 当我们调用PushAsync方法时必须修改App的MainPage属性为NavigationPage对象，否则报如下异常，使用NavigationPage时不必在为iOS单独设置Page的Padding属性解决页面和状态栏遮盖问题。 PopXXX和PushXXX提供的bool类型参数重载方法设置为true增加页面跳转动画。 INavigation还定义了两个IReadOnlyList类型属性ModalStack和NavigationStack，NavigationStack表示非模态页面的集合，PushAsync和PopAsync会改变NavigationStack的内容，ModalStack表示模态页面的集合PushModalAsync和PopModalAsync会改变ModalStack的内容，这两个属性不能直接修改，且提供了类似堆栈的功能。这两个集合不能混合跳转，非模态页面可以导航到模态页面但是模态页面不能导航到非模态页面。如果用MainPage = new NavigationPage(new Page0());初始化App的MainPage属性运行应用程序，此时IOS平台中ModalStack为空，Android和Windows平台ModalStack包含一个元素（MainPage对应NavigationPage实例）。三个平台中的NavigationStack集合包均含一个Page0的实例。 这些方法均定义在INavigation中，VisualElement提供了一个INavigation类型只读属性Navigation，可以通过调用Navigation的方法实现跳转。 页面中调用代码Navigation.PushAsync(new ModelessPage(), true); Programmers familiar with Android architecture are sometimes curious how Xamarin.Forms page navigation integrates with the aspect of Android application architecture known as the activity. A Xamarin.Forms application running on an Android device comprises only one activity, and the page navigation is built on top of that. A ContentPage is a Xamarin.Forms object; it is not an Android activity, or a fragment of an activity.前面提到的参考链接有说明，什么意思自己看看吧！！！ NavigationPage介绍NavigationPage的作用就是导航管理页面。 NavigationPage提供的属性 BarBackgroundColor - 获取、设置NavigationPage顶部导航栏的背景色（iOS、Android、Windows 平台有效）。 BarTextColor - 获取、设置NavigationPage顶部导航栏显示文本颜色（iOS、Windows平台有效）。 不同平台效果： CurrentPage - 获取Navigation Stack最顶部页面，不管当前显示页面是模态页面还是非模态页面，CurrentPage都表示NavigationStack集合中的最后一项。 when a modal page is active, CurrentPage continues to indicate the last modeless page that was active before navigation to a modal page NavigationPage提供的BindableProperty HasBackButtonProperty - 是否显示非模态页面导航栏的返回按钮（iOS、Android起作用）C#设置NavigationPage.SetHasBackButton(this, false);XAML设置NavigationPage.HasBackButton=&quot;False&quot; HasNavigationBarProperty - 是否显示导航栏 BackButtonTitleProperty - 设置返回按钮的文本（仅iOS平台） TitleIconProperty - 设置导航栏上显示图标（iOS平台Icon代替Title，Android修改左侧图标显示，Windows 无效） 屏蔽Android、Windows Mobile 返回按键Android和Windows Phone会包含一个返回键，返回键提供类似PopAsync或PopModalAsync的工能，程序中要屏蔽返回键的功能需要重写Page的OnBackButtonPressed方法。OnBackButtonPressed方法返回true值，程序不处理返回按键。12345protected override bool OnBackButtonPressed()&#123; //return base.OnBackButtonPressed(); return true;&#125; Page还定义了SendBackButtonPressed方法，用来模拟返回按钮被按下。调用该方法与Android按下返回键功能类似。 官方电子书中提到“Although this works on iOS and Android, it currently does not work on the Windows Runtime platforms.”这个方法只对iOS和Android有效，Windows Runtime platforms不能正常工作。 实际测试iOS无效，Android正常，Windows 无法测试。 页面间传值一个应用程序会包含多个页面，把数据从一个页面传到另一个页面该怎么做？ 构造函数传值页面跳转的PushXXX方法传入Page页面实例作为参数，可以通过Page页面的构造函数传入数据，如Navigation.PushModalAsync(new DataPage(label.Text));，在DataPage重载的构造函数中在处理接收的数据。 属性方法传值根据页面的属性或调用方法传值。如： 构造函数传值是单向的不能传递返回数据，通过属性传值可以从当前页面向前一个页面传值。应从NavigationStack集合中取得前一个页面实例。1234567891011var stack = (App.Current.MainPage as NavigationPage).Navigation.NavigationStack;int lastIndex = stack.Count - 1;navigationPage homePage = stack[lastIndex] as navigationPage;if (homePage == null)&#123; homePage = stack[lastIndex - 1] as navigationPage;&#125;homePage.SetText(Value + &quot;页面返回数据了&quot;); 从模态页面跳转到非模态页面和模态页面跳转到模态页面两种情况，跳转前的页面在NavigationStack中有不同的位置。如果是非模态页面跳转到非模态页面？又要从ModalStack中获取前一个页面实例，所以通过属性和方法传值不推荐！！！ Messaging Center传值MessagingCenter是一个静态类，提供了Subscribe、Unsubscribe和Send三个公开的方法。Subscribe订阅接收的消息信息，参数、发送者类型等。Unsubscribe取消订阅，不在接收消息。Send发送指定类型消息。 Messaging Center传值示例： 数据接收页面增加消息订阅代码：1234MessagingCenter.Subscribe&lt;navigationPage, string&gt;(this, &quot;Value&quot;, (arg1, arg2) =&gt; &#123; label.Text = arg2; &#125;); Subscribe包含两个范型参数，第一个为消息发送者类型，第二个为传递数据类型。Subscribe包含三个参数，第一个为消息接收者，第二个参数为字符串类型消息标示，第三个参数是一个lambda表达式，表示接收到消息后的动作。 数据传递页面增加发送消息代码：1MessagingCenter.Send&lt;navigationPage, string&gt;(this, &quot;Value&quot;, label.Text); Send两个范型参数与Subscribe方法相同。Send包含三个参数，第一个参数为消息发送者，第二个参数为消息标示，第三个参数为传递的数据对象。本示例Send方法应在PushAsync后执行。PushAsync执行前消息没有订阅，Send发送消息此时没有接收者。 不再接收消息时应该调用Unsubscribe取消指定消息的订阅,对资源回收释放。本示例取消订阅代码添加在Subscribe方法的lambda中。1MessagingCenter.Unsubscribe&lt;navigationPage, string&gt;(this, &quot;Value&quot;); Strictly speaking, however, unsubscribing shouldn’t be necessary because the MessagingCenter maintains WeakReference objects for subscribers。MessagingCenter定义了一个Dictionary&lt;Tuple&lt;string, Type, Type&gt;, List&lt;Tuple&lt;WeakReference, Action&lt;object, object&gt;&gt;&gt;&gt;类型对象通过WeakReference管理subscribers，所以Unsubscribe方法不是必须的。 事件传值WinForm中常用的传值形式，事件传值。推荐数据回传时使用。 Page1 跳转到Page2时，Page2添加事件定义：1public EventHandler&lt;string&gt; Value; Page2 返回Page1 时，触发事件：12345EventHandler&lt;string&gt; handler = Value;if (handler != null)&#123; handler(this, &quot;增加返回字符串&quot;);&#125; Page1 跳转到Page2时，订阅Page2的事件：123456var page = new Page2();page.Value += (sender, e) =&gt;&#123; label.Text = e;&#125;;Navigation.PushAsync(page); 传递复杂数据继承EventArgs实现传值 App Class传值Xamarin.Forms应用程序会提供一个App类（继承Application）作为程序的入口，该对象在应用程序运行期间一直存在，可以借助App类实现不同页面之间数据传递。 修改App代码定义属性保存、获取数据。如： 获取App类实例可以通过(App)Application.Current)获取。或着直接定义static 属性，直接通过App.Value 传值。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Navigation","slug":"Navigation","permalink":"http://xamarin.xyz/tags/Navigation/"}]},{"title":"Xamarin.Forms Views介绍（七）——TableView","slug":"Xamarin-Forms-Views介绍（七）——TableView","date":"2016-10-21T16:18:00.000Z","updated":"2017-11-03T01:07:41.000Z","comments":true,"path":"2016/10/22/Xamarin-Forms-Views介绍（七）——TableView/","link":"","permalink":"http://xamarin.xyz/2016/10/22/Xamarin-Forms-Views介绍（七）——TableView/","excerpt":"与ListView不同，ListView提供ItemTemplate显示同类型数据集合，TableView通过不同Cell显示不同数据类型集合，TableView没有ItemSource的概念需要手动设置Child。如借助TableView实现Setting界面。","text":"与ListView不同，ListView提供ItemTemplate显示同类型数据集合，TableView通过不同Cell显示不同数据类型集合，TableView没有ItemSource的概念需要手动设置Child。如借助TableView实现Setting界面。 与ListView不同，ListView提供ItemTemplate显示同类型数据集合，TableView通过不同Cell显示不同数据类型集合，TableView没有ItemSource的概念需要手动设置Child。如借助TableView实现Setting界面： TableView属性 HasUnevenRows ：bool类型的值，表示TableView是否有不均匀行。 Intent ：TableIntent类型，获取、设置列表底部的字符串或视图。 RowHeight ：int类型，设置TableView行高，如果HasUnevenRows为true忽略该属性。 Root ：TableRoot类型，获取设置TableView显示Items结构的根节点。每个TableView包含一个TableRoot，TableRoot内有一个Title（只对Windows Phone有效）和多个TableSection，每个TableSection又包含一个Title和多个Cell。 TableRoot 继承TableSectionBase，TableSection继承 TableSectionBase，都继承自TableSectionBase，TableSectionBase又实现了INotifyCollectionChanged接口，况且使用ObservableCollection管理内部集合元素，所以我们可以通过代码动态增加和删除TableView中的字元素。 TableView 定义123456789&lt;TableView Intent=&quot;Settings&quot;&gt; &lt;TableRoot&gt; &lt;TableSection Title=&quot;Section Title&quot;&gt; &lt;EntryCell Text=&quot;EntryCell&quot; Label=&quot;EntryCell Label&quot;/&gt; &lt;SwitchCell Text=&quot;SwitchCell&quot; On=&quot;true&quot; /&gt; &lt;TextCell Text=&quot;Cell Text&quot; Detail=&quot;Cell Detail&quot;/&gt; &lt;/TableSection&gt; &lt;/TableRoot&gt;&lt;/TableView&gt; TableView默认填充整个屏幕，效果图： TableView提供TableIntent类型属性Intent可以定义TableView的外观。 Data – TableView显示数据列表时使用。 Form – TableView每行提供对应动作时使用。 Menu – TableView显示成菜单样式. Settings – TableView显示设置列表样式。 除了Data对应样式的Title显示外没发现有什么不同，，， Cell介绍Forms提供了四个Cell方便我们的开发，这四个Cell分别是TextCell、ImageCell、SwitchCell、EntryCell，前两个通常用于ListView，介绍ListView时有Cell的相关介绍。SwitchCell和EntryCell多用于TableView的定义。 SwitchCellSwitchCell用来设置和显示一个bool值。 Text–左侧显示文本，对这个bool值进行描述。 On–表示Switch的状态对应这个bool值。 EntryCellEntryCell提供了一个Entry让用户进行输入。 Keyboard – Entry获取焦点时显示软键盘的样式。 Label – 左侧显示的说明文本。 LabelColor – 左侧显示文本颜色。 Placeholder – Entry内容为空时显示的内容。 Text – Entry输入的内容。 HorizontalTextAlignment – Text水平对其方式。 自定Cell当Forms提供的Cell不能满足需求时可以通过继承ViewCell自定义Cell实现。 自定义PickerCell示例：新建文件可以选择Forms ContentView或Forms ContentView Xaml Forms ContentView用来通过代码定义Cell，Forms ContentView Xaml用XAML定义Cell。本示例新建一个Forms ContentView Xaml文件，命名PickerCell。修改XAML文件的根节点为ViewCell，并做如下修改：1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;ViewCell xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; x:Class=&quot;views.PickerCell&quot; x:Name=&quot;cell&quot;&gt; &lt;ViewCell.View&gt; &lt;StackLayout Orientation=&quot;Horizontal&quot; BindingContext=&quot;&#123;x:Reference cell&#125;&quot; Padding=&quot;16, 0&quot;&gt; &lt;Label Text=&quot;&#123;Binding Label&#125;&quot; VerticalOptions=&quot;Center&quot; /&gt; &lt;Picker x:Name=&quot;picker&quot; Title=&quot;&#123;Binding Title&#125;&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;FillAndExpand&quot; SelectedIndexChanged=&quot;OnPickerSelectedIndexChanged&quot; /&gt; &lt;/StackLayout&gt; &lt;/ViewCell.View&gt;&lt;/ViewCell&gt; 给Cell添加Name属性，并设置StackLayout的BindingContext为Cell本身，用来绑定Label和Picker。 CS文件实现：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364[ContentProperty(&quot;Items&quot;)]public partial class PickerCell : ViewCell&#123; public static readonly BindableProperty LabelProperty = BindableProperty.Create(&quot;Label&quot;, typeof(string), typeof(PickerCell), default(string)); public static readonly BindableProperty TitleProperty = BindableProperty.Create(&quot;Title&quot;, typeof(string), typeof(PickerCell), default(string)); public static readonly BindableProperty SelectedValueProperty = BindableProperty.Create(&quot;SelectedValue&quot;, typeof(string), typeof(PickerCell), null, BindingMode.TwoWay, propertyChanged: (sender, oldValue, newValue) =&gt; &#123; PickerCell pickerCell = (PickerCell)sender; if (String.IsNullOrEmpty((string)newValue)) &#123; pickerCell.picker.SelectedIndex = -1; &#125; else &#123; pickerCell.picker.SelectedIndex = pickerCell.Items.IndexOf((string)newValue); &#125; &#125;); public PickerCell() &#123; InitializeComponent(); &#125; public string Label &#123; get &#123; return (string)GetValue(LabelProperty); &#125; set &#123; SetValue(LabelProperty, value); &#125; &#125; public string Title &#123; get &#123; return (string)GetValue(TitleProperty); &#125; set &#123; SetValue(TitleProperty, value); &#125; &#125; public string SelectedValue &#123; get &#123; return (string)GetValue(SelectedValueProperty); &#125; set &#123; SetValue(SelectedValueProperty, value); &#125; &#125; public IList&lt;string&gt; Items &#123; get &#123; return picker.Items; &#125; &#125; void OnPickerSelectedIndexChanged(object sender, EventArgs args) &#123; if (picker.SelectedIndex == -1) &#123; SelectedValue = null; &#125; else &#123; SelectedValue = Items[picker.SelectedIndex]; &#125; &#125;&#125; [ContentProperty(&quot;Items&quot;)]这段代码使我们XAML中定义Cell是直接指定Items的值不需要设置属性节点。对属性值的操作尽量通过BindableObject提供的SetValue方法完成，属性有更新时可以更新到XAML界面。 定义TableView时使用自定义的PickerCell： 运行效果： 为了方便，可以直接在XAML中定义TableView时自定义Cell： 响应TableView的点击事件TextCell and ImageCell提供了Command和CommandParameter属性，结合Data Binding中ICommand相关知识，定义ICommand对象，绑定到Cell的Command属性以响应Cell的点击操作。太困，不详细记录。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"TableView","slug":"TableView","permalink":"http://xamarin.xyz/tags/TableView/"}]},{"title":"Xamarin.Forms Views介绍（六）——ListView","slug":"Xamarin-Forms-Views介绍（六）——ListView","date":"2016-10-19T13:56:00.000Z","updated":"2017-11-03T01:18:08.000Z","comments":true,"path":"2016/10/19/Xamarin-Forms-Views介绍（六）——ListView/","link":"","permalink":"http://xamarin.xyz/2016/10/19/Xamarin-Forms-Views介绍（六）——ListView/","excerpt":"ListView用来显示列表数据，适合单一类型数据集合。","text":"ListView用来显示列表数据，适合单一类型数据集合。 ListView用来显示列表数据，适合单一类型数据集合。 ListView属性 Footer ：object类型，获取、设置列表底部的字符串或视图。 FooterTemplate ：DataTemplate类型，获取、设置列表底部数据模版。 Header ：object类型，获取、设置列表顶部的字符串或视图。 HeaderTemplate ：DataTemplate类型，获取、设置列表定部数据模版。 HasUnevenRows ：bool类型，表示列表是否有不均匀的行高，默认值false，设置为true后ListView每行的高度会因为内容不同而提供不同高度。 可以在运行时通过Cell.ForceUpdateSize /)方法更新cell大小。 IsGroupingEnabled ：bool类型，表示是否对列表进行分组。 GroupDisplayBinding:绑定分组头的值。 GroupHeaderTemplate:DataTemplate类型，分组头的数据模版。 GroupShortNameBinding:绑定分组跳转列表中的值。 IsPullToRefreshEnabled ：bool类型，表示列表是否可以进行下拉刷新。 IsRefreshing ：bool类型，表示列表是否正在刷新。 RowHeight ：表示列表行高。 SelectedItem ：object类型，表示列表当前选中对象。 SeparatorColor ：表示列表分割栏的颜色。 SeparatorVisibility ：SeparatorVisibility枚举，表示分割栏的显示方式。 ListView事件 ItemAppearing ：ListView元素显示时触发，ListView滑动使Item显示在屏幕内。 ItemDisappearing ：ListView元素消失时触发，ListView滑动使Item消失在屏幕内。 ItemSelected ：新的Item元素被选中时触发。 ItemTapped ：ListView的元素Item被点击是触发。 Refreshing ：ListView刷新事件。 #ListView基本使用填充ListView显示的数据有两种方式：设置ListView的ItemsSource和Data Binding。Data Binding后面介绍。ItemsSource类型是IEnumerable。XAML定义ListView会默认填充整个屏幕1&lt;ListView x:Name=&quot;listView&quot;/&gt; 通过C#代码设置ItemsSource：123listView.ItemsSource = new List&lt;string&gt;() &#123; &quot;List Item 1&quot;,&quot;List Item 2&quot;,&quot;List Item 3&quot;,&quot;List Item 4&quot;,&quot;List Item 5&quot;&#125;; IOS会有多余分割线显示可以通过代码隐藏分割线listView.SeparatorVisibility = SeparatorVisibility.None; 默认情况下ItemSource集合提供的数据调用ToString方法显示在TextCell上，即ListView每行是一个TextCell。 定义XAML时设置ItemsSource:123456789101112&lt;ListView&gt; &lt;ListView.ItemsSource&gt; &lt;x:Array Type=&quot;&#123;x:Type x:String&#125;&quot;&gt; &lt;x:String&gt;Item 1&lt;/x:String&gt; &lt;x:String&gt;Item 2&lt;/x:String&gt; &lt;x:String&gt;Item 3&lt;/x:String&gt; &lt;x:String&gt;Item 4&lt;/x:String&gt; &lt;x:String&gt;Item 5&lt;/x:String&gt; &lt;x:String&gt;Item 6&lt;/x:String&gt; &lt;/x:Array&gt; &lt;/ListView.ItemsSource&gt;&lt;/ListView&gt; ListView 结合 Data Binding使用ListView的数据源（ItemsSource）不仅可以是简单的字符串集合也可以是自定义的Model类集合，要显示类集合数据时需要结合Data Binding实现，演示一个TextCell显示Text和Detail的示例。 Data Source设置代码，ListViewItem是一个简单的Model类不再展示： 在定义ItemSource的数据集合时推荐用ObservableCollection代替List,ObservableCollection实现了INotifyPropertyChanged接口能够通知数据的变化，提供更新功能。 在XAML代码中定义ListVIew时应显示指出TextCell的展现形式。设置ListView.ItemTemplate,DataTemplate元素节点内定义一个TextCell，绑定 TextCell的Text和Detail属性为对应Model的属性。1234567&lt;ListView x:Name=&quot;listView&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextCell Text=&quot;&#123;Binding Title&#125;&quot; Detail=&quot;&#123;Binding Detail&#125;&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt;&lt;/ListView&gt; ListView Selected事件当用户点击ListView的Item时触发ListView的ItemTapped事件，SelectedItem值发生改变还会触发ItemSelected事件，用户连续点击同一个Item时ItemTapped触发多次，SelectedItem只会在第一次点击时触发。如果想使ListView禁用ListView被取消ListView的选中效果123listView.ItemSelected += (sender, e) =&gt; &#123; listView.SelectedItem = null;&#125;; ListView Cell介绍前面有提到过TextCell，是Xamarin.Forms 提供的Cell子类可以帮助我们显示更复杂的ListView。 Xamarin.Forms提供给ListVIew常用的Cell有两种：TextCell和ImageCell。SwitchCell和EntryCell通常用在TableView中。 TextCell用来显示文本，并允许在第二行显示详细文本：Text – 显示在第一行的文本，以较大字体显示.Detail – 以较小字体显示在第二行的文本.TextColor – Text文本颜色.DetailColor – Detail文本颜色. ImageCell与TextCell相比在Cell的左侧可以显示图片信息。ImageCell显示图片在Windows Phone 8.1 下默认不会缩放，所以会有如下效果： 至于Windows Phone显示效果没有亲自测试，默认不会缩放在官网中有提到，不开发Windows Phone可以不考虑。 具体使用参考ListView 结合 Data Binding使用。更复杂的列表效果需自定义单元格，继承ViewCell实现期望的效果。自定义单元格更多信息参考：https://developer.xamarin.com/guides/xamarin-forms/user-interface/listview/customizing-cell-appearance/#Custom_Cells ListView的Header和Footer可以在ListView的头部和尾部添加显示简单的文本或更加复杂的视图布局。ListView的Header和Footer会随ListView一起滚动。如设置ListView的Header为一个简单的字符串Footer为一个按钮：12345678&lt;ListView x:Name=&quot;listView&quot;&gt; &lt;ListView.Header&gt; ListView Header &lt;/ListView.Header&gt; &lt;ListView.Footer&gt; &lt;Button Text=&quot;Load More&quot;/&gt; &lt;/ListView.Footer&gt;&lt;/ListView&gt; HeaderTemplate和FooterTemplate不是必须的，涉及到数据绑定时才会用到。 如图效果： 加载更多效果可以通过Footer设置为一个Button点击加载跟多数据。 #ListView分组当ListView展示大量数据时可以尝试通过分组管理、展示数据，如iOS的通讯录。对ListView分组前，必须先将数据进行分组，ListView分组的数据源应该是集合的集合（collection of collections，后面给出示例）。准备好数据源同时将ListView 的IsGroupingEnabled属性设置为true，表示ListView开启分组功能。ListView提供了GroupDisplayBinding属性，用来绑定每个分组的Title，GroupShortNameBinding绑定一个索引字段。所以定义的GroupModel应该包含一个Title属性绑定到GroupDisplayBinding属性（必须的），定义一个ShortName绑定到GroupShortNameBinding（可选值），iOS会在右侧提供一个索引列表。 本文示例，ListView的item展现的是简单的字符串，所以GroupModel定义继承IEnumerable,并定义Title和ShortName属性用来绑定ListView的GroupDisplayBinding和GroupShortNameBinding属性。定义一个IEnumerable属性表示没个分组的数据，本例中ListView展示字符串数据，所以定义为IEnumerable。定义如下Model类： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class ListViewGroup : ObservableCollection&lt;string&gt;&#123; public string GroupTitle &#123; get; set; &#125; public string ShortName &#123; get; set; &#125; public static ObservableCollection&lt;ListViewGroup&gt; Items &#123; get; set; &#125; static ListViewGroup() &#123; Items = new ObservableCollection&lt;ListViewGroup&gt;(); //创建虚拟数据 var aGroup = new ListViewGroup &#123; GroupTitle = &quot;A Title&quot;, ShortName = &quot;A&quot; &#125;; aGroup.Add(&quot;Abs&quot;); aGroup.Add(&quot;Apple&quot;); aGroup.Add(&quot;Are&quot;); aGroup.Add(&quot;Add&quot;); Items.Add(aGroup); var bGroup = new ListViewGroup &#123; GroupTitle = &quot;B Title&quot;, ShortName = &quot;B&quot; &#125;; bGroup.Add(&quot;Bbs&quot;); bGroup.Add(&quot;Blue&quot;); bGroup.Add(&quot;Bar&quot;); bGroup.Add(&quot;Bana&quot;); Items.Add(bGroup); var cGroup = new ListViewGroup &#123; GroupTitle = &quot;C Title&quot;, ShortName = &quot;C&quot; &#125;; cGroup.Add(&quot;Cbs&quot;); cGroup.Add(&quot;Couple&quot;); cGroup.Add(&quot;Cut&quot;); cGroup.Add(&quot;Custum&quot;); Items.Add(cGroup); var dGroup = new ListViewGroup &#123; GroupTitle = &quot;D Title&quot;, ShortName = &quot;D&quot; &#125;; dGroup.Add(&quot;Dbs&quot;); dGroup.Add(&quot;Double&quot;); dGroup.Add(&quot;Delete&quot;); dGroup.Add(&quot;Developer&quot;); Items.Add(dGroup); &#125;&#125; XAML中绑定数据，通过x:Static指定数据源为ListViewGroup的静态属性Items，设置IsGroupingEnabled为true，绑定GroupTitle的值到GroupDisplayBinding，同时绑定GroupShortNameBinding的值（不是必须的），ListView.RowHeight属性节点定义不同平台Item显示不同高度。结合Custum Cell知识，定义ItemTemplate的值：1234567891011121314151617181920212223242526272829303132&lt;ListView ItemsSource=&quot;&#123;x:Static local:ListViewGroup.Items&#125;&quot; IsGroupingEnabled=&quot;true&quot; GroupDisplayBinding=&quot;&#123;Binding GroupTitle&#125;&quot; GroupShortNameBinding=&quot;&#123;Binding ShortName&#125;&quot;&gt; &lt;ListView.RowHeight&gt; &lt;OnPlatform x:TypeArguments=&quot;x:Int32&quot; iOS=&quot;80&quot; Android=&quot;80&quot; WinPhone=&quot;90&quot; /&gt; &lt;/ListView.RowHeight&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;ViewCell&gt; &lt;ContentView Padding=&quot;5&quot;&gt; &lt;Frame OutlineColor=&quot;Accent&quot; Padding=&quot;10&quot;&gt; &lt;StackLayout Orientation=&quot;Horizontal&quot;&gt; &lt;BoxView Color=&quot;#00ffdd&quot; WidthRequest=&quot;50&quot; HeightRequest=&quot;50&quot; /&gt; &lt;Label Text=&quot;&#123;Binding .&#125;&quot; FontSize=&quot;22&quot; VerticalOptions=&quot;StartAndExpand&quot; /&gt; &lt;/StackLayout&gt; &lt;/Frame&gt; &lt;/ContentView&gt; &lt;/ViewCell&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt; &lt;/ListView&gt; Android、iOS效果图（GroupShortNameBinding属性对Android平台无效）： 与定义ItemTemplate类似，ListView提供了GroupHeaderTemplate属性方便我们自定义ListView的Group Header样式。示例代码：12345678&lt;ListView.GroupHeaderTemplate&gt; &lt;DataTemplate&gt; &lt;TextCell Text=&quot;&#123;Binding Title&#125;&quot; Detail=&quot;&#123;Binding ShortName&#125;&quot; TextColor=&quot;#f35e20&quot; DetailColor=&quot;#503026&quot; /&gt; &lt;/DataTemplate&gt;&lt;/ListView.GroupHeaderTemplate&gt; ListView 刷新设置ListView的IsPullToRefreshEnabled属性为true，使ListView支持下拉刷新。下拉ListView有如下效果： 用户下拉ListView会触发Refreshing事件，在处理Refreshing事件重新加载数据后应通过设置IsRefreshing为false或调用ListView的EndRefresh方法通知ListView数据加载完成以取消下拉加载的效果。 也可以通过调用ListView 的BeginRefresh方法触发Refreshing事件。 ListView Context Actions有时我们需要为ListView的每一项提供菜单行为，如Item的删除。IOS为左滑动Item，Android和Windows Phone为长按Item。 Context Actions依靠MenuItem实现，可以通过C#或XAML代码定义。MenuItem提供了Clicked事件响应MenuItem的点击，MenuItem继承BaseMenuItem，有三个常用属性属性： Text – string类型，表示MenuItem显示文本. Icon – FileImageSource类型,表示MenuItem图标. IsDestructive – bool类型,值为true时iOS平台MenuItem以红色背景渲染. C# 定义Context Action 定义MenuItem添加到Cell的ContextActions属性中即可。这里不再给出C#代码设置ListView的ItemTemplate示例，所以图片代码为代码片段。可参考：http://stackoverflow.com/questions/38585153/implementing-xamarin-forms-context-actions 默认情况下响应MenuItem的点击事件并不能判断当前MenuItem属于哪个Cell，可以通过MenuItem的CommandParameter属性绑定一个值确定操作的Cell。参考MenuItem响应事件。 XAML 定义Context Action:123456789101112&lt;ListView x:Name=&quot;listView&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextCell Text=&quot;&#123;Binding Title&#125;&quot; Detail=&quot;&#123;Binding Detail&#125;&quot;&gt; &lt;TextCell.ContextActions&gt; &lt;MenuItem Clicked=&quot;OnShare&quot; CommandParameter=&quot;&#123;Binding .&#125;&quot; Text=&quot;分享&quot; /&gt; &lt;MenuItem Clicked=&quot;OnDelete&quot; CommandParameter=&quot;&#123;Binding .&#125;&quot; Text=&quot;删除&quot; IsDestructive=&quot;True&quot; /&gt; &lt;/TextCell.ContextActions&gt; &lt;/TextCell&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt;&lt;/ListView&gt; ListView 性能优化应用程序中使用ListView一定要确保ListView的性能（快速加载和平滑滚动）。Xamarin.Forms提供了Caching Strategy（缓存策略）优化ListView使用性能,对应ListView的CachingStrategy属性。也可以通过ListView使用过程中的一些技巧提升ListView的性能。 Caching StrategyListView用来展示大量数据，默认情况下ListView会为每条记录创建一个Cell，耗费大量内存，通过Caching Strategy减少内存使用，提高ListView性能。ListViewCachingStrategy枚举包含两个值RetainElement和RecycleElement。 RetainElement：为列表中的没一项生成一个Cell，是ListView的默认行为。如下情况应使用该值： 每个单元格（Cell）拥有大量的数据绑定(20-30+). 单元格模版（Cell Template）变化频繁。 设置为RecycleElement值时ListView性能降低，应使用该值。（When testing reveals that the RecycleElement value results in a reduced execution speed. ） RecycleElement：设置为该值时ListView尝试通过重复利用Cell减少内存使用和提高执行速度。RecycleElement不一定会提高ListView的使用性能，但如下情况应使用该值： 单元格有很少的数据绑定 没个单元格的数据源由Cell的BindingContext属性提供 没个单元格拥有相同的单元格模版 XAML中通过代码CachingStrategy=&quot;RecycleElement&quot;指定CachingStrategy的模式。C#代码中ListView没有提供CachingStrategy属性，设置CachingStrategy的值要在ListView 的构造函数中传入设置的值。 ListView设置CachingStrategy=”RecycleElement”，简单的显示string集合出现元素显示重复问题。 显式设置ListView.ItemTemplate后运行正常。1234567&lt;ListView x:Name=&quot;listView&quot; CachingStrategy=&quot;RecycleElement&quot;&gt; &lt;ListView.ItemTemplate&gt; &lt;DataTemplate&gt; &lt;TextCell Text=&quot;&#123;Binding .&#125;&quot;/&gt; &lt;/DataTemplate&gt; &lt;/ListView.ItemTemplate&gt;&lt;/ListView&gt; 自定义Cell时应该重写OnBindingContextChanged方法，以保证设置ListView的属性CachingStrategy=”RecycleElement”时显示正常。 Improving ListView PerformanceListView使用过程中很多技巧可以帮助我们提高ListView的性能： 对于绑定的数据源用IList 集合代替 IEnumerable集合。 尽量使用Forms提供的Cell（TextCell / SwitchCell），避免自定义Cell。 自定Cell时减少布局嵌套和使用视图，布局尽量使用AbsoluteLayout 和 Grid，对于LayoutOptions属性尽量设置为Fill。 显示不规律数据时用TableView代替ListView。 减少Cell.ForceUpdateSize方法的调用。 避免将ListView放置在ScrollView中使用。 过于复杂的Cell，尽量使用Custom Renderer（以后介绍）。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"ListView","slug":"ListView","permalink":"http://xamarin.xyz/tags/ListView/"}]},{"title":"Xamarin.Forms MVVM介绍","slug":"Xamarin-Forms-MVVM介绍","date":"2016-10-13T13:14:00.000Z","updated":"2017-11-04T02:35:43.770Z","comments":true,"path":"2016/10/13/Xamarin-Forms-MVVM介绍/","link":"","permalink":"http://xamarin.xyz/2016/10/13/Xamarin-Forms-MVVM介绍/","excerpt":"MVVM是Model-View-ViewModel的简写，是由微软在WPF中提供的新技术，MVVM 架构使用的是数据绑定基础架构。更多介绍：http://baike.baidu.com/view/3507915.htm MVVM架构分为三层：• Model负责访问数据，为ViewModel提供数据。• ViewModel连接Model层和View层. ViewModel帮助管理Model提供的数据.• View层表现数据，通常为XAML定义的用户界面.","text":"MVVM是Model-View-ViewModel的简写，是由微软在WPF中提供的新技术，MVVM 架构使用的是数据绑定基础架构。更多介绍：http://baike.baidu.com/view/3507915.htm MVVM架构分为三层：• Model负责访问数据，为ViewModel提供数据。• ViewModel连接Model层和View层. ViewModel帮助管理Model提供的数据.• View层表现数据，通常为XAML定义的用户界面. MVVM是Model-View-ViewModel的简写，是由微软在WPF中提供的新技术，MVVM 架构使用的是数据绑定基础架构。更多介绍：http://baike.baidu.com/view/3507915.htm MVVM架构分为三层：• Model负责访问数据，为ViewModel提供数据。• ViewModel连接Model层和View层. ViewModel帮助管理Model提供的数据.• View层表现数据，通常为XAML定义的用户界面. 三层之间的调用关系： View层不允许直接调用Model层获取数据，View层获取数据需要通过调用ViewModel提供的方法或属性简介获取Model层提供的数据。 同时为了实现双向通信，ViewModel和View会提供事件处理逐层向下反馈用户处理。 再简单的MVVM示例中Model层是被省略的，ViewModel负责全部业务逻辑。ViewModel和View之间通过Data Binding通信，其中View作为Target，ViewModel作为Source。 ViewModels 和 Data Binding再Data Binding介绍中提到，Source必须是实现了INotifyPropertyChanged（INPC）接口的对象。 INotifyPropertyChanged接口包含一个PropertyChanged事件委托类型为PropertyChangedEventHandler。PropertyChangedEventHandler委托第二个参数类型为PropertyChangedEventArgs，PropertyChangedEventArgs包含一个string 类型的PropertyName属性,根据这个属性可以判断ViewModel的哪个属性发生改变。 对Xamarin.Forms平台而言，ViewModel通常继承BindableObject即可，ViewModel公共属性定义为BindableProperty类型。BindableObject已经实现了INotifyPropertyChanged接口，定义为BindableProperty类型的属性改变时会自动触发PropertyChanged事件。 简单INotifyPropertyChanged接口使用示例：一个Label标签显示当前时间，每过一秒Label时间更新一次。INotifyPropertyChanged ➕ Data Binding实现。自定义ViewModel实现INotifyPropertyChanged接口。1234567891011121314151617181920212223242526272829303132333435363738394041public class DateTimeViewModel : INotifyPropertyChanged&#123; DateTime dateTime = DateTime.Now; public event PropertyChangedEventHandler PropertyChanged; public DateTimeViewModel() &#123; Device.StartTimer(TimeSpan.FromSeconds(1), () =&gt; &#123; DateTime = DateTime.Now; return true; &#125;); &#125; public DateTime DateTime &#123; private set &#123; if (dateTime != value) &#123; dateTime = value; OnPropertyChanged(&quot;DateTime&quot;); &#125; &#125; get &#123; return dateTime; &#125; &#125; protected void OnPropertyChanged(string propertyName) &#123; if (PropertyChanged != null) &#123; PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125; &#125;&#125; ViewModel除实现了INotifyPropertyChanged接口外还定义了DateTime类型的DateTime属性。在DateTime属性的set操作中检查属性对应的字段与value是否相等，如不想等对dateTime赋值的同时检查PropertyChanged的值是否为null，不为null调用PropertyChanged。 OnPropertyChanged方法传入的string类型参数表示当前改变属性的字符串名，一个ViewModel内定义多个属性应确保调用OnPropertyChanged方法时传入一个正确的字符串，错误的字符串导致会使绑定失败。.Net 4.5之后的版本提供了一个特性类CallerMemberName,表调用者名且对应参数应设为可选参数具有默认值。修改后的OnPropertyChanged方法：1234567protected void OnPropertyChanged([CallerMemberName] string propertyName = &quot;&quot;)&#123; if (PropertyChanged != null) &#123; PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125;&#125; 属性的set操作中调用OnPropertyChanged方法的代码修改为OnPropertyChanged();。由于定义了CallerMemberNameAttribute可以省略参数传递。事实上CallerMemberNameAttribute类就是为了INotifyPropertyChanged接口使用定义的。 进一步修改代码，定义ViewModel时定义一个SetProperty通用方法，第一个参数标记为ref，表示Property对应的字段，第二个参数为set提供的value。123456789101112bool SetProperty&lt;T&gt;(ref T storage, T value, [CallerMemberName] string propertyName = &quot;&quot;)&#123; if (Object.Equals(storage, value)) return false; storage = value; if (PropertyChanged != null) &#123; PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125; return true;&#125; 如果属性的set操作中只提供简单的赋值，调用定义的SetProperty方法即可。本例中DateTime属性的示例：123456789101112public DateTime DateTime&#123; private set &#123; SetProperty&lt;DateTime&gt;(ref dateTime,value); &#125; get &#123; return dateTime; &#125;&#125; 《Creating Mobile Apps with Xamarin.Forms》中代码示例，可以定义一个ViewModel基类，定义ViewModel时即成ViewModelBase类即可，不再考虑INotifyPropertyChanged接口。 XAML界面定义：12345678&lt;ContentPage.Resources&gt; &lt;ResourceDictionary&gt; &lt;local:DateTimeViewModel x:Key=&quot;dateTimeViewModel&quot; /&gt; &lt;/ResourceDictionary&gt;&lt;/ContentPage.Resources&gt; &lt;Label Text=&quot;&#123;Binding Source=&#123;StaticResource dateTimeViewModel&#125; ,Path=DateTime &#125;&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot; /&gt; 运行效果： MVVM可以使用户界面与逻辑代码分离，如修改Label为Button，只需要编辑XAML代码即可。12&lt;Button Text=&quot;&#123;Binding Source=&#123;StaticResource dateTimeViewModel&#125; ,Path=DateTime &#125;&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot; /&gt; ICommand 接口介绍Data Binding 可以方便的连接View的属性和ViewModel的属性，有时候ViewModel还会定义公共方法给View调用，如ViewModel定义一个公共方法响应Button的点击事件。MVVM提供了command interface协议绑定方法，command interface只支持极少数的几个类：Button、MenuItem、ToolbarItem、SearchBar、TextCell、ImageCell、ListView、TapGestureRecognizer。当然也可以自定义类实现command interface的支持。 通过command interface代替Button的Clicked事件示例。Button提供了Command和CommandParameter两个属性支持commanding。ViewModel需要定义一个类型为ICommand的公告属性连接Button的Command属性。ICommand定义在System.Windows.Input命名空间下。 ICommand中定义了两个方法一个事件，当Button的Command属性绑定一个实现了ICommand接口的对象时，点击按钮触发Clicked事件的同时还会调用Command属性的Excute方法，Excute方法的参数通过Button的CommandParameter属性设置。CanExecute方法会在Command属性第一次赋值时调用，如果CanExecute返回false，表示Button不可用且不会发生Excute方法的调用。Button还会监听CanExecuteChanged事件，当CanExecuteChanged事件触发时会继续调用CanExecute方法判断Button是否可用。实际使用通常不会自己实现ICommand接口，Forms提供了ICommand的实现类Command，同时也提供了Command&lt;T&gt;类. Command出了实现ICommand接口还提供了ChangeCanExecute方法，调用该方法会触发CanExecuteChanged事件。 Command如上所示，构造函数提供的两个参数类型分别为Action和Func，excute表示Execute方法的调用，canExecute表示CanExecute方法的调用。 通过一个简单示例展示Commanding的用法。添加两个按钮使Label上显示的数字在＋3～－3之间增加和减小，效果： 首先定义NumberViewModel类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class NumberViewModel : INotifyPropertyChanged&#123; private int number = 0; private const int Increase_Limit = 3, Decrease_Limit = -3; public event PropertyChangedEventHandler PropertyChanged; public NumberViewModel() &#123; IncreaseCommand = new Command(() =&gt; &#123; Number++; &#125;, () =&gt; &#123; return number &lt; Increase_Limit; &#125;); DecreaseCommand = new Command(() =&gt; &#123; Number--; &#125;, () =&gt; &#123; return number &gt; Decrease_Limit; &#125;); &#125; public int Number &#123; private set &#123; if (SetProperty&lt;int&gt;(ref number, value)) &#123; IncreaseCommand.ChangeCanExecute(); DecreaseCommand.ChangeCanExecute(); &#125; &#125; get &#123; return number; &#125; &#125; bool SetProperty&lt;T&gt;(ref T storage, T value, [CallerMemberName] string propertyName = &quot;&quot;) &#123; if (Object.Equals(storage, value)) return false; storage = value; if (PropertyChanged != null) &#123; PropertyChanged(this, new PropertyChangedEventArgs(propertyName)); &#125; return true; &#125; #region Command public Command IncreaseCommand &#123; get; set; &#125; public Command DecreaseCommand &#123; get; set; &#125; #endregion&#125; NumberViewModel类不止实现了INotifyPropertyChanged类还定义了两个Command类型（实现了ICommand接口）属性IncreaseCommand和DecreaseCommand，这两个属性分别会绑定到加1按钮和减1按钮的Command属性。两个属性在构造函数中初始化时第一个参数的匿名委托中一定要直接操作Number属性而不是number字段，否则不会触发PropertyChanged事件，第二个参数根据number的值判断按钮是否可以用从而控制number的变化范围。修改Number的set代码，改变number值的同时调用Command的ChangeCanExecute方法触发CanExecuteChanged事件从而调用CanExecute方法（前文提到的第二个参数）。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"MVVM","slug":"MVVM","permalink":"http://xamarin.xyz/tags/MVVM/"}]},{"title":"Xamarin.Forms Data Binding介绍","slug":"Xamarin-Forms-Data-Binding介绍","date":"2016-10-07T06:55:00.000Z","updated":"2017-11-04T02:37:13.100Z","comments":true,"path":"2016/10/07/Xamarin-Forms-Data-Binding介绍/","link":"","permalink":"http://xamarin.xyz/2016/10/07/Xamarin-Forms-Data-Binding介绍/","excerpt":"很多时候我们需要将某个View1 值的改变显示在另外一个View2 上，对View1的对应事件编码可实现我们想要的效果，如果只是想处理值的改变，可以通过连接两个View的对应属性即可，称为Data Binding。Data Binding在Model-View-ViewModel (MVVM)设计模式中起着重要作用。Data Binding中设计两个概念Source 和 Target。当Source的值发生改变时Data Binding会自动将这个新的值更新到Target。对Target和Source有特殊要求，Target必须继承BindableProperty类（VisualElement通过继承Element继承了BindableObject，所以Xamarin.Forms中视图的大部分属性都是BindableProperty类型），Source必须实现INotifyPropertyChanged接口提供一种通知机制监听Source值的改变(BindableObject实现了INotifyPropertyChanged接口)。","text":"很多时候我们需要将某个View1 值的改变显示在另外一个View2 上，对View1的对应事件编码可实现我们想要的效果，如果只是想处理值的改变，可以通过连接两个View的对应属性即可，称为Data Binding。Data Binding在Model-View-ViewModel (MVVM)设计模式中起着重要作用。Data Binding中设计两个概念Source 和 Target。当Source的值发生改变时Data Binding会自动将这个新的值更新到Target。对Target和Source有特殊要求，Target必须继承BindableProperty类（VisualElement通过继承Element继承了BindableObject，所以Xamarin.Forms中视图的大部分属性都是BindableProperty类型），Source必须实现INotifyPropertyChanged接口提供一种通知机制监听Source值的改变(BindableObject实现了INotifyPropertyChanged接口)。 很多时候我们需要将某个View1 值的改变显示在另外一个View2 上，对View1的对应事件编码可实现我们想要的效果，如果只是想处理值的改变，可以通过连接两个View的对应属性即可，称为Data Binding。Data Binding在Model-View-ViewModel (MVVM)设计模式中起着重要作用。Data Binding中设计两个概念Source 和 Target。当Source的值发生改变时Data Binding会自动将这个新的值更新到Target。对Target和Source有特殊要求，Target必须继承BindableProperty类（VisualElement通过继承Element继承了BindableObject，所以Xamarin.Forms中视图的大部分属性都是BindableProperty类型），Source必须实现INotifyPropertyChanged接口提供一种通知机制监听Source值的改变(BindableObject实现了INotifyPropertyChanged接口)。 简单的Data Binding使用本示例以Slider的Value属性作Source，Label的Opacity属性作Target，实现拖动滑块影响Label透明度的效果。 代码方式设置Data Binding: 核心代码设置Target对象的BindingContext属性（BindableObject类型）。再调用Target 对象的SetBinding方法设置绑定属性关系,第一个参数targetProperty为BindableProperty类型，表示目标属性。第二个参数string类型，表示BindingContext的哪个属性为Source。本例调用的是5个参数的方法，后三个参数为默认值。 代码运行效果： XAML方式设置Data Binding：12345678910&lt;StackLayout&gt; &lt;Label Text=&quot;Opacity Binding Demo&quot; FontSize=&quot;Large&quot; VerticalOptions=&quot;CenterAndExpand&quot; HorizontalOptions=&quot;Center&quot; BindingContext=&quot;&#123;x:Reference Name=slider&#125;&quot; Opacity=&quot;&#123;Binding Path=Value&#125;&quot; /&gt; &lt;Slider x:Name=&quot;slider&quot; VerticalOptions=&quot;CenterAndExpand&quot; /&gt;&lt;/StackLayout&gt; 查看Label定义，BindingContext属性通过x:Reference指定，Opacity为目标属性通过Binding扩展标记的Path设置。Path不仅可以是Property也可以是SubProperty或 Indexer.如Content.Children[4].Value. 在整个视图树中子View是会继承父布局的BindingContext属性。如子View没有单独设置BindingContext属性，会查找上级视图若发现BindingContext赋值会直接继承，如果上级视图同样没有BindingContext赋值且存在上级视图会继续搜索上级视图BindingContext的赋值。本例修改XAML布局代码将Label的BindingContext删除添加到StackLayout中，同样会实现我们想要的效果。123456789&lt;StackLayout BindingContext=&quot;&#123;x:Reference Name=slider&#125;&quot;&gt; &lt;Label Text=&quot;Opacity Binding Demo&quot; FontSize=&quot;Large&quot; VerticalOptions=&quot;CenterAndExpand&quot; HorizontalOptions=&quot;Center&quot; Opacity=&quot;&#123;Binding Path=Value&#125;&quot; /&gt; &lt;Slider x:Name=&quot;slider&quot; VerticalOptions=&quot;CenterAndExpand&quot; /&gt;&lt;/StackLayout&gt; 同样可以使用属性节点定义方式设置Data Binding相关属性1234567891011&lt;Label Text=&quot;Opacity Binding Demo&quot; FontSize=&quot;Large&quot; VerticalOptions=&quot;CenterAndExpand&quot; HorizontalOptions=&quot;Center&quot;&gt; &lt;Label.BindingContext&gt; &lt;x:Reference Name=&quot;slider&quot; /&gt; &lt;/Label.BindingContext&gt; &lt;Label.Opacity&gt; &lt;Binding Path=&quot;Value&quot; /&gt; &lt;/Label.Opacity&gt;&lt;/Label&gt; Reference对应的C#类为ReferenceExtension,Binding对应的类为BindingExtension。两个类的定义都指定了Content Property，分别为Name和Path，所以可以简化代码：12BindingContext=&quot;&#123;x:Reference slider&#125;&quot;Opacity=&quot;&#123;Binding Value&#125;&quot; 前面是通过BindingContext指定Data Binding的Source，还可以通过Binding指定Source。对应的C#代码为SetBinding两个参数的方法： BindingBase为abstract类，Forms提供了Binding类该类继承了BindingBase。通过Binding指定Source，再将Binding对象作为参数传入SetBinding方法。 Binding 提供了重载的构造函数和静态方法Create来创建Binding对象，不作介绍。 同样XAML定义方式为，删除BindingContext属性赋值，修改Binding扩展标记。 根据内容属性简化XAML代码：1Opacity=&quot;&#123;Binding Value , Source=&#123;x:Reference slider&#125;&#125;&quot; 扩展标记定义在一对大括号内且大括号内不应出现双引号，指定多个属性值时通过逗号分隔。关于内容属性定义的简化写法《Creating Mobile Apps with Xamarin.Forms》中有提到“Even though BindingExtension defines Path as its content property, the argument name can be eliminated only when that argument is the first among multiple arguments.”大概意思是要省略内容属性的参数名称必须将其放在第一个参数,但是测试发现Opacity=&quot;{Binding Source={x:Reference slider} , Value}&quot;这种写法同样可以。 那么问题来了，如果我们给BindingContext赋值的同时也为Binding的Source赋值，应该将哪个属性对应的对象作为数据源。符合就近原则Source的优先级高于BindingContext，即指定Source时不在考虑BindingContext。且Source使用更加灵活，如一个对象的多个属性使用不同对象作为数据源只能通过Source方式指定。 Binding Mode 介绍现在要通过Data Binding实现两个Slider的Value相互影响。滑动一个Slider的同时另一个有相同变化。 愚蠢的办法是分别将两个Slider作为另一个的Source，即同时为两个Slider设置Data Binding。上一个Slider和Label的示例可以理解为Source影响Target，最简单的办法就是可以使Source和Target相互影响。BindingMode枚举可以帮助我们定义target 和 source之间的绑定模式。BindingMode有四个枚举值：• Default• OneWay — Source 的改变影响Target的值(通常是这种情况).• OneWayToSource — Target的改变影响Source的值.• TwoWay — Source和Target值改变会相互影响. 对于可读写的BindableProperty对象默认BindingMode为OneWay，只读的BindableProperty对象默认BindingMode为OneWayToSource。大多数BindableProperty对象BindingMode默认值为OneWay，以下控件的Property的BindingMode方式默认是TwoWay： 由于Slider的Value默认BindingMode为TwoWay，所以实现两个Slider连动XAMlL定义为：1234&lt;StackLayout&gt; &lt;Slider x:Name=&quot;slider&quot; VerticalOptions=&quot;CenterAndExpand&quot; /&gt; &lt;Slider BindingContext=&quot;&#123;x:Reference Name=slider&#125;&quot; Value=&quot;&#123;Binding Path=Value&#125;&quot; VerticalOptions=&quot;CenterAndExpand&quot; /&gt;&lt;/StackLayout&gt; 通过XAML明确指定BindingMode的值Value=&quot;{Binding Path=Value Mode=TwoWay}&quot;。通过C#代码指定BindingMode的值slider.SetBinding(Slider.ValueProperty,&quot;Value&quot;,BindingMode.TwoWay);。 Binding StringFormat 介绍再次把Slider作为Source，Label作为Target。将Slider的Value值绑定到Label的Text。Value值ToString后直接显示到Label上可能不是我们期望的，Binding类提供了StringFormat属性表示.NET格式化字符串。 XAML中StringFormat使用,因为StringFormat本身会包含一对大括号，所以StringFormat赋值时要包含一对单引号： C#代码设置StringFormat：1label.SetBinding(Label.TextProperty, &quot;Value&quot;, stringFormat: &quot;Slider Value Is &#123;0:F3&#125;&quot;); Binding IValueConvert 介绍目前示例Target需要的数据为string，默认转换或StringFormat可以实现效果。但是Data Binding的Target接受数据类型为一个对象时如何处理？我们可以通过value converter类完成Source到Target的类型转换，需要实现IValueConverter接口，接口有Convert和ConvertBack两个方法。 当数据由Source转换到Target时调用Convert方法。Convert方法中value表示Source传递的值，你可以通过GetType来确定它的类型，也可以默认一种类型来处理。targetType表示Target需要的数据类型，Convert方法返回的类型应与targetType相同。parameter在Binding 中会用到，culture为CultureInfo类型需要和地域文化相关的转换时会用到。 ConvertBack方法会在数据由Target转换到Source 时调用，只有Binding Mode为TwoWay 或者 OneWayToSource时才有必要实现该方法，否则直接返回null即可。value参数表示target传递的值，targetType表示source的Type类型。 示例实现效果，一个Entry 和一个Button，当Entry中内容为空时Button不可用，点击Button清空Entry。 定义IntToBoolConverter实现IValueConverter，本示例中Entry为Source，Entry的Text.Length为Path，Button为Target，IsEnabled为绑定的属性。所以自定义的Converter应有Int转换为bool的能力（Convert方法，本例中ConvertBack可直接返回null）。 XAML中使用Converter要先在Resources字典中定义IntToBoolConverter对象，指定key值，在Binding时通过StaticResource赋值。其中Resources相关内容在Style中介绍。 如果Converter只使用一次，不必在Resources中定义，直接在Binding中通过属性节点定义即可。 《Creating Mobile Apps with Xamarin.Forms》中提供了一个bool转泛型的Converter类，可以将bool值转换为我们想要的值。定义如下： 在XAML定义时，通过 x:TypeArguments指定我们需要的类型，并设置TrueObject和FalseObject属性。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Binding","slug":"Binding","permalink":"http://xamarin.xyz/tags/Binding/"}]},{"title":"Xamarin.Forms Views介绍（五）","slug":"Xamarin-Forms-Views介绍（五）","date":"2016-09-30T04:06:00.000Z","updated":"2017-11-04T02:19:40.000Z","comments":true,"path":"2016/09/30/Xamarin-Forms-Views介绍（五）/","link":"","permalink":"http://xamarin.xyz/2016/09/30/Xamarin-Forms-Views介绍（五）/","excerpt":"","text":"SearchBar使用SearchBar提供一个搜索框，方便用户实现搜索功能。 SearchBar提供属性 CancelButtonColor ：设置Cancel颜色。 Placeholder ：SearchBar默认显示文本，Text为空时显示。 Text ：SearchBar输入的文本。 SearchCommand ：用于Data Binding。 SearchCommandParameter ：用于SearchCommand的参数。 SearchBar提供事件 SearchButtonPressed ：用户按下搜索按钮时触发。 TextChanged ：Text属性改变时触发该事件。 具体使用不做介绍，实际情况会结合ListView来显示搜索结果，SearchCommand和SearchCommandParameter两个属性又涉及数据绑定相关知识，故先跳过。 WebView使用提供简易浏览器功能来访问Html页面，可以是网络页面也可以是本地Html文件或任何通过WebView查看的文档，也可以直接显示Html字符串。WebView不支持多点触碰手势，无法缩放网页。 WebView属性 CanGoBack ：返回bool类型，表示当前页面是否可以返回到上一页。 CanGoForward ：返回bool类型，表示当前页面是否可以跳转到下一页。 Source ：WebViewSource类型，表示WebView显示资源。显示网路页面：指定WebView的Source属性为要显示的页面地址（必须是完整的URL地址，包含协议）。1&lt;WebView Source=&quot;https://www.baidu.com&quot; /&gt; 运行iOS项目，网页无法显示。查看应用程序输出NSURLSession/NSURLConnection HTTP load failed (kCFStreamErrorDomainSSL, -9802)，解决方案，修改’info.plist’文件增加如下节点。对应xml节点为：12345&lt;key&gt;NSAppTransportSecurity&lt;/key&gt; &lt;dict&gt; &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt; 详情查看：http://www.jianshu.com/p/b671d2ee4458借助HtmlWebViewSource显示Html字符串,显示一个Html font元素：1234webView.Source = new HtmlWebViewSource()&#123; Html = &quot;&lt;font size=\\&quot;3\\&quot; face=\\&quot;Times\\&quot;&gt;This is another paragraph.&lt;/font&gt;&quot;&#125;; 显示本地Html文件:将Html文件和相关的CSS文件、图片等复制到平台项目中（不是PCL项目），iOS添加到Resources目录下设置Build Action 为BundleResource，Android添加到Asset目录下设置Build Action为AndroidAsset，Windows Phone赋知道项目跟目录设置Build Action为Content。通过DependencyService获取Html文件内容并赋值给HtmlWebViewSource的Html属性，同时指定HtmlWebViewSource的BaseUrl属性。iOS通过NSBundle.MainBundle.BundlePath 获取，Android指定为&quot;file:///android_asset/&quot;,Windows Phone指定为&quot;&quot;。文件读取涉及到Platform-specific API calls 相关知识先不做介绍。 WebView方法 GoBack ：返回到上一页。 GoForward ：跳转到下一页。 Eval ：调用javascript方法。WebView调用JavaScript示例：修改布局代码：1234&lt;StackLayout&gt; &lt;Button x:Name=&quot;button&quot; Text=&quot;call javascript&quot; HorizontalOptions=&quot;Center&quot; VerticalOptions=&quot;Start&quot;/&gt; &lt;WebView x:Name=&quot;webView&quot; HeightRequest=&quot;1000&quot; WidthRequest=&quot;1000&quot; /&gt;&lt;/StackLayout&gt; 增加CS代码：123456789webView.Source = new HtmlWebViewSource()&#123; Html = &quot;&lt;html&gt;\\n &lt;script&gt;\\n function buttonClick()&#123;\\n alert(\\&quot;clicked\\&quot;);\\n &#125;\\n &lt;/script&gt;\\n &lt;head&gt;\\n &lt;title&gt;Html Title&lt;/title&gt;\\n &lt;/head&gt;\\n &quot; + &quot;&lt;body&gt;\\n &lt;h1&gt;Xamrin.Forms&lt;/h1&gt;\\n &lt;button type=\\&quot;button\\&quot; onClick=\\&quot;buttonClick()\\&quot;&gt;clicked me&lt;/button&gt;\\n &lt;/body&gt;\\n&lt;/html&gt;&quot;&#125;;button.Clicked += (sender, e) =&gt;&#123; webView.Eval(&quot;buttonClick()&quot;);&#125;; 运行效果： 当WebView包含在StackLayout 或者RelativeLayout布局内时必须指定WebView的HeightRequest和WidthRequest属性，否则WebView将无法显示。 WebView事件 Navigated ：页面跳转结束时触发。 Navigating ：页面跳转开始时触发。 事件不多做介绍。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms Views介绍（四）","slug":"Xamarin-Forms-Views介绍（四）","date":"2016-09-28T13:05:00.000Z","updated":"2017-11-04T02:20:46.770Z","comments":true,"path":"2016/09/28/Xamarin-Forms-Views介绍（四）/","link":"","permalink":"http://xamarin.xyz/2016/09/28/Xamarin-Forms-Views介绍（四）/","excerpt":"","text":"BitMap表示一个位图文件，支持“JPEG, PNG, GIF, and BMP”所有图片类型。Image不支持Gif图片显示。 Image属性 Aspect ：Aspect枚举类型，设置Image的缩放模式。Fill - 拉伸图片填充整个显示区域，可能会导致图像失真.AspectFill -剪切图片填充整个区域，不会使图像失真.AspectFit - 不对图像进行拉伸和剪切处理，根据图像的大小上下或左右留白显示，默认值. 不同平台缩放效果可能会有所不同 IsLoading ：bool类型，表示图片的加载状态。 IsOpaque ：bool类型，设置Image是否透明。 Source ：ImageSource类型，设置显示的图片资源。 ImageSource介绍ImageSource提供了四个静态方法来创建对象。 FromUri ：根据网络图片资源创建对象。 FromResource ：根据嵌入到PCL的图片资源创建对象。 FromFile ：根据各个平台提供的图片资源创建对象。 FromStream ：根据.NET Stream创建对象。 Xamarin.Forms 提供了三个ImageSource的子类。 UriImageSource ：表示网络图片资源，对应FromUri。 FileImageSource ：表示平台相关图片资源，对应FromFile。 StreamImageSource ：表示流图片资源，对应FromStream。 在XAML中定义ImageSource使用提供的ImageSource子类更方便，在代码中定义使用提供的静态方法更方便,静态方法内部实现就是返回系统提供的子类。 访问网络图片资源FromUri代码示范：1234Image image = new Image()&#123; Source = ImageSource.FromUri(new Uri(&quot;http://cdn-qn0.jianshu.io/assets/apple-touch-icons/72-feca4b183b9d29fd188665785dc7a7f1.png&quot;))&#125;; 也可以直接设置Image的Source为string或Uri类型地址，会隐式转换为ImageSource。1234Image image = new Image()&#123; Source = &quot;http://cdn-qn0.jianshu.io/assets/apple-touch-icons/72-feca4b183b9d29fd188665785dc7a7f1.png&quot;&#125;; 对应XAML为：1&lt;Image Source=&quot;http://cdn-qn0.jianshu.io/assets/apple-touch-icons/72-feca4b183b9d29fd188665785dc7a7f1.png&quot;/&gt; XAML定义UriImageSource示范：12345&lt;Image HorizontalOptions=&quot;Center&quot; VerticalOptions=&quot;Center&quot; WidthRequest=&quot;200&quot; HeightRequest=&quot;200&quot; Aspect=&quot;Fill&quot;&gt; &lt;Image.Source&gt; &lt;UriImageSource Uri=&quot;http://cdn-qn0.jianshu.io/assets/apple-touch-icons/72-feca4b183b9d29fd188665785dc7a7f1.png&quot;/&gt; &lt;/Image.Source&gt;&lt;/Image&gt; UriImageSource定义了CachingEnabled和CachingValidity连个属性。CachingEnabled表示是否启用缓存，bool类型默认为true。CachingValidity表示缓存的有效时间，TimeSpan类型，默认为1天。 访问嵌入到PCL图片资源图片资源添加到PCL项目中，设置图片的Build Action为EmbeddedResource。 资源嵌入到项目中会有一个对应的资源ID，对应的资源ID为程序集名.文件夹（若果有）.图片全名（包含扩展名）,如果不能确定资源ID可以调用Assembly 对象的GetManifestResourceNames方法，返回一个string类型数组，表示项目中所有资源的ID。更简单的方法就是图片资源右键属性查看资源ID。 调用FromResource创建图片资源12var imageResID = &quot;views.image.image.png&quot;;image.Source = ImageSource.FromResource(imageResID); XAML中如何调用嵌入资源？如果你熟悉x:FactoryMethod使用，可能会想通过x:FactoryMethod调用ImageSource.FromResource方法，但是ImageSource.FromResource方法要求图片资源与调用方法在同一个程序集内，通过x:FactoryMethod调用ImageSource.FromResource方法时调用代码是在Xamarin.Forms.Xaml程序集内的。 《Creating Mobile App with Xamarin.Forms》中介绍了解决方法，定义一个XAML扩展标记（先不多做介绍）。123456789101112131415161718[ContentProperty(&quot;Source&quot;)]public class ResourceImageExtension : IMarkupExtension&#123; public string Source &#123; get; set; &#125; public object ProvideValue(IServiceProvider serviceProvider) &#123; if (Source == null) return null; return ImageSource.FromResource(Source); &#125;&#125; 定义了Source属性表示图片资源ID。添加ContentProperty特性，指定Source为ContentProperty，在使用ResourceImageExtension时不必明确指定“Source=”。 XAML中定义，local表示ResourceImageExtension所在命名空间1&lt;Image x:Name=&quot;image&quot; Source=&quot;&#123;local:ResourceImageExtension views.image.image.png&#125;&quot;/&gt; 访问单独平台图片资源由于每个平台对一些图片有特别的分辨率要求，所以有时候会为每个平台准备不同大小图片，ImageSource.FromFile静态方法和相应的FileImageSource类能方便访问存储在平台项目中的图片资源。 各平台存储图片路径:iOS - 图片存储在Resources 目录中并设置Build Action为BundleResource （提供@2x命名文件，相关分辨率知识不做介绍）.Android - 图片存储在Resources/drawable 目录中并设置Build Action:为AndroidResource. (不同分辨路图片放在Resources下drawable-ldpi 或drawable-hdpi 等子目录中 ).Windows Phone - 图片存储在Assets目录或其子目录下并设置Build Action为Content . 示例代码：1234image.Source = new FileImageSource()&#123; File = Device.OnPlatform(iOS: &quot;ios.png&quot;, Android: &quot;android.png&quot;, WinPhone: &quot;Assets/WindowsPhone.png&quot;)&#125;; 对于iOS和Android直接指定文件名即可，这两个平台资源文件默认存储在Resources目录中，Windows Phone对应的路径应包含Assets目录。 对应的XAML为12345&lt;Image&gt; &lt;Image.Source&gt; &lt;OnPlatform x:TypeArguments=&quot;ImageSource&quot; iOS=&quot;ios.png&quot; Android=&quot;android.png&quot; WinPhone=&quot;Assets/WindowsPhone.png&quot; /&gt; &lt;/Image.Source&gt;&lt;/Image&gt; 分别截取了Android和iOS模拟器的图片，运行起来效果有点怪。 通过Stream访问图片资源通过Stream可以访问网络图片和嵌入项目中的图片资源。ImageSource.FromStream或者StreamImageSource可以帮助我们轻松的访问Stream对应的图片资源。 FromStream方法的参数并不是Stream类型而是Func&lt;Stream&gt;类型（一个无参数，返回值为Stream的方法）。 示例1——访问本地嵌入图片资源123456var imageResID = &quot;views.image.image.png&quot;;image.Source = ImageSource.FromStream(() =&gt;&#123; Assembly assembly = GetType().GetTypeInfo().Assembly; return assembly.GetManifestResourceStream(imageResID);&#125;); 示例2——访问网络图片资源1234567891011121314151617var request = WebRequest.Create(new Uri(&quot;http://img2.myhsw.cn/2015-12-29/q9z0b418.jpg&quot;));request.BeginGetResponse((IAsyncResult arg) =&gt;&#123; var stream = request.EndGetResponse(arg).GetResponseStream(); //Windows 平台特殊处理 if (Device.OS == TargetPlatform.WinPhone || Device.OS == TargetPlatform.Windows) &#123; MemoryStream memStream = new MemoryStream(); stream.CopyTo(memStream); memStream.Seek(0, SeekOrigin.Begin); stream = memStream; &#125; var imageSource = ImageSource.FromStream(() =&gt; stream); Device.BeginInvokeOnMainThread(() =&gt; &#123; image.Source = imageSource; &#125;);&#125;, null); 子线程中不允许更新UI，在子线程中更新UI借助Device.BeginInvokeOnMainThread方法完成。 不同平台图片显示效果不同。“On iOS and Android, the bitmap is displayed in its pixel size. In other words, the bitmap is rendered with a one-to-one mapping between the pixels of the bitmap and the pixels of the video display. The iPhone 6 simulator used for these screenshots has a screen width of 750 pixels, and you can see that the 256-pixel width of the bitmap is about one-third that width. The Android phone here is a Nexus 5, which has a pixel width of 1080, and the bitmap is about one-quarter that width.On the Windows Runtime platforms, however, the bitmap is displayed in device-independent units—in this example, 256 device-independent units. The Nokia Lumia 925 used for these screenshots has a pixel width of 768, which is approximately the same as the iPhone 6. However, the screen width of this Windows 10 Mobile phone in device-independent units is 341, and you can see that the rendered bitmap is much wider than on the other platforms.” Toolbar使用Toolbar表示应用程序的工具栏，iOS和AndroidToolbar显示在屏幕顶部，Windows Phone显示在屏幕底部。 Forms并没有提供Toolbar类，为Page类的ToolbarItems集合赋值即可实现Toolbar效果。Windows Phone平台ContentPage添加ToolbarItem正常显示，Android和iOS平台必须使用NavigationPage。 ToolbarItem并不View实现而是继承MenuItem类，ToolbarItem定义了三个属性。Text - ToolbarItem显示的文本。Order - ToolbarItemOrder枚举类型，决定ToolbarItem显示图标（Primary）还是显示文字（Secondary）。Icon - FileImageSource类型，ToolbarItem显示的图标。FileImageSource类型说明图标文件是单独存储在平台项目中。 XAML示例代码：123456789101112131415161718192021222324252627282930313233343536373839&lt;ContentPage.ToolbarItems&gt; &lt;ToolbarItem Text=&quot;Item 1&quot; Order=&quot;Primary&quot; Clicked=&quot;响应点击事件&quot;&gt; &lt;ToolbarItem.Icon&gt; &lt;OnPlatform x:TypeArguments=&quot;FileImageSource&quot; iOS=&quot;tc.png&quot; Android=&quot;tc.png&quot;/&gt; &lt;/ToolbarItem.Icon&gt; &lt;/ToolbarItem&gt; &lt;ToolbarItem Text=&quot;Item 2&quot; Order=&quot;Primary&quot; &gt; &lt;ToolbarItem.Icon&gt; &lt;OnPlatform x:TypeArguments=&quot;FileImageSource&quot; iOS=&quot;tf.png&quot; Android=&quot;tf.png&quot;/&gt; &lt;/ToolbarItem.Icon&gt; &lt;/ToolbarItem&gt; &lt;ToolbarItem Text=&quot;Item 3&quot; Order=&quot;Primary&quot; &gt; &lt;ToolbarItem.Icon&gt; &lt;OnPlatform x:TypeArguments=&quot;FileImageSource&quot; iOS=&quot;tg.png&quot; Android=&quot;tg.png&quot;/&gt; &lt;/ToolbarItem.Icon&gt; &lt;/ToolbarItem&gt; &lt;ToolbarItem Text=&quot;Item 4&quot; Order=&quot;Secondary&quot; &gt; &lt;ToolbarItem.Icon&gt; &lt;OnPlatform x:TypeArguments=&quot;FileImageSource&quot; iOS=&quot;tf.png&quot; Android=&quot;tf.png&quot;/&gt; &lt;/ToolbarItem.Icon&gt; &lt;/ToolbarItem&gt; &lt;ToolbarItem Text=&quot;Item 5&quot; Order=&quot;Secondary&quot; &gt; &lt;ToolbarItem.Icon&gt; &lt;OnPlatform x:TypeArguments=&quot;FileImageSource&quot; iOS=&quot;tg.png&quot; Android=&quot;tg.png&quot;/&gt; &lt;/ToolbarItem.Icon&gt; &lt;/ToolbarItem&gt; &lt;/ContentPage.ToolbarItems&gt; 一定要修改App.xaml.cs文件中构造函数MainPage赋值的代码为MainPage = new NavigationPage(new 自己的page类()); 各平台图标像素要求Android ToolbarItem图标像素：• drawable-mdpi (medium DPI) — 32 pixels square• drawable-hdpi (high DPI) — 48 pixels square• drawable-xhdpi (extra high DPI) — 64 pixels square• drawable-xxhdpi (extra extra high DPI) — 96 pixels square IOS ToolbarItem图标像素：默认为20像素正方形，应提供@2x（40-pixel-square ）和@3x（60-pixel-square ）版本使iPhone5 和iPhone6有更好的显示效果。 Windows Phone ToolbarItem图标像素要求：大小为76像素的正方形图标。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms Views介绍（三）","slug":"Xamarin-Forms-Views介绍（三）","date":"2016-09-26T16:07:00.000Z","updated":"2017-11-04T02:21:17.640Z","comments":true,"path":"2016/09/27/Xamarin-Forms-Views介绍（三）/","link":"","permalink":"http://xamarin.xyz/2016/09/27/Xamarin-Forms-Views介绍（三）/","excerpt":"","text":"Picker使用Picker是一个列表选择器。点击Picker弹出一个选择列表，供用户选择，不同平台渲染效果不同。 Picker属性 Title ：定义Picker的标题，起到提示说明作用。不同平台Title渲染效果不同，Windows Phone会单独提供一个Label显示Title。 TextColor ：选中某项后，文本显示在Picker上的颜色。 Items ：IList&lt;string&gt;类型 ，表示Picker提供的可选集合，XAML中定义Items借助&lt;x:String&gt;节点。 SelectedIndex ：int类型，表示选择项索引，由0开始，默认值－1。 XAML定义：1234567891011&lt;Picker Title=&quot;Picker Title&quot; TextColor=&quot;Aqua&quot; HorizontalOptions=&quot;Center&quot; VerticalOptions=&quot;Center&quot;&gt; &lt;Picker.Items&gt; &lt;x:String&gt;Item 1&lt;/x:String&gt; &lt;x:String&gt;Item 2&lt;/x:String&gt; &lt;x:String&gt;Item 3&lt;/x:String&gt; &lt;x:String&gt;Item 4&lt;/x:String&gt; &lt;/Picker.Items&gt; &lt;Picker.SelectedIndex&gt; 2 &lt;/Picker.SelectedIndex&gt;&lt;/Picker&gt; 同时赋值Items和SelectedIndex属性，SelectedIndex赋值应再Items之后。 Picker事件 SelectedIndexChanged ：SelectIndex值发生改变时触发，响应SelectedIndexChanged事件时应对SelectIndex的－1值进行判断。 DatePicker使用DatePicker提供日期选择功能。 DatePicker属性 Date ：DateTime类型，DatePicker当前日期。 Format ：string类型，设置所选日期显示格式。 MaximumDate ：DatePicker最大可选日期，默认值1900-1-1。 MinimumDate ：DatePicker最小可选日期，默认值2100-12-31。 TextColor ：同Picker属性。 Date、MinimumDate、MaximumDate不同赋值方式参考本文示例 DatePicker事件 DateSelected ：用户选择新日起即Date发生改变时触发。 XAML定义示例：12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:local=&quot;clr-namespace:views&quot; xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot; x:Class=&quot;views.viewsPage&quot;&gt; &lt;ContentPage.Padding&gt; &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot; iOS=&quot;0, 20, 0, 0&quot; /&gt; &lt;/ContentPage.Padding&gt; &lt;DatePicker TextColor=&quot;Red&quot; Format=&quot;yyyy-MM:dd&quot; MaximumDate=&quot;2022-2-22&quot; Date=&quot;&#123;x:Static sys:DateTime.Today&#125;&quot;&gt; &lt;DatePicker.MinimumDate&gt; &lt;sys:DateTime x:FactoryMethod=&quot;Parse&quot;&gt; &lt;x:Arguments&gt; &lt;x:String&gt;2000-1-1&lt;/x:String&gt; &lt;/x:Arguments&gt; &lt;/sys:DateTime&gt; &lt;/DatePicker.MinimumDate&gt; &lt;/DatePicker&gt;&lt;/ContentPage&gt; 这里提供了整个XAML页面的定义代码。通过x:Static调用DateTime的静态属性为Date赋值，x:FactoryMethod调用DateTime的静态方法为MinimumDate赋值，要访问DateTime类，应该在跟节点ContentPage中添加System命名空间定义xmlns:sys=&quot;clr-namespace:System;assembly=mscorlib&quot;。 TimePicker使用TimePicker提供时间选择功能。 TimePicker属性 Time ：TimeSpan类型，TimePicker当前日期。 Format ：string类型，设置所选事件显示格式。。 TextColor ：同Picker属性。 XAML定义参考DatePicker。 TimePicker事件TimePicker并没有自定义事件,不知道为什么没有提供TimeSelected事件。如何监听TimePicker的Time改变事件？PropertyChanged事件同样可以监听Time的变化，PropertyChanged事件由BindableObject提供，当BindableProperty类型属性改变时会触发PropertyChanged事件。 1234567timePicker.PropertyChanged += (sender, e) =&gt;&#123; if (e.PropertyName.Equals(&quot;Time&quot;)) &#123; DisplayAlert(&quot;Time Alert&quot;, $&quot;&#123;timePicker.Time.ToString()&#125;&quot;, &quot;OK&quot;); &#125;&#125;;","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms Views介绍（二）","slug":"Xamarin-Forms-Views介绍（二）","date":"2016-09-26T04:09:00.000Z","updated":"2017-11-04T02:22:56.000Z","comments":true,"path":"2016/09/26/Xamarin-Forms-Views介绍（二）/","link":"","permalink":"http://xamarin.xyz/2016/09/26/Xamarin-Forms-Views介绍（二）/","excerpt":"","text":"Button使用功能很简单，用来响应用户的点击操作。 Button特殊属性介绍Text、FontAttributes等属性不再说明。 Image ：FileImageSource类型，按钮上显示的图片，涉及图片资源先不介绍。 BorderWidth ：double类型，表示按钮边框宽度，默认值0。 BorderColor ：边框颜色，默认值Color.Default。 BorderRadius ：double类型，按钮圆角弧度，默认值5。 只设置BorderWidth属性，仅IOS有边框效果。同时设置BorderWidth和BorderColor，使 Windows 10 mobile显示边框效果。而Android要同时设置BorderWidth、BorderColor和BackgroundColor才会有边框效果。BorderRadius仅对Android和IOS有效 Button事件 Clicked ：用户点击按钮，手指抬起时触发，手指按下移动手指到按钮外不会触发。 示例：123456&lt;Button Text=&quot;Forms Button&quot; HorizontalOptions=&quot;Center&quot; VerticalOptions=&quot;Center&quot; BorderWidth=&quot;5&quot; BorderColor=&quot;Aqua&quot; BackgroundColor=&quot;Red&quot;/&gt; 效果，Android预览效果变形，运行时正常（为了演示属性，效果是难看了）： #ActivityIndicator使用给用户简单的反馈表明程序正在运行，不提供具体进度信息。不同平台效果 ActivityIndicator内部实现只定义了两个属性。 Color ：表示指示器颜色。 IsRunning ：bool类型，指示活动是否正在运行，设置为false时ActivityIndicator自动隐藏。 无特殊事件。 XAML定义：12345&lt;ActivityIndicator HorizontalOptions=&quot;Center&quot; VerticalOptions=&quot;Center&quot; Color=&quot;Red&quot; IsRunning=&quot;true&quot;/&gt; ProgressBar使用显示进度信息。定义了Progress属性表示当前进度。Progress也是ProgressBar定义的唯一属性，没有提供MaxXX和MinXX相关属性，所以Progress有效值是0～1范围内的double类型数值。不同平台效果展示： XAML定义123&lt;ProgressBar VerticalOptions=&quot;Center&quot; Progress=&quot;.5&quot; /&gt; ProgressBar定义了一个ProgressTo方法设置当前进度值，与直接赋值Progress不同ProgressTo提供了动画效果（Animate方法实现）。第一个参数value表示设置的进度值，第二个参数length表示多少时间内达到设置的值（毫秒），第三个参数easing表示动画效果。 使用示例和效果：1await progressBar.ProgressTo(0.8, 3000, Easing.BounceOut); Slider使用Slider是一个水平拖动的滑块。 Slider提供属性 Maximum ：double类型，表示Slider支持最大值,默认值1。 Minimum ：double类型，表示Slider支持最小值，默认值0。 Value ：double类型，表示Slider当前值。 定义Slider注意事项。Minimum值必须小于Maximum值，Value值必须大于等于Minimum小于等于Maximum。 如&lt;Slider Minimum=&quot;10&quot;/&gt;定义Slider引发异常： XAML解析器解析Slider节点，初始化Slider定义Minimum为10，Maximum值仍是默认值1，Minimum大于Maximum引发异常，因此定义Slider时应先为Maximum赋值再为Minimum赋值，Minimum和Maximum有正确的赋值之后再为Value赋值。 当我们先定义Value值为30时，滑块仍处于最小值位置不会出现我们期望的效果，这是因为XAML解析器解析Slider节点会根据属性赋值顺序从前到后初始化Slider对象，先赋值Value等于30，此时Minimum值为0，Maximum值为1，Value等于30不是一个合法的值. ##Slider提供事件 ValueChanged ：Value值发生改变时触发。 Stepper使用Stepper 与Slider类似，区别是Stepper两个按钮组成，两个按钮加减一个增量值改变Value的值。 Stepper提供属性 Increment ：double类型，表示Stepper增量值，默认值1。 Maximum ：double类型，表示Stepper支持最大值,默认值100。 Minimum ：double类型，表示Stepper支持最小值，默认值0。 Value ：double类型，表示Stepper当前值。 ##Stepper提供事件 ValueChanged ：Value值发生改变时触发。 Switch使用Switch表示开关按钮，获取用户bool类型输入。Switch只定义了一个IsToggled属性，IsToggled属性的改变会触发Toggled事件。 当我们为Switch的x:Name属性时赋值时可能会赋值为switch与C#关键字重复，可以替换为@switch。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms Views介绍（一）","slug":"Xamarin-Forms-Views介绍（一）","date":"2016-09-23T13:11:00.000Z","updated":"2017-11-04T02:18:51.000Z","comments":true,"path":"2016/09/23/Xamarin-Forms-Views介绍（一）/","link":"","permalink":"http://xamarin.xyz/2016/09/23/Xamarin-Forms-Views介绍（一）/","excerpt":"Views指的就是组成我们App的用户控件，如前面我们频繁用到的Label，由于跨平台因素的影响，Forms并没有为我们提供太多的用户控件。这些控件均继承View。","text":"Views指的就是组成我们App的用户控件，如前面我们频繁用到的Label，由于跨平台因素的影响，Forms并没有为我们提供太多的用户控件。这些控件均继承View。 Views指的就是组成我们App的用户控件，如前面我们频繁用到的Label，由于跨平台因素的影响，Forms并没有为我们提供太多的用户控件。这些控件均继承View。 Label使用Label用来显示文本内容。 常用属性介绍： Text ：Label显示的文本内容。 FontSize ：Label显示的文本字体大小，double值或者特殊的字符串值（Default、Micro、Small、Medium、Large）。 FontSize 设置为NamedSize枚举时，会根据不同平台选择效果最佳的一个值。Xaml中指定对应的枚举字符串,代码中设置label.FontSize=Device.GetNamedSize(NamedSize.Large,typeof(Label));, Device.GetNamedSize返回各个平台对应ElementType的合适值。 TextColor ：Label显示的文本颜色。 BackgroundColor ：Label背景色。 FontAttributes ：Label显示的文本样式（加粗、斜体）。 LineBreakMode ：Label显示的文本换行模式,默认为WordWrap。 123456789public enum LineBreakMode&#123; NoWrap, //不换行，超出部分隐藏 WordWrap,//单词为单位换行 CharacterWrap,//字符换行，即会出现单词隔断现象 HeadTruncation,//头部截断，省略头部文本以...代替 TailTruncation,//尾部截断 MiddleTruncation//中间截断&#125; FormattedText ：FormattedString类型，可以对一个Label设置多段不同样式文本。使用示例： 1234567891011&lt;Label VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot; &gt; &lt;Label.FormattedText&gt; &lt;FormattedString&gt; &lt;FormattedString.Spans&gt; &lt;Span Text=&quot;Red Bold&quot; ForegroundColor=&quot;Red&quot; FontAttributes=&quot;Bold&quot; /&gt; &lt;Span Text=&quot;Default&quot; /&gt; &lt;Span Text=&quot;italic small&quot; FontAttributes=&quot;Italic&quot; FontSize=&quot;Small&quot; /&gt; &lt;/FormattedString.Spans&gt; &lt;/FormattedString&gt; &lt;/Label.FormattedText&gt;&lt;/Label&gt; 示例中涉及到了两个属性节点Label.FormattedText和FormattedString.Spans，显得代码冗长，可以删除FormattedString.Spans节点，只保留节点内元素，显示同样效果。 FormattedString定义时添加了ContentProperty特性，指示内容属性，对于内容属性在XAML中以节点属性方式使用时可以省略对应的属性节点直接设置内容元素。 Label使用示例： 12345678910111213&lt;Label Text=&quot;Welcome to Xamarin Forms! Welcome to Xamarin Forms! Welcome to Xamarin Forms! Welcome to Xamarin Forms! Welcome to Xamarin Forms! Welcome to Xamarin Forms!&quot; FontAttributes=&quot;Bold&quot; TextColor=&quot;Silver&quot; BackgroundColor=&quot;Aqua&quot; FontSize=&quot;Small&quot; LineBreakMode=&quot;WordWrap&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot; /&gt; 效果图： Entry使用Entry单行文本录入控件，适合简短信息录入，如登录界面的用户名和密码。 常用属性： Text ：Entry内的文本内容。 TextColor ：Entry文本颜色。 Placeholder ：占位符，Text为空时显示。 PlaceholderColor ：占位符颜色。 IsPassword ：是否为密码格式，默认false，设置true时输入内容以密码格式显示。 Keyboard ：软键盘类型。更多信息参考：https://developer.xamarin.com/recipes/cross-platform/xamarin-forms/controls/choose-keyboard-for-entry/ WidthRequest ：设置控件宽度，HorizontalOptions=&quot;Fill&quot;时无效 ，同理HeightRequest。 InputTransparent ：是否接受用户输入。默认false，设置true时，控件接收用户输入时不做响应，传递父控件处理。 使用示例：1234567891011&lt;Entry Text=&quot;Entry内文本&quot; TextColor=&quot;Fuchsia&quot; Placeholder=&quot;录入数据&quot; PlaceholderColor=&quot;Green&quot; IsPassword=&quot;true&quot; Keyboard=&quot;Telephone&quot; InputTransparent=&quot;false&quot; WidthRequest=&quot;200&quot; VerticalOptions=&quot;Start&quot; HorizontalOptions=&quot;Center&quot;/&gt; 效果图： 常用事件： Focused ：控件获取焦点时触发，定义在VisualElement中的事件。 Unfocused ：控件失去焦点时触发，定义在VisualElement中的事件。 SizeChanged ：控件大小改变，定义在VisualElement中的事件。 Completed ：用户录入结束时出发（IOS用户按下Done键，Android，Windows Phone用户点击回车键或者物理键盘返回）。 TextChanged ：Entry文本改变时触发。 以Completed事件为例：在CS文件中定义一个方法：12345void Entry_Completed(object sender, EventArgs e)&#123; var entry = (Entry)sender; ...&#125; 接下来就是将定义的方法与Entry的Completed事件绑定。 Xaml 方式绑定事件，设置Entry的Completed属性Completed=&quot;Entry_Completed&quot;。代码方式绑定事件代码 entry.Completed+=Entry_Completed; 也可以省略方法的定义，借助Lambda表达式：123entry.Completed += (sender, e) =&gt; &#123; var entry = (Entry)sender;&#125;; 其它事件同理，区别在于第二个参数可能是EventArgs的子类以传递更多的信息。 Editor使用Editor同样作为一个用户输入控件使用，与Entry不同Editor允许输入多行数据。 使用事例：1234&lt;Editor VerticalOptions=&quot;Start&quot; HeightRequest=&quot;200&quot; BackgroundColor=&quot;Gray&quot; TextColor=&quot;Red&quot; /&gt; 运行效果： Editor使用与Entry相似。不同的是Completed事件的触发，Editor中回车键文本换行并不会触发Completed事件。 BoxView使用定义一个带有颜色的矩形，默认大小40*40,自定义大小可以通过WidthRequest和HeightRequest设置BoxView的大小。除此之外还不知道这东西有什么用…1&lt;BoxView Color=&quot;Blue&quot; VerticalOptions=&quot;Center&quot; HorizontalOptions=&quot;Center&quot;/&gt;","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms布局讲解(四)","slug":"Xamarin-Forms布局讲解(四)","date":"2016-09-17T15:26:00.000Z","updated":"2017-11-03T01:10:31.000Z","comments":true,"path":"2016/09/17/Xamarin-Forms布局讲解(四)/","link":"","permalink":"http://xamarin.xyz/2016/09/17/Xamarin-Forms布局讲解(四)/","excerpt":"AbsoluteLayout是一种绝对布局，在AbsoluteLayout中可以明确的指出子视图的位置（相对于左边和上边的坐标）和大小（不设置大小时默认为子视图本身大小），位置和大小的设置可以是一个绝对值也可以是相对于当前AbsoluteLayout的一个比例值，绝对值和比例值可以混合使用。由于设备尺寸不同故绝对值不推荐使用。","text":"AbsoluteLayout是一种绝对布局，在AbsoluteLayout中可以明确的指出子视图的位置（相对于左边和上边的坐标）和大小（不设置大小时默认为子视图本身大小），位置和大小的设置可以是一个绝对值也可以是相对于当前AbsoluteLayout的一个比例值，绝对值和比例值可以混合使用。由于设备尺寸不同故绝对值不推荐使用。 AbsoluteLayout介绍AbsoluteLayout是一种绝对布局，在AbsoluteLayout中可以明确的指出子视图的位置（相对于左边和上边的坐标）和大小（不设置大小时默认为子视图本身大小），位置和大小的设置可以是一个绝对值也可以是相对于当前AbsoluteLayout的一个比例值，绝对值和比例值可以混合使用。由于设备尺寸不同故绝对值不推荐使用。 演示如何在屏幕的上下左右四边中间位置定义一个指定大小的Label。下面的效果（IOS预览效果，顶部空白是IOS状态栏预留）： AbsoluteLayout布局的子视图，通过AbsoluteLayout.LayoutBounds属性来位置和大小，AbsoluteLayout.LayoutFlags属性指定是绝对值还是比例值。 LayoutBounds是Rectangle类型对象，拥有如下四个值，AbsoluteLayouty也是通过这四个值确定子视图的位置和大小。 X – 子视图的水平坐标Y – 子视图的垂直坐标Width – 子视图的宽度Height – 子视图的高度 相对值设置需指定0～1之间的一个double值，表示子视图与布局之间的对应关系，如：子视图的Width为一个.5的相对值，定义在一个宽度为480的Layout中，则子视图的宽度为480 ＊ 0.5 ＝ 240.绝对值使用明确值设置子视图的X，Y，Width，Heigh值即可. LayoutFlags是AbsoluteLayoutFlags类型枚举,多个枚举值可以通过逗号分隔（XAML中）组合使用。 None – 默认值。表示X，Y，Width，Height四个值都是绝对值.All – 表示所有值都是相对值.WidthProportional – 只有Width是相对值.HeightProportional – 只有Height是相对值.XProportional – 只有X是相对值.YProportional – 只有Y是相对值.PositionProportional – X,Y 是相对值.SizeProportional – Width和Height是相对值. 本文示例Xaml定义如下：123456&lt;AbsoluteLayout&gt; &lt;Label Text=&quot;Left Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;0,.5,20,200&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt; &lt;Label Text=&quot;Top Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;.5,0,200,20&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt; &lt;Label Text=&quot;Rop Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;1,.5,20,200&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt; &lt;Label Text=&quot;Right Center&quot; BackgroundColor=&quot;Lime&quot; AbsoluteLayout.LayoutBounds=&quot;.5,1,200,20&quot; AbsoluteLayout.LayoutFlags=&quot;PositionProportional&quot;/&gt;&lt;/AbsoluteLayout&gt; 代码中定义布局子视图调用AbsoluteLayout提供的静态方法：AbsoluteLayout.SetLayoutBounds设置AbsoluteLayout.LayoutBounds属性，AbsoluteLayout.SetLayoutFlags设置AbsoluteLayout.LayoutFlags属性。 设置LayoutFlags的组合值AbsoluteLayout.SetLayoutFlags(label,AbsoluteLayoutFlags.XProportional|AbsoluteLayoutFlags.YProportional);","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"AbsoluteLayout","slug":"AbsoluteLayout","permalink":"http://xamarin.xyz/tags/AbsoluteLayout/"}]},{"title":"Xamarin.Forms布局讲解(三)","slug":"Xamarin-Forms布局讲解(三)","date":"2016-09-15T17:04:00.000Z","updated":"2017-11-03T01:11:27.000Z","comments":true,"path":"2016/09/16/Xamarin-Forms布局讲解(三)/","link":"","permalink":"http://xamarin.xyz/2016/09/16/Xamarin-Forms布局讲解(三)/","excerpt":"Grid是一种横竖排列的布局，即九宫格。可以通过ColumnSpacing和RowSpacing设置每行每列之间的间隙。Xaml定义时会先通过RowDefinitions 和ColumnDefinitions确定Grid行和列的数量，RowDefinition的Height属性表示每行的高度，ColumnDefinition的’Width’属性表示每列的宽度。Height和Width都是’GridLength’类型。","text":"Grid是一种横竖排列的布局，即九宫格。可以通过ColumnSpacing和RowSpacing设置每行每列之间的间隙。Xaml定义时会先通过RowDefinitions 和ColumnDefinitions确定Grid行和列的数量，RowDefinition的Height属性表示每行的高度，ColumnDefinition的’Width’属性表示每列的宽度。Height和Width都是’GridLength’类型。 Grid介绍Grid是一种横竖排列的布局，即九宫格。可以通过ColumnSpacing和RowSpacing设置每行每列之间的间隙。Xaml定义时会先通过RowDefinitions 和ColumnDefinitions确定Grid行和列的数量，RowDefinition的Height属性表示每行的高度，ColumnDefinition的’Width’属性表示每列的宽度。Height和Width都是’GridLength’类型。 定义GridLength类型时可能会涉及到GridUnitType枚举类型的使用。 • Absolute—表示一个具体宽高值（device-independent units，在XAML中定义是用具体数字表示）• Auto—表示宽高由内容决定 (在XAML中用“Auto” 表示)• Star—余下的单元格按比例分配宽高 ( 在XAML中用“*”表示或数字+“*”) XAML定义示例，定义一个两行两列的Grid,第一行的高度是90，第二行的高度是180,第一列宽度是自适应Cell的宽度，第二列是填充剩余宽度：12345678910111213&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;90&quot; /&gt; &lt;RowDefinition Height=&quot;180&quot; /&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;Auto&quot; /&gt; &lt;ColumnDefinition Width=&quot;*&quot; /&gt; &lt;/Grid.ColumnDefinitions&gt; ... &lt;/Grid&gt; 代码定义只要调用Grid的RowDefinitions和ColumnDefinitions的Add方法即可： Grid的行和列定义完之后，就可以确定每个视图所在的行和列。将Grid的Xaml定义修改如下：123456789101112131415&lt;Grid&gt; &lt;Grid.RowDefinitions&gt; &lt;RowDefinition Height=&quot;90&quot; /&gt; &lt;RowDefinition Height=&quot;180&quot; /&gt; &lt;/Grid.RowDefinitions&gt; &lt;Grid.ColumnDefinitions&gt; &lt;ColumnDefinition Width=&quot;Auto&quot; /&gt; &lt;ColumnDefinition Width=&quot;*&quot; /&gt; &lt;/Grid.ColumnDefinitions&gt; &lt;Label Text=&quot;Top Left&quot; Grid.Row=&quot;0&quot; Grid.Column=&quot;0&quot; BackgroundColor=&quot;Aqua&quot;/&gt; &lt;Label Text=&quot;Top Right&quot; Grid.Row=&quot;0&quot; Grid.Column=&quot;1&quot; BackgroundColor=&quot;Yellow&quot;/&gt; &lt;Label Text=&quot;Bottom Left&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;0&quot; BackgroundColor=&quot;Lime&quot;/&gt; &lt;Label Text=&quot;Bottom Right&quot; Grid.Row=&quot;1&quot; Grid.Column=&quot;1&quot; BackgroundColor=&quot;Red&quot;/&gt;&lt;/Grid&gt; 预览中IOS的效果如下： 子视图所在的位置是由Grid.Row和Grid.Column两个属性确定的（Grid提供的附加属性），两个属性的默认值都为0，即默认位置第一行的第一列。对于这两个属性有很灵活的代码设置方法。可以通过Grid对象Children属性的Add方法添加视图时指定 其中view是我们要添加的视图，left和top对应Grid.Column和Grid.Row。 除此之外还可以用Grid提供的静态方法Grid.SetColumn和Gird.SetRow方法指定子视图的位置。调用如下 view表示子视图，第二个参数表示设置的值。 观察SetColumn的方法实现： 方法中调用了第一参数的SetValue方法。Forms中的所有视图都是BindableObject（特殊类型先不做介绍）类型的，继承关系是：View VisualElement Element BindableObject所以可以直接调用子视图的SetValue方法设置： 还有两个附加属性Grid.ColumnSpan和Grid.RowSpan表示子视图占据Grid的多少空间（几列和几行），Grid.ColumnSpan=&quot;2&quot;表示占2列。使用与Grid.Row和Grid.Column类似。","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"},{"name":"Grid","slug":"Grid","permalink":"http://xamarin.xyz/tags/Grid/"}]},{"title":"Xamarin.Forms 布局讲解（二）","slug":"Xamarin-Forms-布局讲解（二）","date":"2016-09-15T14:23:00.000Z","updated":"2017-11-02T13:53:47.000Z","comments":true,"path":"2016/09/15/Xamarin-Forms-布局讲解（二）/","link":"","permalink":"http://xamarin.xyz/2016/09/15/Xamarin-Forms-布局讲解（二）/","excerpt":"RelativeLayout是一种相对布局，相对的位置可以是父布局（layout）或其它视图（view）。虽然名称和Android中的RelativeLayout布局相同，但是使用却有很大的差距，Forms RelativeLayout布局借助Constraints（约束）来确定子视图的位置和大小。","text":"RelativeLayout是一种相对布局，相对的位置可以是父布局（layout）或其它视图（view）。虽然名称和Android中的RelativeLayout布局相同，但是使用却有很大的差距，Forms RelativeLayout布局借助Constraints（约束）来确定子视图的位置和大小。 #RelativeLayout介绍 RelativeLayout是一种相对布局，相对的位置可以是父布局（layout）或其它视图（view）。虽然名称和Android中的RelativeLayout布局相同，但是使用却有很大的差距，Forms RelativeLayout布局借助Constraints（约束）来确定子视图的位置和大小。 创建项目使用如下代码修改布局文件：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ContentPage xmlns=&quot;http://xamarin.com/schemas/2014/forms&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2009/xaml&quot; xmlns:local=&quot;clr-namespace:layout&quot; x:Class=&quot;layout.layoutPage&quot;&gt; &lt;ContentPage.Padding&gt; &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot; iOS=&quot;0, 20, 0, 0&quot; /&gt; &lt;/ContentPage.Padding&gt; &lt;RelativeLayout x:Name=&quot;layout&quot;&gt; &lt;/RelativeLayout&gt;&lt;/ContentPage&gt; xaml文件中定义涉及到ConstraintExpression的使用，为了更好的理解Constraint在RelativeLayout中的作用，先用代码的方式定义布局。 在页面的构造函数中InitializeComponent方法后添加如下代码：12345678910111213141516171819var label1 = new Label()&#123; Text = &quot;Text 1&quot;, BackgroundColor = Color.Red&#125;;layout.Children.Add(label1, Constraint.RelativeToParent((layoutView) =&gt;&#123; return 100;&#125;), Constraint.RelativeToParent((layoutView) =&gt;&#123; return 100;&#125;), Constraint.RelativeToParent((layoutView) =&gt;&#123; return 200;&#125;), Constraint.RelativeToParent((layoutView) =&gt; return 200;&#125;)); 通常情况用户自己编写的代码要放在InitializeComponent方法后，InitializeComponent表示xaml定义的页面初始化完成。 layout指的是我们在xaml文件中指定了x:Name的RelativeLayout布局。RelativeLayout的Children属性是RelativeLayout.IRelativeList&lt;View&gt;类型，提供了三种重载的Add方法. 本文中调用第三个重载方法定义向RelativeLayout中添加子视图。后四个参数分别代表子视图的x,y坐标和宽高的约束。相对于布局的约束还是其它子视图的约束可以通过Constraint的两个静态方法区分，Constraint.RelativeToParent创建相对于布局视图的约束，Constraint.RelativeToView创建相对于其它子视图的约束。参数中Func委托反悔的double是当前Constraint的值，即创建xConstraint时返回值对应视图的X坐标。运行效果： 两个方法的实现就是根据我们传入的Func委托（RelativeToView方法多一个View视图）定义一个Constraint实例返回： 继续添加如下代码，示范RelativeToView方法的使用：1234567891011121314151617layout.Children.Add(new Label()&#123; Text = &quot;Text 2&quot;, BackgroundColor = Color.Blue&#125;, Constraint.RelativeToParent((layoutView) =&gt;&#123; return 0;&#125;), Constraint.RelativeToView(label1, (layoutView, view) =&gt;&#123; return view.Height + view.X + 100;&#125;), Constraint.RelativeToParent((layoutView) =&gt;&#123; return 400;&#125;), Constraint.RelativeToParent((layoutView) =&gt;&#123; return 100;&#125;)); RelativeToView的第一个参数表示根据哪个视图创建约束，与第二个Func中的第二个参数应该表示同一个View。运行项目查看效果： 接下来示范如何直接在Xaml文件中定义RelativeLayout布局。定义在RelativeLayout中的视图会有对应x,y,width,height约束的扩展属性如RelativeLayout.XConstraint,在xaml中通过ConstraintExpression设置对应的约束。 修改xaml文件代码：123456789101112&lt;RelativeLayout&gt; &lt;Label x:Name=&quot;label1&quot; Text=&quot;Label 1&quot; BackgroundColor=&quot;Blue&quot; WidthRequest=&quot;200&quot; HeightRequest=&quot;200&quot; RelativeLayout.XConstraint = &quot;&#123;ConstraintExpression Type=RelativeToParent,Property=X,Factor=1,Constant=100&#125;&quot; RelativeLayout.YConstraint = &quot;&#123;ConstraintExpression Type=RelativeToParent,Property=Y,Factor=1,Constant=100&#125;&quot;/&gt; &lt;Label Text=&quot;Label 2&quot; BackgroundColor=&quot;Red&quot; RelativeLayout.XConstraint=&quot;&#123;ConstraintExpression Type=RelativeToParent,Property=X,Factor=1,Constant=0&#125;&quot; RelativeLayout.YConstraint=&quot;&#123;ConstraintExpression Type=RelativeToView,ElementName=label1,Property=Y,Factor=2,Constant=200&#125;&quot; RelativeLayout.WidthConstraint=&quot;&#123;ConstraintExpression Type=RelativeToView,ElementName=label1,Property=Width,Factor=2,Constant=0&#125;&quot; RelativeLayout.HeightConstraint=&quot;&#123;ConstraintExpression Type=RelativeToView,ElementName=label1,Property=Height,Factor=0.5,Constant=0&#125;&quot;/&gt;&lt;/RelativeLayout&gt; 通过RelativeLayout.XConstraint和RelativeLayout.YConstraint确定视图的位置（Position）,视图的大小可以通过设置WidthRequest和HeightRequest或者设置RelativeLayout.WidthConstraint和RelativeLayout.HeightConstraint两种方式确定。 根据ConstraintExpression定义约束时每个字段含义介绍：Type – 以什么方式定义约束，RelativeToParent和RelativeToViewProperty – 以相对视图的哪个属性作为基础值.Factor – Property的倍数值.Constant – 约束Value的偏移数值.ElementName – 当Type定义为RelativeToView时,ElementName用来确定约束相对与哪个子视图. 以Label 2 HeightConstraint的为例：RelativeLayout.HeightConstraint=&quot;{ConstraintExpression Type=RelativeToView,ElementName=label1,Property=Height,Factor=0.5,Constant=0}&quot;表示：Label 2 的高度 ＝ Label 1 的高度 （Property=Height）＊ 0.5（Factor=0.5） ＋ 0（Constant=0）预览效果：","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Forms 布局讲解（一）","slug":"Xamarin-Forms-布局讲解（一）","date":"2016-09-12T15:35:00.000Z","updated":"2017-11-02T13:55:48.000Z","comments":true,"path":"2016/09/12/Xamarin-Forms-布局讲解（一）/","link":"","permalink":"http://xamarin.xyz/2016/09/12/Xamarin-Forms-布局讲解（一）/","excerpt":"tackLayout是一种堆栈式布局，类似Android中的LinearLayout。StackLayout只提供了两个属性：• Orientation :StackOrientation枚举类型，表示StackLayout以哪种方式布局， Vertical (垂直方向布局) 和 Horizontal（水平方向布局）,默认值是Vertical.• Spacing :double类型，表示每个子视图之间的间隙, 默认值 6.0.","text":"tackLayout是一种堆栈式布局，类似Android中的LinearLayout。StackLayout只提供了两个属性：• Orientation :StackOrientation枚举类型，表示StackLayout以哪种方式布局， Vertical (垂直方向布局) 和 Horizontal（水平方向布局）,默认值是Vertical.• Spacing :double类型，表示每个子视图之间的间隙, 默认值 6.0. #布局的引入 首先要注意创建项目时确保“Use XAML for user interface files”勾选，使用XAML文件实现布局，默认选中。 先忽略Shared Code 选项，保持默认。App Name输入layout，创建项目。生成的解决方案结构如下： 目前关注layout项目即可，layoutPage.xaml就是我们程序的布局文件。查看文件内容会发现一个ContentPage根结点。运行项目查看效果后，修改文件内容（xaml知识点不做介绍）： 123456789&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:layout\" x:Class=\"layout.layoutPage\"&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" VerticalOptions=\"Start\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" VerticalOptions=\"Center\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" VerticalOptions=\"End\" HorizontalOptions=\"Center\" /&gt;&lt;/ContentPage&gt; 运行项目看到如下效果： 只显示了最后一个Label。看到官方电子书中介绍： “The ContentPage class defines a Content property of type View that you can set to an object—but only one object. Displaying multiple views requires setting Content to an instance of a class that can have multiple children of type View. Such a class is Layout, which defines a Children property of type IList.” 大致意思就是ContentPage有一个Content属性设置显示的内容，但是只能设置一个对象，要显示多个视图必须Content设置为继承了Layout（抽象类）的对象实例。 系统为我们提供了四个继承Layout的类：• AbsoluteLayout• Grid• RelativeLayout• StackLayout 这四个类都以集合的形式管理Children。 #StackLayout介绍 先修改我们的布局文件，使用StackLayout进行布局：1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:layout\" x:Class=\"layout.layoutPage\"&gt; &lt;StackLayout&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" VerticalOptions=\"StartAndExpand\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" VerticalOptions=\"Center\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" VerticalOptions=\"EndAndExpand\" HorizontalOptions=\"Center\" /&gt; &lt;/StackLayout&gt;&lt;/ContentPage&gt; 注意第一个和最后一个Label的VerticalOptions的属性设置,Expand（只对StackLayout布局起作用）表示扩展填充StartAndExpand表示放置在布局开始且自动填充布局的空余位置，可以尝试设置不同值查看效果。先忽略第一个Label与IOS状态栏重叠的问题，Android效果应该是正常的，这里先只给出IOS的效果。 StackLayout是一种堆栈式布局，类似Android中的LinearLayout。StackLayout只提供了两个属性：• Orientation :StackOrientation枚举类型，表示StackLayout以哪种方式布局， Vertical (垂直方向布局) 和 Horizontal（水平方向布局）,默认值是Vertical.• Spacing :double类型，表示每个子视图之间的间隙, 默认值 6.0. 调整布局代码，设置StackLayout的Spacing属性为一个较大的值并增加Label数量，为Label提供不同的BackgroundColor。12345678910111213141516&lt;StackLayout Spacing=\"40\"&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Aqua\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Blue\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Fuchsia\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Gray\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Green\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Lime\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Maroon\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Navy\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Olive\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Purple\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Red\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Silver\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Teal\" HorizontalOptions=\"Center\" /&gt; &lt;Label Text=\"Welcome to Xamarin Forms!\" BackgroundColor=\"Yellow\" HorizontalOptions=\"Center\" /&gt; &lt;/StackLayout&gt; 运行效果： 布局超出屏幕无法显示，我们可以借助ScrollView实现滚动效果，将StackLayout节点放入ScrollView节点即可： ScrollView继承了Layout类，因此它是一个布局类且只可以包含一个子视图。 关于前面提到的IOS中ContentPage与IOS状态栏重叠的问题解决可以通过属性节点和OnPlatform解决，后面再做详细介绍。 12345&gt;&lt;ContentPage.Padding&gt; &gt; &lt;OnPlatform x:TypeArguments=&quot;Thickness&quot; &gt; iOS=&quot;0, 20, 0, 0&quot; /&gt;&gt;&lt;/ContentPage.Padding&gt;&gt; 尝试运行Android项目，报错 关注前两个报错，提示下载android_m2repository_r22.zip文件保存到指定目录，第二个提示指定的zip文件不是一个有效的文件。 解决办法：下载android_m2repository_r22.zip文件，复制到错误信息中提到的目录，并替换第二个错误中提到的文件。Build-&gt;Clean All ，清理项目后重新运行即可。 最后贴出IOS和Android运行的效果图：","categories":[{"name":"Xamarin.Forms","slug":"Xamarin-Forms","permalink":"http://xamarin.xyz/categories/Xamarin-Forms/"}],"tags":[{"name":"Forms","slug":"Forms","permalink":"http://xamarin.xyz/tags/Forms/"}]},{"title":"Xamarin.Android OnTouchEvent和GestureDetector简介","slug":"ontouchevent-gesturedetector","date":"2016-06-23T17:03:04.000Z","updated":"2017-11-02T15:17:53.810Z","comments":true,"path":"2016/06/24/ontouchevent-gesturedetector/","link":"","permalink":"http://xamarin.xyz/2016/06/24/ontouchevent-gesturedetector/","excerpt":"好久没有写博了，也就是说好久没学习Xamarin相关的东西了，潇洒了一段时间今天了解一下Android触碰和手势相关的知识。OnTouchEvent是基于回调的，当我们的返回值为false时Touch事件继续向外传，由外层容器或Activity处理。","text":"好久没有写博了，也就是说好久没学习Xamarin相关的东西了，潇洒了一段时间今天了解一下Android触碰和手势相关的知识。OnTouchEvent是基于回调的，当我们的返回值为false时Touch事件继续向外传，由外层容器或Activity处理。 1public override bool OnTouchEvent (MotionEvent e) OnTouchEvent方法的传入一个MotionEvent对象，其中MotionEvent常用的有Action、PointerCount、DownTime、EventTime等属性和GetX及GetY方法。 Action属性是一个MotionEventActions枚举，定义如下： 12345678910111213141516171819202122232425262728[Flags]public enum MotionEventActions&#123; ButtonPress = 11, ButtonRelease = 12, Cancel = 3, Down = 0, HoverEnter = 9, HoverExit = 10, HoverMove = 7, Mask = 255, Move = 2, Outside = 4, Pointer1Down = 5, Pointer1Up = 6, Pointer2Down = 261, Pointer2Up = 262, Pointer3Down = 517, Pointer3Up = 518, PointerDown = 5, PointerIdMask = 65280, PointerIdShift = 8, PointerIndexMask = 65280, PointerIndexShift = 8, PointerUp = 6, Scroll = 8, Up = 1&#125; 通过判断Action的值确定当前手指执行的什么操作，如Down表示一跟手指按下，Up对应抬起手指（最后一根手指）的动作，Move移动手指，当我们有一个手指按下，继续按下一个手指时对应的动作是Pointer1Down，其中Mask用于多点触碰。 PointerCount属性用来获取触碰点的数量。DownTime表示按下开始时间，EventTime表示事件结束时间。 GetX及GetY方法用来获取触碰点的坐标，两个方法都可以传入一个int类型的pointIndex，获取多点触碰时不同点的坐标。 接下来就是通过获取的点的信息，进行一系列的计算实现想要的效果，缩放、移动等。数学问题头大，没做过多测试。 Gestures(手势)简介手势检测介绍当我们想定义一种复杂的手势操作时，通过重写OnTouchEvent肯定会增加很多的编码，Android为我们提供了GestureDetector专门用来识别手势。GestureDetector.IOnGestureListener接口监听手势的交互。GestureDetector的使用也是比较简单的，首先定义我们自己的GestureListener对象，传入GestureListener对象实例创建GestureDetector对象，重写OnTouchEvent方法，OnTouchEvent方法中调用GestureDetector对象的OnTouchEvent方法。 示例：先定义实现IOnGestureListener接口，定义GestureListener对象。 123456789101112131415161718192021222324252627282930313233343536class MyGestureListener : Java.Lang.Object, Android.Views.GestureDetector.IOnGestureListener&#123; bool GestureDetector.IOnGestureListener.OnDown (MotionEvent e) &#123; Console.WriteLine (&quot;OnDown&quot;); return false; &#125; bool GestureDetector.IOnGestureListener.OnFling (MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) &#123; Console.WriteLine (&quot;OnFling&quot;); return false; &#125; void GestureDetector.IOnGestureListener.OnLongPress (MotionEvent e) &#123; Console.WriteLine (&quot;OnLongPress&quot;); &#125; bool GestureDetector.IOnGestureListener.OnScroll (MotionEvent e1, MotionEvent e2, float distanceX, float distanceY) &#123; Console.WriteLine (&quot;OnScroll&quot;); return false; &#125; void GestureDetector.IOnGestureListener.OnShowPress (MotionEvent e) &#123; Console.WriteLine (&quot;OnShowPress&quot;); &#125; bool GestureDetector.IOnGestureListener.OnSingleTapUp (MotionEvent e) &#123; Console.WriteLine (&quot;OnSingleTapUp&quot;); return false; &#125;&#125; GestureDetector.IOnGestureListener中方法的介绍： 按下（OnDown）： 刚刚手指接触到触摸屏的那一刹那，就是触的那一下。 抛掷（OnFling）： 手指在触摸屏上迅速移动，并松开的动作。 长按（OnLongPress）： 手指按在持续一段时间，并且没有松开。 滚动（OnScroll）： 手指在触摸屏上滑动。 按住（OnShowPress）： 手指按在触摸屏上，它的时间范围在按下起效，在长按之前。 抬起（OnSingleTapUp）：手指离开触摸屏的那一刹那。 在OnCreate方法中初始化gestureDetector对象。 12myGestureListener = new MyGestureListener ();gestureDetector = new GestureDetector (this, mySimpleOnGestureListener); 重写OnTouchEvent方法。 1234public override bool OnTouchEvent (MotionEvent e)&#123; return gestureDetector.OnTouchEvent (e);&#125; 如果我们只想检测OnScroll动作，因为IOnGestureListener是接口的原因我们不得重写所有的接口方法，会编写很多无用的代码，Android系统为我们提供了GestureDetector.SimpleOnGestureListener类，对应的手势操作定义成相应的虚方法，检测单一手势时完全可以用GestureDetector.SimpleOnGestureListener代替GestureDetector.IOnGestureListener。 手势的添加与识别Android还允许我们添加自定义手势，Android提供了GestureLibrary（包含手势的删除保存等操作）手势库类和GestureOverlayView（手势绘图区）手势编辑组件。 GestureLibraries工具类提供了FromFile\\FromPrivateFile\\FromRawResource静态方法来加载手势库。取得GestureLibrary对象实例后，通过如下方法和属性对手势库进行相应的操作。 public void AddGesture (string entryName, Gesture gesture)：添加一个名为entryName的手势 public ICollection&lt; string &gt; GestureEntries ：获得手势库中所有手势的名称 public IList&lt; Gesture &gt; GetGestures (string entryName)：获得entryName名称对应的全部手势 public IList&lt; Prediction &gt; Recognize (Gesture gesture):从当前手势库中识别与gesture匹配的全部手势 public void RemoveEntry (string entryName)：删除手势库中entryName名称对应的手势 public void RemoveGesture (string entryName, Gesture gesture)：删除手势库中entryName和gesture都匹配的手势 public abstract boolean Save ()：想手势库中添加手势或从中删除手势后调用该方法保存手势库 对于GestureOverlayView 我们需要调用AddOnGesturePerformedListener方法为GestureOverlayView对象添加手势绘制完成监听并做相应的处理。 作为参考，这里指给出添加和识别手势的C#代码。因为要读些手势文件所以要添加相应的读写权限。 添加手势示例CS代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445[Activity (Label = &quot;Activity2&quot;)]public class Activity2 : Activity&#123; private GestureOverlayView gesture; protected override void OnCreate (Bundle savedInstanceState) &#123; base.OnCreate (savedInstanceState); SetContentView (Resource.Layout.Main2); gesture = FindViewById&lt;GestureOverlayView&gt; (Resource.Id.gesture); gesture.GestureColor = Color.Green; gesture.AddOnGesturePerformedListener (new MyOnGesturePerformedListener (this)); &#125;&#125;class MyOnGesturePerformedListener : Java.Lang.Object, GestureOverlayView.IOnGesturePerformedListener&#123; public MyOnGesturePerformedListener (Context context) &#123; this.context = context; &#125; private Context context; public void OnGesturePerformed (GestureOverlayView overlay, Gesture gesture) &#123; View saveDialog = LayoutInflater.From (context).Inflate (Resource.Layout.dialog_save, null, false); var imageShow = saveDialog.FindViewById&lt;ImageView&gt; (Resource.Id.img_show); var editName = saveDialog.FindViewById&lt;EditText&gt; (Resource.Id.edit_name); var bitmap = gesture.ToBitmap (128, 128, 10, Color.Green); imageShow.SetImageBitmap (bitmap); new AlertDialog.Builder (context) .SetView (saveDialog).SetPositiveButton (&quot;保存&quot;, (sender, e) =&gt; &#123; //获取文件对应的手势库 GestureLibrary gestureLib = GestureLibraries.FromFile (&quot;/mnt/sdcard/mygestures&quot;); gestureLib.AddGesture (editName.Text, gesture); gestureLib.Save (); &#125;) .SetNegativeButton (&quot;取消&quot;, (sender, e) =&gt; &#123; &#125;).Show (); &#125;&#125; 手势识别示例CS代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657[Activity (Label = &quot;Activity3&quot;, MainLauncher = true)]public class Activity3 : Activity&#123; static GestureOverlayView gesture; static GestureLibrary gestureLibrary; protected override void OnCreate (Bundle savedInstanceState) &#123; base.OnCreate (savedInstanceState); // Create your application here SetContentView (Resource.Layout.Main3); gestureLibrary = GestureLibraries.FromFile (&quot;/mnt/sdcard/mygestures&quot;); if (gestureLibrary.Load ()) &#123; Toast.MakeText (this, &quot;手势库加载成功&quot;, ToastLength.Short).Show (); &#125; else &#123; Toast.MakeText (this, &quot;手势库加载失败&quot;, ToastLength.Short).Show (); &#125; gesture = FindViewById&lt;GestureOverlayView&gt; (Resource.Id.gesture); gesture.GestureColor = Color.Green; gesture.GestureStrokeWidth = 5f; gesture.AddOnGesturePerformedListener (new My2OnGesturePerformedListener (this)); &#125; class My2OnGesturePerformedListener : Java.Lang.Object, GestureOverlayView.IOnGesturePerformedListener &#123; public My2OnGesturePerformedListener (Context context) &#123; this.context = context; &#125; private Context context; public void OnGesturePerformed (GestureOverlayView overlay, Gesture gesture) &#123; //识别用户刚绘制的手势 var predictions = gestureLibrary.Recognize (gesture); var result = new List&lt;string&gt; (); //遍历所有找到的Prediction对象 foreach (var item in predictions) &#123; if (item.Score &gt; 2.0) &#123; result.Add (&quot;与手势[&quot; + item.Name + &quot;]相似度为&quot; + item.Score); &#125; &#125; if (result.Count &gt; 0) &#123; ArrayAdapter&lt;string&gt; adapter = new ArrayAdapter&lt;string&gt; (context, Android.Resource.Layout.SimpleDropDownItem1Line, result); new AlertDialog.Builder (context).SetAdapter (adapter, (sender, e) =&gt; &#123; &#125;).SetPositiveButton (&quot;确定&quot;, (sender, e) =&gt; &#123; &#125;).Show (); &#125; else &#123; Toast.MakeText (context, &quot;无法找到匹配的手势！&quot;, ToastLength.Short).Show (); &#125; &#125; &#125;&#125;","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Gesture","slug":"Gesture","permalink":"http://xamarin.xyz/tags/Gesture/"}]},{"title":"Xamarin.Android 自定义控件","slug":"custom-view","date":"2016-05-26T08:28:13.000Z","updated":"2017-11-02T15:14:07.000Z","comments":true,"path":"2016/05/26/custom-view/","link":"","permalink":"http://xamarin.xyz/2016/05/26/custom-view/","excerpt":"Android的UI是基于View（widgets）和ViewGroup（layouts），android为我们提供了很多控件用来创建UI界面，但有时我们要通过自定义View实现想要的效果。创建一个自定义View，一般是继承View和ViewGroup及其子类，重写一些方法实现我们想要的效果或逻辑,如OnDraw，OnMeasure，OnLayout，OnTouchEvent等方法。 主要通过以下五个方面创建一个自定义View： 绘图，通过重写OnDraw方法控制View的渲染效果 交互，重写OnTouchEvent方法实现与用户的交互 测量，重写OnMeasure测量控件显示位置 属性，attrs.xml中自定义控件的属性，通过TypedArray读取属性 保存状态，避免配置改变时丢失View的状态，重写OnSaveInstanceState和OnRestoreInstanceState方法保存、恢复状态","text":"Android的UI是基于View（widgets）和ViewGroup（layouts），android为我们提供了很多控件用来创建UI界面，但有时我们要通过自定义View实现想要的效果。创建一个自定义View，一般是继承View和ViewGroup及其子类，重写一些方法实现我们想要的效果或逻辑,如OnDraw，OnMeasure，OnLayout，OnTouchEvent等方法。 主要通过以下五个方面创建一个自定义View： 绘图，通过重写OnDraw方法控制View的渲染效果 交互，重写OnTouchEvent方法实现与用户的交互 测量，重写OnMeasure测量控件显示位置 属性，attrs.xml中自定义控件的属性，通过TypedArray读取属性 保存状态，避免配置改变时丢失View的状态，重写OnSaveInstanceState和OnRestoreInstanceState方法保存、恢复状态 接下来通过一个例子详细的介绍一下如何自定义View，实现一个图片➕文字说明的控件。自定义一个TitleImageView继承View，重写3个构造函数，布局定义View是调用的两个参数的构造函数，这里我们实现所有构造函数都调用三个参数的构造函数，在三个参数的构造函数中获取自定义属性。 初步代码如下： 1234567891011121314151617class TitleImageView:View&#123; public TitleImageView (Context context) : this (context, null) &#123; &#125; public TitleImageView (Context context, IAttributeSet attrs) : this (context, attrs, 0) &#123; &#125; public TitleImageView (Context context, IAttributeSet attrs, int defStyle) : base (context, attrs, defStyle) &#123; &#125;&#125; 一个良好的自定义控件应该能通过xml控制属性。自定义View的属性，在Resources／values下新建attrs.xml文件，在attrs中定义属性和声明样式。确定我们能在xml中定义的属性，然后写如下定义： 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;resources&gt; &lt;attr name=\"titleText\" format=\"string\" /&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"titleTextColor\" format=\"color\" /&gt; &lt;attr name=\"image\" format=\"reference\" /&gt; &lt;attr name=\"imageScaleType\"&gt; &lt;enum name=\"fillXY\" value=\"0\" /&gt; &lt;enum name=\"center\" value=\"1\" /&gt; &lt;/attr&gt; &lt;declare-styleable name=\"TitleImageView\"&gt; &lt;attr name=\"titleText\" /&gt; &lt;attr name=\"titleTextSize\" /&gt; &lt;attr name=\"titleTextColor\" /&gt; &lt;attr name=\"image\" /&gt; &lt;attr name=\"imageScaleType\" /&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 也可以有另外一种写法： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"TitleImageView\"&gt; &lt;attr name=\"titleText\" format=\"string\" /&gt; &lt;attr name=\"titleTextSize\" format=\"dimension\" /&gt; &lt;attr name=\"titleTextColor\" format=\"color\" /&gt; &lt;attr name=\"image\" format=\"reference\" /&gt; &lt;attr name=\"imageScaleType\"&gt; &lt;enum name=\"fillXY\" value=\"0\" /&gt; &lt;enum name=\"center\" value=\"1\" /&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 定义了自定义属性，我们就可以在xml中进行使用，不同的是我们自定义属性的命名空间是不同的，我们需要在布局的根节点或自定义View中加上定义命名空间才能使用自定义属性。 format是指该属性的取值类型:一共有：string,color,demension,integer,enum,reference,float,boolean,fraction,flag;具体介绍参考：http://www.jb51.net/article/40069.htm 接下来完善TitleImageView三个参数的构造函数，在构造函数中借助TypedArray类提取我们定义的属性，并编写类属性可以通过代码设置View属性。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class TitleImageView:View&#123; private Bitmap image; private ImageScale imageScaleType; private string titleText; private Color titleTextColor; private int titleTextSize; public Bitmap Image &#123; get &#123; return image; &#125; set &#123; image = value; Invalidate (); RequestLayout (); &#125; &#125; public ImageScale ImageScaleType &#123; get &#123; return imageScaleType; &#125; set &#123; imageScaleType = value; Invalidate (); &#125; &#125; public string TitleText &#123; get&#123; return titleText; &#125; set&#123; titleText = value; Invalidate (); RequestLayout (); &#125; &#125; public Color TitleTextColor &#123; get &#123; return titleTextColor; &#125; set &#123; titleTextColor = value; Invalidate (); &#125; &#125; public int TitleTextSize &#123; get&#123; return titleTextSize; &#125; set&#123; titleTextSize = value; Invalidate (); RequestLayout (); &#125; &#125; public enum ImageScale &#123; FillXY, Center &#125; public TitleImageView (Context context) : this (context, null) &#123; &#125; public TitleImageView (Context context, IAttributeSet attrs) : this (context, attrs, 0) &#123; &#125; public TitleImageView (Context context, IAttributeSet attrs, int defStyle) : base (context, attrs, defStyle) &#123; TypedArray typedArray = Context.Theme.ObtainStyledAttributes (attrs, Resource.Styleable.TitleImageView, defStyle, 0); int count = typedArray.IndexCount; try &#123; for (int i = 0; i &lt; count; i++) &#123; int index = typedArray.GetIndex (i); switch (index) &#123; case Resource.Styleable.TitleImageView_image: image = BitmapFactory.DecodeResource (Resources, typedArray.GetResourceId (index, 0)); break; case Resource.Styleable.TitleImageView_imageScaleType: imageScaleType = (ImageScale)typedArray.GetInt (index, 0); break; case Resource.Styleable.TitleImageView_titleText: titleText = typedArray.GetString (index); break; case Resource.Styleable.TitleImageView_titleTextColor: titleTextColor = typedArray.GetColor (index, Color.Black); break; case Resource.Styleable.TitleImageView_titleTextSize: //获取尺寸三个方法的介绍：http://my.oschina.net/ldhy/blog/496420 titleTextSize = typedArray.GetDimensionPixelSize (index, (int)TypedValue.ApplyDimension (ComplexUnitType.Sp, 16, Resources.DisplayMetrics)); break; default: break; &#125; &#125; &#125; catch (System.Exception ex) &#123; throw ex; &#125; finally &#123; typedArray.Recycle (); &#125; &#125;&#125; 代码中View的属性发生改变时我们需要进行重绘和重新布局。所以在属性赋值时调用了Invalidate(重新绘制OnDraw)和RequestLayout（重新布局OnLayout）方法. 重写OnMeasure方法，按照用户定义的宽度高度进行绘制，View会先做一次测量，计算出自己占用多大的面积。 123456789101112131415protected override void OnMeasure (int widthMeasureSpec, int heightMeasureSpec)&#123; base.OnMeasure (widthMeasureSpec, heightMeasureSpec); //计算宽度 以图片宽度作控件宽度 int minWidth = PaddingLeft + PaddingRight + image.Width; var width = ResolveSizeAndState (minWidth, widthMeasureSpec, 0); //计算高度 int minHeight = PaddingBottom + PaddingTop + image.Height + textBound.Height (); var height = ResolveSizeAndState (minHeight, heightMeasureSpec, 0); // 测量完成后必须调用setMeasuredDimension方法 SetMeasuredDimension (width, height);&#125; MeasureSpec代表了一组宽度和高度的要求。一个MeasureSpec由大小和模式组成。它有三种模式：UNSPECIFIED(未指定),父元素部队自元素施加任何束缚，子元素可以得到任意想要的大小；EXACTLY(完全)，父元素决定自元素的确切大小(设置了明确的值或者是MATCH_PARENT),子元素将被限定在给定的边界里而忽略它本身大小；AT_MOST(至多)，子元素至多达到指定大小的值(WARP_CONTENT)。 ResolveSizeAndState方法返回一个合适的尺寸，只要将测量模式和我们计算的宽度高度传进去即可,该方法在新的api中才有，无法兼容3.0以下,我们可以根据源码定义自己的ResolveSizeAndState方法： 123456789101112131415161718192021private int ResolveSizeAndState(int size, int measureSpec, int childMeasuredState) &#123; int result = size; int specMode = MeasureSpec.GetMode(measureSpec); int specSize = MeasureSpec.GetSize(measureSpec); switch (specMode) &#123; case MeasureSpecMode.Unspecified: result = size; break; case MeasureSpecMode.AtMost: if (specSize &lt; size) &#123; result = specSize | View.MeasuredStateTooSmall; &#125; else &#123; result = size; &#125; break; case MeasureSpecMode.Exactly: result = specSize; break; &#125; return result | (childMeasuredState&amp;View.MeasuredStateMask);&#125; 在构造函数中初始化一个Paint和两个Rect。 1234567rect = new Rect (); //图片位置paint = new Paint ();paint.TextSize = TitleTextSize;paint.Color = titleTextColor;textBound = new Rect ();//底部说明文字位置 // 计算了描绘字体需要的范围 paint.GetTextBounds (titleText, 0, titleText.Length, textBound); 重写OnDraw方法，根据定义的属性绘制图形。在参数canvas上绘制我们希望的View样式。 123456789101112131415161718192021222324252627282930313233343536protected override void OnDraw (Canvas canvas)&#123; base.OnDraw (canvas); rect.Left = PaddingLeft; rect.Right = Width - PaddingRight; rect.Top = PaddingTop; rect.Bottom = Height - PaddingBottom; paint.TextSize = TitleTextSize; paint.Color = titleTextColor; paint.SetStyle (Paint.Style.Fill); //当前设置的宽度小于字体需要的宽度，将字体改为xxx... if (textBound.Width () &gt; Width) &#123; TextPaint paint = new TextPaint (this.paint); string msg = TextUtils.Ellipsize (titleText, paint, (float)Width - PaddingLeft - PaddingRight, TextUtils.TruncateAt.End); canvas.DrawText (msg, PaddingLeft, Height - PaddingBottom, paint); &#125; else &#123; canvas.DrawText (titleText, Width / 2 - textBound.Width () / 2, Height - PaddingBottom, paint); &#125; //取消使用掉的部分 rect.Bottom -= textBound.Height (); if (imageScaleType == ImageScale.FillXY) &#123; canvas.DrawBitmap (image, null, rect, paint); &#125; else &#123; rect.Left = Width / 2 - image.Width / 2; rect.Right = Width / 2 + image.Width / 2; rect.Top = (Height - textBound.Height ()) / 2 - image.Height / 2; rect.Bottom = (Height - textBound.Height ()) / 2 + image.Height / 2; canvas.DrawBitmap (image, null, rect, paint); &#125;&#125; 这个控件中我们不需要与用户交互，所以忽略OnTouchEvent方法，没有要保存的状态信息，也不需要重写OnSaveInstanceState和OnRestoreInstanceState方法。本文只是简单的介绍一下如何自定义控件，复杂实现要通过日后实际项目学习，不做记录。而OnLayout方法通常是自定义ViewGroup时，排列子View重写。 在布局文件中定义我们的控件（通过代码定义未测试）： 1234567891011&lt;view.TitleImageView xmlns:myue=\"http://schemas.android.com/apk/res/com.myue.view\" android:layout_width=\"100dp\" android:layout_height=\"200dp\" android:layout_margin=\"10dp\" android:padding=\"10dp\" myue:image=\"@mipmap/icon\" myue:imageScaleType=\"fillXY\" myue:titleText=\"hello andorid ! \" myue:titleTextColor=\"#ff0000\" myue:titleTextSize=\"30sp\" /&gt; 要做几下几点说明： view.TitleImageView 为自定义控件的全局限定名 要定义控件的命名空间，这里直接定义到View上，也可以提取到根布局上 命名空间xmlns:myue=”http://schemas.android.com/apk/res/com.myue.view“ 中/res/之后的部分为包名，如果自定义控件不在当前项目，com.myue.view不是当前项目包名，而是控件所在项目包名。 运行效果图：","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"View","slug":"View","permalink":"http://xamarin.xyz/tags/View/"}]},{"title":"Xamarin.Android 特殊Fragment讲解","slug":"special-fragment","date":"2016-05-24T06:07:55.000Z","updated":"2017-11-02T15:21:28.000Z","comments":true,"path":"2016/05/24/special-fragment/","link":"","permalink":"http://xamarin.xyz/2016/05/24/special-fragment/","excerpt":"前面介绍过Fragment的出现就是为了更好的适配手机屏幕和大屏幕的Android设备。与Activity一样，Android同样为我们提供了一些特殊的Fragment简化我们的编码。本文主要介绍以下三个Fragment子类的使用：ListFragment，DialogFragment，PreferenceFragment。","text":"前面介绍过Fragment的出现就是为了更好的适配手机屏幕和大屏幕的Android设备。与Activity一样，Android同样为我们提供了一些特殊的Fragment简化我们的编码。本文主要介绍以下三个Fragment子类的使用：ListFragment，DialogFragment，PreferenceFragment。 ListFragment使用简介ListFragment与ListActivity相似，提供了默认包含一个List的视图，在使用ListFragment时可以不重写OnCreateView方法。如果要自定义ListFragment显示的视图，一定要在布局文件中包含一个id为“@android:id/list”的ListView。 先自定义我们的ListFragment。使用默认视图忽略OnCreateView方法，重写OnCreate或OnActivityCreated方法，初始化ListFragment.ListAdapter的属性（默认ListView的适配器）。 123456789public override void OnCreate (Bundle savedInstanceState)&#123; base.OnCreate (savedInstanceState); string[] values = new[] &#123; &quot;Android&quot;, &quot;iPhone&quot;, &quot;WindowsMobile&quot;, &quot;Blackberry&quot;, &quot;WebOS&quot;, &quot;Ubuntu&quot;, &quot;Windows7&quot;, &quot;Max OS X&quot;, &quot;Linux&quot;, &quot;OS/2&quot; &#125;; this.ListAdapter = new ArrayAdapter&lt;string&gt; (Activity, Android.Resource.Layout.SimpleExpandableListItem1, values); &#125; 处理ListView的点击事件，需要重写OnListItemClick方法。 12345public override void OnListItemClick (ListView l, Android.Views.View v, int position, long id)&#123; base.OnListItemClick (l, v, position, id); //事件响应代码&#125; DialogFragment使用简介DialogFragment在android 3.0时被引入。用于在Activity的内容之上展示一个模态的对话框。在DialogFragment产生之前，我们创建对话框：一般采用AlertDialog或Dialog（不推荐直接使用Dialog创建对话框）。DialogFragment创建对话框的好处就是时Dialog与Fragment生命周期一致，且可以把Dialog内嵌到DialogFragment中使用。 DialogFragment为我们提供了Show方法显示Fragment，调用Dismiss隐藏Fragment。我们一个可以显示一个其它的DialogFragment从而隐藏当前显示的DialogFragment。 使用DialogFragment至少需要实现OnCreateView或OnCreateDIalog方法。OnCreateView使用定义的xml布局文件展示Dialog。OnCreateDialog使用AlertDialog创建Dialog。 先定义AlertDialogFragment重写OnCreateDialog方法,通过AlertDialog.Builder创建Dialog。在按钮点击时显示MyDialogFragment，Show方法的第一参数为FragmentTransaction对象，第二个参数为字符串类型的tag(Fragment的字符串标识)。 123456789101112131415public class AlertDialogFragment : DialogFragment&#123; public override Dialog OnCreateDialog (Bundle savedInstanceState) &#123; var builder = new AlertDialog.Builder (Activity) .SetMessage (&quot;This is my dialog.&quot;) .SetPositiveButton (&quot;Ok&quot;, (sender, args) =&gt; &#123; //显示MyDialogFragment var transaction = FragmentManager.BeginTransaction (); var dialogFragment = new MyDialogFragment (); dialogFragment.Show (transaction, &quot;dialog_fragment_view&quot;); &#125;).SetTitle (&quot;Custom Dialog&quot;); return builder.Create (); &#125;&#125; 自定义MyDialogFragment,重写OnCreateView方法，返回我们自定义的View。 Dialog.RequestWindowFeature ((int)Android.Views.WindowFeatures.NoTitle);隐藏顶部Title 12345678910111213public class MyDialogFragment : DialogFragment&#123; public override Android.Views.View OnCreateView (Android.Views.LayoutInflater inflater, Android.Views.ViewGroup container, Bundle savedInstanceState) &#123; base.OnCreateView (inflater, container, savedInstanceState); Dialog.RequestWindowFeature ((int)Android.Views.WindowFeatures.NoTitle); var view = inflater.Inflate (Resource.Layout.fragment_dialog, container, false); return view; &#125; &#125; 当AlertDialogFragment中的按钮点击时，MyDialogFragment被创建并显示，没有调用Dismiss方法的情况下AlertDialogFragment自动隐藏，而MyDialogFragment的隐藏则需要我们通过Dismiss方法隐藏。 PreferenceFragment 使用简介PreferenceFragment与PreferenceActivity类似，可以帮我们配置一些信息，保存应用设置可以使用。应用内实现类似系统设置的效果： 使用PreferenceFragment不是把layout布局文件作为填充界面而是在xml（resource／xml）文件夹中创建一个xml资源文件编写相应的preference节点,这些设置不需要我们自己保存用户设置的数据，它自己会将数据保存在xml文件当中，自动创建一个配置文件/data/data/your_package_name /shared_prefs/(your_package_name)_preferences.xml。 官网中给出的示例代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;PreferenceScreen xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;PreferenceCategory android:title=\"Inline Preferences\"&gt; &lt;CheckBoxPreference android:key=\"checkbox_preference\" android:title=\"Checkbox Preference Title\" android:summary=\"Checkbox Preference Summary\" /&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"Dialog Based Preferences\"&gt; &lt;EditTextPreference android:key=\"edittext_preference\" android:title=\"EditText Preference Title\" android:summary=\"EditText Preference Summary\" android:dialogTitle=\"Edit Text Preferrence Dialog Title\" /&gt; &lt;/PreferenceCategory&gt; &lt;PreferenceCategory android:title=\"Launch Preferences\"&gt; &lt;!-- This PreferenceScreen tag serves as a screen break (similar to page break in word processing). Like for other preference types, we assign a key here so it is able to save and restore its instance state. --&gt; &lt;PreferenceScreen android:key=\"screen_preference\" android:title=\"Title Screen Preferences\" android:summary=\"Summary Screen Preferences\"&gt; &lt;!-- You can place more preferences here that will be shown on the next screen. --&gt; &lt;CheckBoxPreference android:key=\"next_screen_checkbox_preference\" android:title=\"Next Screen Toggle Preference Title\" android:summary=\"Next Screen Toggle Preference Summary\" /&gt; &lt;/PreferenceScreen&gt; &lt;PreferenceScreen android:title=\"Intent Preference Title\" android:summary=\"Intent Preference Summary\"&gt; &lt;intent android:action=\"android.intent.action.VIEW\" android:data=\"http://www.android.com\" /&gt; &lt;/PreferenceScreen&gt; &lt;/PreferenceCategory&gt;&lt;/PreferenceScreen&gt; 在PreferenceFragment 的OnCreate方法中调用AddPreferencesFromResource ()方法填充界面. Preference节点介绍 PreferenceScreen：用作xml的根元素。用它可嵌套形成二级设置页面，还可以Intent启动指定的activity。 PreferenceCategory：用于分组，它可以将几个 模块 组合在一起，然后 可用Title参数 设置个大标题，相当于一个分界线的东西一样，它的上面和下面分别属于不同类型的设置。 CheckBoxPreference：是一个CheckBox设置，值的类型是布尔值：true或false。summaryOn和summaryOff参数来设置控件选中和未选中时的提示。defaultValue=”true” 第一次使用是选中。 ListPreference：列表选择，弹出对话框供选择。dialogTitle设置下拉框的标题。defaultValue=“0” //注意，0 默认 选中 第一项，1 默认 选中 第二项，以此类推，defaultValue 的值是 字符型。entries 和 entryValues分别表示 显示的值 和 代码中获取的真正的值，他们一定要是 字符数组。下拉框内显示的内容和具体的值需要在res/values/array.xml中设置两个array来表示。 EditTextPreference：输入框控件，点击后 弹出一个输入框，值为String类型。dialogTitle参数 设置输入框的标题。 RingtonePreference：弹出铃声选择框，点击后可选择 系统铃声。dialogTitle参数设置铃声选择框的标题，值的类型是string。 Preference：只是单一的显示文本信息，不能够嵌套显示二级界面； Preference属性介绍 android:key —— 对应节点的键，保存读取数据的key。 android:title —— 显示标题 android:summary —— 显示的摘要说明 android:entries —— 将选项设置成列表项的文本 android:entryValues —— 定义每个列表项的值 android:dialogTitle —— 对话框的标题 android:defaultValue —— 项列表中选项的默认值 android:persistent —— 是否将preference存储到shared preferences中 dependency：标识此元素附属于某一个元素（通常为CheckBoxPreference)，dependency值为所附属元素的key。当CheckPreference被选中时，Preference则为可用，否则为不可用。 Preferenece数据的操作在当前PreferenceFragment中读取数据可以使用：PreferenceScreen.SharedPreferences.GetXXX方法。 在其它的Activity中通过PreferenceManager.GetDefaultSharedPreferences (this).GetXXX方法读取存储的配置信息。 如果需要清除数据，可以通过PreferenceScreen.RemovePreference清除某个prefernece，PreferenceScreen.RemoveAll清除所有的preferences。我们可以通过PreferenceScreen.Editor属性获取preferences的editor进行编辑，修改后通过Commit()将修改值保存。 Querying Activities to Create a Preference Fragmenthttps://developer.xamarin.com/guides/android/platform_features/fragments/part_3_-_specialized_fragment_classes/#Querying_Activities_to_Create_a_Preference_Fragment","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"http://xamarin.xyz/tags/Fragment/"}]},{"title":"Xamarin.Android Fragment 使用详解","slug":"fragment","date":"2016-05-20T02:17:52.000Z","updated":"2017-11-02T15:15:12.000Z","comments":true,"path":"2016/05/20/fragment/","link":"","permalink":"http://xamarin.xyz/2016/05/20/fragment/","excerpt":"Fragment的出现是为了解决一个App无法同时使用手机和平板而出现的，可以把Fragment当成Activity中的模块，一个Fragment必须嵌入到Activity中，它有自己的布局和生命周期且生命周期受Activity的生命周期影响。虽然Fragment有自己独立的生命周期，但是与之关联的Activity的生命周期会直接影响到Fragment的什么周期。例如Activity进入Pause状态，Fragment同样会回调OnPause方法。","text":"Fragment的出现是为了解决一个App无法同时使用手机和平板而出现的，可以把Fragment当成Activity中的模块，一个Fragment必须嵌入到Activity中，它有自己的布局和生命周期且生命周期受Activity的生命周期影响。虽然Fragment有自己独立的生命周期，但是与之关联的Activity的生命周期会直接影响到Fragment的什么周期。例如Activity进入Pause状态，Fragment同样会回调OnPause方法。 用一张图描述Fragment的生命周期： 这里只介绍Fragment比Activity额外多的生命周期回调方法。 OnAttach()当Fragment与Activity发生关联时调用，是Fragment生命周期中第一回调的方法，一些初始化操作应该在这个方法中实现。 OnCreateView()在OnCreate()方法执行完回调，创建Fragment的视图，返回Fragment的布局View。一些UI操作应该在这个方法中实现而不是OnCreate方法。 OnActivityCreated()当Activity的OnCreate执行完成时掉用该方法，如果与Activity中的UI有交互应该在这个方法中实现。 OnDestroyView()Fragment中的布局被移除时掉用，清除Fragment中视图相关资源。 OnDetach()Fragment与Activity解除关联时调用。Fragment不再使用，所有相关资源都应该释放。 这里要对绿色虚线生命周期进行说明，例如旋转屏幕Activity会重新创建，我们可以在Fragment的OnCreate方法中设置RetainInstance = true,使Fragment不会彻底被销毁，提高运行效率。当Fragment恢复时会跳过OnCreate()和OnDestroy()方法，因此不能在onCreate()中放置一些初始化逻辑. Fragment 使用首先自定义一个Fragment。通过NewInstance方法获取Fragment实例，参考Android Studio生成的模版代码。 123456789101112131415161718192021222324252627282930public class MyFragment : Fragment &#123; public override void OnCreate (Bundle savedInstanceState) &#123; base.OnCreate (savedInstanceState); &#125; /// &lt;summary&gt; /// Returns a new instance of this fragment for the given section number. /// &lt;/summary&gt; /// &lt;returns&gt;The instance.&lt;/returns&gt; /// &lt;param name=&quot;sectionNumber&quot;&gt;Section number.&lt;/param&gt; public static MyFragment NewInstance (int sectionNumber) &#123; MyFragment fragment = new MyFragment (); Bundle args = new Bundle (); args.PutInt (&quot;section_number&quot;, sectionNumber); fragment.Arguments = args; return fragment; &#125; public override View OnCreateView (LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View rootView = inflater.Inflate (Resource.Layout.MyFragment, container, false); return rootView; &#125; &#125; Fragment必须要实现没有参数的构造函数（Fragment sub-classes must have a public default no argument constructor.） 定义好的Fragment有两种使用方式，（静态）Declaratively和动态（Programmatically）。静态使用是在.axml布局文件中增加一个标签，引用自定义的Fagment。动态使用是代码方式通过FragmentManager管理Fragment。 静态使用Fragment添加Fragment标签引用Fragment，可以通过android:name 属性或class属性指定.使用示例： 1234&lt;fragment android:name=\"com.myue.fragment.MyFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 对于android:name 属性或class属性的设置，我们可以有两种设置方式，一种是com.myue.fragment（包名）.MyFragment，另一种是fragment（命名控件）.MyFragment。 尝试运行项目，抛出异常：Binary XML file line #1: Error inflating class fragment。 查看堆栈输出信息：Must specify unique android:id, android:tag, or have a parent with an id for com.myue.fragment.MyFragment。 Fragment使用时必须指定一个唯一标识符，可以是android:id 也可以是android:tag。完善我们的代码： 12345&lt;fragment android:id=\"@+id/fragment\" android:name=\"com.myue.fragment.MyFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 运行项目正常。 如果没有为Fragment指定id和tag中的一种，可以为Fragment所在的元素添加一个id，如下 123456789101112&gt; &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:id=\"@+id/fragment_container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;fragment android:name=\"com.myue.fragment.MyFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt;&lt;/LinearLayout&gt;&gt; 动态使用Fragment动态使用Fragment要在布局文件中添加一个FrameLayout，并在代码中通过FragmentManager增加、更新、删除Fragment。 修改布局文件替换fragment节点为： 1234&lt;FrameLayout android:id=\"@+id/fragmentcontent\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 在Activity 中通过FragmentManager属性获取FragmentManager实例。 如果使用Android3.0以下的版本，需要引入v4的包，然后Activity继承FragmentActivity，然后通过SupportFragmentManager属性获得FragmentManager。 在Activity的OnCreate方法中增加如下代码： 123var transaction = FragmentManager.BeginTransaction (); transaction.Add (Resource.Id.fragmentcontent, MyFragment.NewInstance (0)); transaction.Commit (); 通过FragmentManager.BeginTransaction方法获取到BeginTransaction对象，通过BeginTransaction对象完成Fragment的替换、增加、删除操作，最后调用Commit方法完成操作。Activity保存State信息同时会保存Fragment的信息，所以Commit方法必须在Activity.OnSaveInstanceState()之前调用否为灰抛出异常。 Fragment常用的三个类：Fragment 主要用于定义FragmentFragmentManager 主要用于在Activity中操作FragmentFragmentTransaction 保证一些列Fragment操作的一致性 当我们调用FragmentTransaction的Add或Replace方法时前一个Fragment对象会被销毁。在Activity的管理中提到了会退栈（back stack），同样Fragment也可以放在一个回退栈中进行管理。添加一个Fragment事务到回退栈FragmentTransaction.AddToBackStack(string)。由于当前的事务添加到了回退栈，此时调用FragmentTransaction的Add或Replace方法，前一个Fragment实例不会被销毁，Replace方法使视图层次依然会被销毁，即会调用onDestoryView和onCreateView，而Add方法会避免视图重绘。 示例代码： 123456789101112// Create a new fragment and a transaction.FragmentTransaction fragmentTx = this.FragmentManager.BeginTransaction();DetailsFragment aDifferentDetailsFrag = new DetailsFragment();// Replace the fragment that is in the View fragment_container (if applicable).fragmentTx.Replace(Resource.Id.fragment_container, aDifferentDetailsFrag);// Add the transaction to the back stack.fragmentTx.AddToBackStack(null);// Commit the transaction.fragmentTx.Commit(); Fragment与Activity通信在Activity中通过FragmentManager 的FindFragmentById或FindFragmentByTag方法获取指定的Fragment对象，在Activity中调用Fragment的public方法。在Fragment中可以通过Activity属性获取当前与Fragment关联的Activity。实际编码时为了降低Fragment与Activity的耦合，Fragment不应该直接操作其它Fragment，可以借助delegate或Listener 实现Fragment与Activity之间的通信。 Fragment状态管理同Activity一样，我们一样可以重写Fragment的OnSaveInstanceState方法管理Fragment的状态，使用方式同Activity。在Fragment的生命周期中OnCreate、OnCreateView和OnActivityCreated都会传入我们OnSaveInstanceState中保存数据的Bundle对象。获取保存的数据之前要判断savedInstanceState是否为null，如果为null，说明没有保存过数据。对于指定了ID的控件，Fragment同样会自动保存相关数据。 Fragment增加菜单重写OnCreateOptionsMenu方法，为Fragment创建菜单。 12345public override void OnCreateOptionsMenu (IMenu menu, MenuInflater menuInflater)&#123; menuInflater.Inflate (Resource.Menu.menu_fragment, menu); base.OnCreateOptionsMenu (menu, menuInflater);&#125; menu_fragment的布局如下： 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/add_vehicle\" android:icon=\"@drawable/ic_menu_add_data\" android:title=\"@string/add_vehicle\" /&gt;&lt;/menu&gt; 在Fragment的OnCreate方法中调用SetHasOptionsMenu(true)；方法，告诉Android系统我们的Fragment有提供Menu，Fragment添加的菜单与Activity中添加的菜单会共同显示，Fragment中处理菜单的点击操作，需要重写Fragment的OnOptionsItemSelected方法。对菜单点击的处理会先进入Activity的OnMenuItemSelected方法，再进入Fragment的OnOptionsItemSelected方法，如果OnMenuItemSelected返回为false，Fragment不会再处理菜单的点击。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Fragment","slug":"Fragment","permalink":"http://xamarin.xyz/tags/Fragment/"}]},{"title":"Xamarin.Android Intent简介","slug":"intent","date":"2016-05-18T15:35:07.000Z","updated":"2017-11-02T15:16:11.000Z","comments":true,"path":"2016/05/18/intent/","link":"","permalink":"http://xamarin.xyz/2016/05/18/intent/","excerpt":"前面的四大组件介绍中有频繁的用到Intent，Activity、Service和BroadcastReceiver都有使用到Intent，Intent（意图）主要是解决Android应用的各项组件之间的通讯。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。实际使用中Intent有显式和隐式两种，显式Intent通过组件名启动目标组件，也是实际使用中最常用到的。隐式Intent不指定组件名而是指定Intent的Action，Category和Data等，启动组件时，根据我们AndroidManifest.xml中注册intent—filter匹配出满足属性的组件，如果有多个组件满足条件会弹出选择框。","text":"前面的四大组件介绍中有频繁的用到Intent，Activity、Service和BroadcastReceiver都有使用到Intent，Intent（意图）主要是解决Android应用的各项组件之间的通讯。Intent负责对应用中一次操作的动作、动作涉及数据、附加数据进行描述，Android则根据此Intent的描述，负责找到对应的组件，将 Intent传递给调用的组件，并完成组件的调用。实际使用中Intent有显式和隐式两种，显式Intent通过组件名启动目标组件，也是实际使用中最常用到的。隐式Intent不指定组件名而是指定Intent的Action，Category和Data等，启动组件时，根据我们AndroidManifest.xml中注册intent—filter匹配出满足属性的组件，如果有多个组件满足条件会弹出选择框。 例如通过如下代码，隐式方式从应用程序返回Home页： 1234Intent intent = new Intent ();intent.SetAction (Intent.ActionMain);intent.AddCategory (Intent.CategoryHome);StartActivity (intent); 如果组件没有intent过滤器，它仅仅可以接收显式的intent。含有过滤器的组件既可以接收隐式intent也可以接收显式intent。通过扩展和标志不可以确定那个组件接收intent. 具体使用请参考：http://www.xamarin.xyz/2016/04/28/activity1/ Intent属性介绍ComponentName(组件名称)目标组件名称，显示启动Intent必须指定，由应用程序包名➕组件类名组成。 组件的名字通过Intent的SetComponent()、SetClass()、SetClassName()方法设置，通过Component属性读取。 Action(动作)一个普通的字符串，代表Intent要执行的动作的名字，一个Intent只能有一个Action。当我们自定义Action时需要把包名作为前缀（推荐）。 Intent里的动作是通过 SetAction()方法设置，通过Action属性读取。 Category(类别)包含附加信息的字符串，信息是需要处理intent的组件的类型。一个Intent可能有多个Category。 AddCategory方法为intent添加一个类别，RemoveCategory方法删除之前添加的，Categories属性获取当前所有的类别。 Data(数据)和Type(MIME类型)Data用于指定Action要操作的数据，接受一个URI对象。Type用于指定URI对应的MIME类型，组件能显示图形数据却不能用来播放音频文件，我们可以自定义MIME类型，只要是符合abc/xyz的格式的字符串即可。SetData() 方法指定数据作为一个URI， SetType()指定一个MIME类型，SetDataAndType()同时指定URI和MIME类型。 Data属性函数读取URI， Type属性读取类型。 Extras(额外)附加键值对信息，用于组件之间传递数据.Extras属性是Bundle对象，更多传递数据知识参考http://www.xamarin.xyz/2016/04/29/activity2/ 通过PutExtra方法插入数据，通过GetXXXExtra方法获取数据。Bundle对象要通过Extras属性获取。 Flags(标记)指示Android如何启动Activity（例如：Activity属于那个任务）启动后如何处理（例如：是否属于现在Activity 的列表）,具体参考http://www.xamarin.xyz/2016/05/02/activity3/中介绍。 AddFlags方法设置，Flags属性读取。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Intent","slug":"Intent","permalink":"http://xamarin.xyz/tags/Intent/"}]},{"title":"Xamarin.Android 自定义ContentProvider","slug":"contentprovider2","date":"2016-05-16T04:49:14.000Z","updated":"2017-11-02T15:12:51.000Z","comments":true,"path":"2016/05/16/contentprovider2/","link":"","permalink":"http://xamarin.xyz/2016/05/16/contentprovider2/","excerpt":"前面介绍了如何使用系统提供的ContentProvider。虽然很多时候我们不需要定义自己的ContentProvider提供数据给其他应用程序使用，但是仍要掌握这个能力，能够自定义ContentProvider。本文主要内容为VegetableProvider类的实现及对于VegetableProvider的代码介绍，涉及SQLite的操作可选择性跳过阅读。 这里我们先定义一个DBHelper，创建数据库并初始化数据作为ContentProvider的数据源。涉及到Android中SQLite数据库操作","text":"前面介绍了如何使用系统提供的ContentProvider。虽然很多时候我们不需要定义自己的ContentProvider提供数据给其他应用程序使用，但是仍要掌握这个能力，能够自定义ContentProvider。本文主要内容为VegetableProvider类的实现及对于VegetableProvider的代码介绍，涉及SQLite的操作可选择性跳过阅读。 这里我们先定义一个DBHelper，创建数据库并初始化数据作为ContentProvider的数据源。涉及到Android中SQLite数据库操作 12345678910111213141516171819202122232425262728class VegetableDatabase : SQLiteOpenHelper &#123; const string create_table_sql = &quot;CREATE TABLE [vegetables] ([_id] INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL UNIQUE, [name] TEXT NOT NULL UNIQUE)&quot;; const string DatabaseName = &quot;vegetables.db&quot;; const int DatabaseVersion = 1; public VegetableDatabase (Context context) : base (context, DatabaseName, null, DatabaseVersion) &#123; &#125; public override void OnCreate (SQLiteDatabase db) &#123; db.ExecSQL (create_table_sql); // seed with data db.ExecSQL (&quot;INSERT INTO vegetables (name) VALUES (&apos;Vegetables&apos;)&quot;); db.ExecSQL (&quot;INSERT INTO vegetables (name) VALUES (&apos;Fruits&apos;)&quot;); db.ExecSQL (&quot;INSERT INTO vegetables (name) VALUES (&apos;Flower Buds&apos;)&quot;); db.ExecSQL (&quot;INSERT INTO vegetables (name) VALUES (&apos;Legumes&apos;)&quot;); db.ExecSQL (&quot;INSERT INTO vegetables (name) VALUES (&apos;Bulbs&apos;)&quot;); db.ExecSQL (&quot;INSERT INTO vegetables (name) VALUES (&apos;Tubers&apos;)&quot;); &#125; public override void OnUpgrade (SQLiteDatabase db, int oldVersion, int newVersion) &#123; throw new System.NotImplementedException (); &#125; &#125; 然后要做的就是自定义ContentProvider，并在应用中注册我们自定义的ContentProvider，这里依然适用特性注册, 指定authorities和Exported = true表示允许其他应用访问,先贴出完整代码在根据代码解释： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283[ContentProvider (new string[] &#123; VegetableProvider.AUTHORITY &#125;, Exported = true)] class VegetableProvider:ContentProvider &#123; public const string AUTHORITY = &quot;com.myue.vegetableprovider&quot;; static string BASE_PATH = &quot;vegetables&quot;; public static readonly Android.Net.Uri CONTENT_URI = Android.Net.Uri.Parse (&quot;content://&quot; + AUTHORITY + &quot;/&quot; + BASE_PATH); // MIME types used for getting a list, or a single vegetable public const string VEGETABLES_MIME_TYPE = ContentResolver.CursorDirBaseType + &quot;/vnd.myue.vegetableprovider&quot;; public const string VEGETABLE_MIME_TYPE = ContentResolver.CursorItemBaseType + &quot;/vnd.myue.vegetableprovider&quot;; // Column names public static class InterfaceConsts &#123; public const string Id = &quot;_id&quot;; public const string Name = &quot;name&quot;; &#125; const int GET_ALL = 0; // return code when list of Vegetables requested const int GET_ONE = 1; // return code when a single Vegetable is requested by ID static UriMatcher uriMatcher = BuildUriMatcher (); static UriMatcher BuildUriMatcher () &#123; var matcher = new UriMatcher (UriMatcher.NoMatch); // Uris to match, and the code to return when matched matcher.AddURI (AUTHORITY, BASE_PATH, GET_ALL); // all vegetables matcher.AddURI (AUTHORITY, BASE_PATH + &quot;/#&quot;, GET_ONE); // specific vegetable by numeric ID return matcher; &#125; VegetableDatabase vegeDB; public override bool OnCreate () &#123; vegeDB = new VegetableDatabase (Context); return true; &#125; public override string GetType (Android.Net.Uri uri) &#123; switch (uriMatcher.Match (uri)) &#123; case GET_ALL: return VEGETABLES_MIME_TYPE; // list case GET_ONE: return VEGETABLE_MIME_TYPE; // single item default: throw new System.Exception (&quot;Unknown Uri: &quot; + uri); &#125; &#125; public override Android.Database.ICursor Query (Android.Net.Uri uri, string[] projection, string selection, string[] selectionArgs, string sortOrder) &#123; switch (uriMatcher.Match (uri)) &#123; case GET_ALL: return vegeDB.ReadableDatabase.RawQuery (&quot;SELECT _id, name FROM vegetables&quot;, null); case GET_ONE: var id = uri.LastPathSegment; return vegeDB.ReadableDatabase.RawQuery (&quot;SELECT _id, name FROM vegetables WHERE _id = &quot; + id, null); default: throw new System.Exception (&quot;Unknown Uri: &quot; + uri); &#125; &#125; public override int Delete (Android.Net.Uri uri, string selection, string[] selectionArgs) &#123; throw new Java.Lang.UnsupportedOperationException (); &#125; public override Android.Net.Uri Insert (Android.Net.Uri uri, ContentValues values) &#123; throw new Java.Lang.UnsupportedOperationException (); &#125; public override int Update (Android.Net.Uri uri, ContentValues values, string selection, string[] selectionArgs) &#123; throw new Java.Lang.UnsupportedOperationException (); &#125; &#125; 先说明重写的6个方法，都是必须重写的，OnCreate方法是ContentProvider被创建后调用，可以实现初始化操作。Delete方法根据Uri删除selection条件匹配的纪录。Insert方法根据Uri插入values对应的数据。Update根据Uri修改selection条件匹配的纪录。Query根据Uri查询出selection匹配的记录。GetType方法返回当前Uri的MIME类型。多条数据的对应的MIME类型以ContentResolver.CursorDirBaseType （vnd.android.cursor.dir）开头，单条记录的MIME数据类型以ContentResolver.CursorItemBaseType（vnd.android.cursor.item）开头。 首先定义了Authority常量,代表ContentProvider传入Uri的主机名，与注册时指定的authorities相同。同时根据前面介绍过的Uri结构定义CONTENT_URI。定义一个static方法BuildUriMatcher用来初始化UriMatcher。通过AddURI方法添加到UriMatcher实例中，前两个参数构成URI，最后一个参数传入我们定义的标识码，当我们调用UriMatcher的Match方法匹配成功返回我们传入的标识码，不匹配则返回－1. 当我们重写GetType方法时，根据UriMatcher的Match方法返回的Code确定Uri对应的数据，如果是多条数据返回定义的以ContentResolver.CursorDirBaseType开头的MIME，单条数据返回定义的以ContentResolver.CursorItemBaseType开头的MIME。 重写增删改查方法，这里我们只重写了查询方法，其他方法抛出Java.Lang.UnsupportedOperationException异常，实际编码是可以根据需要实现。编码时可以调用ContentUris.WithAppendedId方法给Uri加上id，ContentUris.ParseId方法解析出Uri中的id值来方便我们的操作。 使用自定义的ContentProvider不再介绍与使用系统提供的同理。 http://www.xamarin.xyz/2016/05/14/contentprovider1 中有提到过使用ContentObserver来监听ContentProvider提供数据的变化。当应用到我们自定义的ContentProvider中是却没有任何效果。在我们自定义ContentProvider的Update，Delete，Insert方法中调用Context.ContentResolver.NotifyChange(uri, null);方法回调系统监听，就能有效的监听数据变化。 本文知识简单的介绍了一下自定义ContentProvider实现，更多内容请Baidu或Google Android原生文章介绍。 *更多Xamarin自定义ContentProvider内容请参考：https://developer.xamarin.com/guides/android/platform_features/intro_to_content_providers/part_3_-_creating_a_custom_contentprovider/ https://github.com/xamarin/monodroid-samples/blob/master/ContentProvider/LocationContentProvider.cs*","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://xamarin.xyz/tags/ContentProvider/"}]},{"title":"Xamarin.Android ContentProvider使用介绍","slug":"contentprovider1","date":"2016-05-14T04:32:19.000Z","updated":"2017-11-02T15:11:53.000Z","comments":true,"path":"2016/05/14/contentprovider1/","link":"","permalink":"http://xamarin.xyz/2016/05/14/contentprovider1/","excerpt":"ContentProvider为存储和读取数据提供了统一的接口，是应用程序暴露数据给其他应用程序的标准方式。使用ContentProvider，应用程序可以实现数据共享。Android中许多数据都是使用ContentProvider的形式暴漏给发者调用的(如视频，音频，图片，通讯录等)。根据提供的Uri通过ContentProvider可以实现对数据源的增删改查等操作，数据源通常是使用SQLite数据库提供数据，当然也可以是其他文件，如XMl文件等。","text":"ContentProvider为存储和读取数据提供了统一的接口，是应用程序暴露数据给其他应用程序的标准方式。使用ContentProvider，应用程序可以实现数据共享。Android中许多数据都是使用ContentProvider的形式暴漏给发者调用的(如视频，音频，图片，通讯录等)。根据提供的Uri通过ContentProvider可以实现对数据源的增删改查等操作，数据源通常是使用SQLite数据库提供数据，当然也可以是其他文件，如XMl文件等。 通过一张图演示ContentProvider是如何工作的 ContentProvider 是一个抽象类，通过实现这个抽象类暴露出操作数据的接口，根据注册的URI确定要操作的数据。 SQLiteOpenHelper SQLite数据库帮助类（数据源使用SQLite提供数据时会用到） UriMatcher UriMatcher用来管理、匹配查询数据的Uri ContentResolver 类似于一个代理，ContentResolver通过ContentProvider来获取其他与应用程序共享的数据 CursorAdapter 使用它来操作ContentProvider返回的数据 在使用ContentProvider时，我们都是传入一个Uri来确定要操作的数据，对应哪张Table哪列Column或者Xml文件的节点。根据传入的Uri返回一个Cusor结果集。 Android系统提供的ContentProvider有： Browser – bookmarks and browser history (requires permission READ_HISTORY_BOOKMARKS and/or WRITE_HISTORY_BOOKMARKS). CallLog – recent calls made or received with the device. Contacts – detailed information from the user’s contact list, including people, phones, photos &amp; groups. MediaStore – contents of the user’s device: audio (albums, artists, genres, playlists), images (including thumbnails) &amp; video. Settings – system-wide device settings and preferences. UserDictionary – contents of the user-defined dictionary used for predictive text input. Voicemail – history of voicemail messages. Uri介绍：格式如下： scheme://host:port/pathscheme在ContentProvider调用的Uri中协议指定为content。host:port组成主机名（或叫Authority）用于唯一标识这个，外部调用者可以根据这个标识来找到它。path用来表示我们要操作的数据，有如下格式: 操作person表中id为10的记录对应的path为“/person/10” 操作person表中id为10的记录的name字段对应的path为“/person/10/name” 操作person表中的所有记录对应的path为“/person” 如果数据不是来自数据库，要操作xml文件中person节点下的name节点，可以构建这样的路径：/person/name 如果要把一个字符串转换成Uri，可以使用Uri类中的Parse()方法，如下：Uri uri = Uri.Parse(“content://com.ljq.provider.personprovider/person”) Uri中可以使用通配符，如“/person/*”，＊代表所有字符，＃代表所有数字。 使用系统提供的ContentProvider根据Uri获取Cursor游标，除非自定义ContentProvider，否则使用时不回用到ContentProvider类。ManagedQuery方法已经过时不在介绍，ContentResolver.Query()和CursorLoader().LoadInBackground()可以获得Cursor对象实例，ContentResolver.Query()获得的Cursor对象需要我们自己管理调用Close关闭、释放Cursor(This cursor is unmanaged, so it must be closed when no longer required. Ensure that the code closes a cursor that is open, otherwise an error will occur.)，CursorLoader().LoadInBackground()查询不是在主线程进行的，所以查询时不会锁住UI，这个类实在Android 3.0 (API Level 11)被引入的，在低版本中使用需要v4包支持。 CursorLoader包含如下构造函数 1public CursorLoader (Context context, Uri uri, string[] projection, string selection, string[] selectionArgs, string sortOrder); 后5个参数与ContentResolver.Query方法参数相同，分别介绍每个参数的意义： uri 提供给 ContentProvider的资源定位符 projection 指定要查询哪些列 selection 条件语句，相当于SQL中的where条件 selectionArgs 替换selection中的参数 sortOrder 表示根据哪列进行排序 可传入null 接下来使用CursorLoader().LoadInBackground()实现一个查询联系人Demo。 添加android.permission.READ_CONTACTS权限 定义uri和projection： 123456var uri = ContactsContract.Contacts.ContentUri;string[] projection = &#123; ContactsContract.Contacts.InterfaceConsts.Id, ContactsContract.Contacts.InterfaceConsts.DisplayName, ContactsContract.Contacts.InterfaceConsts.PhotoId,&#125;; 忽略selection、selectionArgs、sortOrder三个参数，定义CursorLoader，并将ICursor数据保存到一个List中： 123456789101112CursorLoader cursorLoader = new CursorLoader (this, uri, projection, null, null, null);var cursor = (ICursor)cursorLoader.LoadInBackground ();var contactList = new List&lt;Contact&gt; ();while (cursor.MoveToNext ()) &#123; contactList.Add (new Contact &#123; Id = cursor.GetLong (cursor.GetColumnIndex (projection [0])), DisplayName = cursor.GetString (cursor.GetColumnIndex (projection [1])), PhotoId = cursor.GetString (cursor.GetColumnIndex (projection [2])) &#125;);&#125; 自定义Adapter,处理数据显示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class ContactsAdapter:BaseAdapter &#123; List&lt;Contact&gt; contactList; Context context; public ContactsAdapter (Context context, List&lt;Contact&gt; contactList) &#123; this.contactList = contactList; this.context = context; &#125; #region implemented abstract members of BaseAdapter public override Java.Lang.Object GetItem (int position) &#123; return null; &#125; public override long GetItemId (int position) &#123; return contactList [position].Id; &#125; public override Android.Views.View GetView (int position, Android.Views.View convertView, Android.Views.ViewGroup parent) &#123; var view = convertView ?? LayoutInflater.From (context).Inflate (Resource.Layout.ContactListItem, parent, false); var contactName = view.FindViewById&lt;TextView&gt; (Resource.Id.ContactName); var contactImage = view.FindViewById&lt;ImageView&gt; (Resource.Id.ContactImage); contactName.Text = contactList [position].DisplayName; if (contactList [position].PhotoId == null) &#123; contactImage.SetImageResource (Resource.Mipmap.Icon); &#125; else &#123; var contactUri = ContentUris.WithAppendedId (ContactsContract.Contacts.ContentUri, contactList [position].Id); var contactPhotoUri = Android.Net.Uri.WithAppendedPath (contactUri, ContactsContract.Contacts.Photo.ContentDirectory); contactImage.SetImageURI (contactPhotoUri); &#125; return view; &#125; public override int Count &#123; get &#123; return contactList.Count; &#125; &#125; #endregion &#125; 最后调用listview.Adapter = new ContactsAdapter (this, contactList);将Adapter的数据显示在ListView上。 Android为我们提供了SimpleCursorAdapter来处理Cursor数据的显示，使用方法与SimpleAdapter类似，这里不过多介绍 ContentObserver监听ContentProvider的数据变化ContentObserver——内容观察者，目的是观察特定Uri引起的数据库的变化，继而做一些相应的处理，当ContentObserver所观察的Uri发生变化时，便会触发它。 自定义ContentObserver子类，重写OnChange方法且必须重写构造方法ContentObserver(Handler handler) 。 1234567891011121314class ContactsContentObserver:ContentObserver&#123; public override void OnChange (bool selfChange, Android.Net.Uri uri) &#123; System.Console.WriteLine (uri.ToString ()); base.OnChange (selfChange, uri); &#125; public ContactsContentObserver (Handler handler) : base (handler) &#123; &#125;&#125; 调用ContentResolver.RegisterContentObserver注册监听器。 1ContentResolver.RegisterContentObserver (uri, true, new ContactsContentObserver (new Handler ())); ContentResolver.RegisterContentObserver方法三个参数：uri为要监听的Uri，第二个参数notifyForDescendents为一个bool类型的值,false 表示精确匹配，即只匹配该Uri,true 表示可以同时匹配其派生的Uri.第三个参数为定义的ContentObserver实例。 增加、删除联系人会看到 “content://com.android.contacts” 字符串输出。 当我们不需要监听ContentObserver时需要调用ContentResolver.UnregisterContentObserver ()方法取消注册。 可以自己尝试短信验证码自动提取","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"ContentProvider","slug":"ContentProvider","permalink":"http://xamarin.xyz/tags/ContentProvider/"}]},{"title":"Xamarin.Android LocalBroadcastManager使用介绍","slug":"localbroadcastmanager","date":"2016-05-11T14:38:37.000Z","updated":"2017-11-02T15:16:54.360Z","comments":true,"path":"2016/05/11/localbroadcastmanager/","link":"","permalink":"http://xamarin.xyz/2016/05/11/localbroadcastmanager/","excerpt":"android-support-v4.jar中引入LocalBroadcastManager，是一种只能在应用内接收的广播，相比普通的BroadcastReceiver有更好的安全心和更高的运行效率，是发送应用内广播的推荐方式。LocalBroadcastManager使用方式与普通的BroadcastReceiver差别不大。本地广播无法通过静态注册方式来接受,相比起系统全局广播更加高效。 接下来演示一个应用内广播的Demo，实现效果是点击按钮发送广播，程序内部接收广播弹出提示框。","text":"android-support-v4.jar中引入LocalBroadcastManager，是一种只能在应用内接收的广播，相比普通的BroadcastReceiver有更好的安全心和更高的运行效率，是发送应用内广播的推荐方式。LocalBroadcastManager使用方式与普通的BroadcastReceiver差别不大。本地广播无法通过静态注册方式来接受,相比起系统全局广播更加高效。 接下来演示一个应用内广播的Demo，实现效果是点击按钮发送广播，程序内部接收广播弹出提示框。 首先定义BroadcastReceiver子类，动态注册广播时使用。 1234567891011121314151617public class CustomBroadcastReceiver : BroadcastReceiver&#123; public override void OnReceive (Context context, Intent intent) &#123; AlertDialog.Builder builder = new AlertDialog.Builder (context); builder.SetTitle (&quot;警告&quot;); builder.SetMessage (&quot;检测到本地广播&quot;); builder.SetCancelable (false); builder.SetPositiveButton (&quot;确定&quot;, (s, e) =&gt; &#123; &#125;); AlertDialog alert = builder.Create (); alert.Window.SetType (WindowManagerTypes.SystemAlert); alert.Show (); &#125;&#125; 在广播中弹出AlertDialog需要设置对话框的类型为SystemAlert，且增加“android.permission.SYSTEM_ALERT_WINDOW”权限，否则不能正常显示。 在广播中启动Activity要添加Intent的Flag为ActivityFlags.NewTask，创建一个新的栈存放新打开的Activity。 实例化LocalBroadcastManager完成广播的注册和取消注册操作。 定义两个类变量： LocalBroadcastManager localBroadcastManager; CustomBroadcastReceiver customBroadcastReceiver; 动态注册本地广播 localBroadcastManager = LocalBroadcastManager.GetInstance (this); customBroadcastReceiver = new CustomBroadcastReceiver (); IntentFilter intentFilter = new IntentFilter (&quot;com.myue.custombroadcastreceiver&quot;); localBroadcastManager.RegisterReceiver (customBroadcastReceiver, intentFilter); 取消注册 localBroadcastManager.UnregisterReceiver (customBroadcastReceiver); 发送本地广播 Intent intent = new Intent (&quot;com.myue.custombroadcastreceiver&quot;); localBroadcastManager.SendBroadcast (intent);","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"LocalBroadcastManager","slug":"LocalBroadcastManager","permalink":"http://xamarin.xyz/tags/LocalBroadcastManager/"}]},{"title":"Xamarin.Android 广播接收器使用介绍","slug":"broadcastreceiver","date":"2016-05-11T06:16:57.000Z","updated":"2017-11-02T15:11:00.000Z","comments":true,"path":"2016/05/11/broadcastreceiver/","link":"","permalink":"http://xamarin.xyz/2016/05/11/broadcastreceiver/","excerpt":"BroadcastReceiver就是我们本文要介绍的主角广播接受者，Android四大基本组件之一。本质上是一种全局的监听器，监听系统全局的广播消息，可以接受来自系统和应用的广播。由于BroadcastReceiver是一个全局的监听器，因此可以将它作为不同应用程序间通信的一种手段。系统在特定情况下会发送广播，比如电量低或者充足，刚启动完，插入耳机，输入法改变等都会发送特定广播，这是系统广播，每个APP都会收到，当然我们也可以自己发广播，比如：接到服务端推送信息，用户在别处登录，发送广播强制用户下线回到 登陆界面，并提示在别处登录。","text":"BroadcastReceiver就是我们本文要介绍的主角广播接受者，Android四大基本组件之一。本质上是一种全局的监听器，监听系统全局的广播消息，可以接受来自系统和应用的广播。由于BroadcastReceiver是一个全局的监听器，因此可以将它作为不同应用程序间通信的一种手段。系统在特定情况下会发送广播，比如电量低或者充足，刚启动完，插入耳机，输入法改变等都会发送特定广播，这是系统广播，每个APP都会收到，当然我们也可以自己发广播，比如：接到服务端推送信息，用户在别处登录，发送广播强制用户下线回到 登陆界面，并提示在别处登录。 广播类型介绍 接收系统广播前面也提到过系统会在某些时候发送特定的广播，下面写一个接收系统广播的例子。 首先要为我们的应用注册一个广播接收器，可以代码注册（动态）或者AndroidManifest中注册（静态）。动态注册广播是借助IntentFilter，通过IntentFilter的AddAction方法指定要监听的广播然后通过RegisterReceiver注册广播监听，动态注册一定要在合适的时候（通常是OnDestroy方法内）调用UnregisterReceiver停止广播监听。动态注册只有当应用程序运行时才能监听到广播，如果想应用程序没有启动仍然可以监听到广播需要使用静态注册，在AndroidManifest.xml中增加&lt; receiver &gt;节点进行静态注册。 动态注册定义MyBroadcastReceiver 继承BroadcastReceiver，重写OnReceive方法完成相关逻辑。 123456789public class MyBroadcastReceiver:BroadcastReceiver&#123; #region implemented abstract members of BroadcastReceiver public override void OnReceive (Context context, Intent intent) &#123; System.Console.WriteLine (\"MyBroadcastReceiver OnReceive\"); &#125; #endregion &#125; 注册广播接收器，这里我们注册的是电量改变广播。 常用系统广播总结： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150Intent.ACTION_AIRPLANE_MODE_CHANGED;//关闭或打开飞行模式时的广播Intent.ACTION_BATTERY_CHANGED;//充电状态，或者电池的电量发生变化//电池的充电状态、电荷级别改变，不能通过组建声明接收这个广播，只有通过Context.registerReceiver()注册Intent.ACTION_BATTERY_LOW;//表示电池电量低Intent.ACTION_BATTERY_OKAY;//表示电池电量充足，即从电池电量低变化到饱满时会发出广播Intent.ACTION_BOOT_COMPLETED;//在系统启动完成后，这个动作被广播一次（只有一次）。Intent.ACTION_CAMERA_BUTTON;//按下照相时的拍照按键(硬件按键)时发出的广播Intent.ACTION_CLOSE_SYSTEM_DIALOGS;//当屏幕超时进行锁屏时,当用户按下电源按钮,长按或短按(不管有没跳出话框)，进行锁屏时,android系统都会广播此Action消息Intent.ACTION_CONFIGURATION_CHANGED;//设备当前设置被改变时发出的广播(包括的改变:界面语言，设备方向，等，请参考Configuration.java)Intent.ACTION_DATE_CHANGED;//设备日期发生改变时会发出此广播Intent.ACTION_DEVICE_STORAGE_LOW;//设备内存不足时发出的广播,此广播只能由系统使用Intent.ACTION_DEVICE_STORAGE_OK;//设备内存从不足到充足时发出的广播,此广播只能由系统使用Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE;//移动APP完成之后，发出的广播(移动是指:APP2SD)Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE;//正在移动APP时，发出的广播(移动是指:APP2SD)Intent.ACTION_HEADSET_PLUG;//在耳机口上插入耳机时发出的广播Intent.ACTION_INPUT_METHOD_CHANGED;//改变输入法时发出的广播Intent.ACTION_LOCALE_CHANGED;//设备当前区域设置已更改时发出的广播Intent.ACTION_MEDIA_BAD_REMOVAL;//未正确移除SD卡(正确移除SD卡的方法:设置--SD卡和设备内存--卸载SD卡)，但已把SD卡取出来时发出的广播//广播：扩展介质（扩展卡）已经从 SD 卡插槽拔出，但是挂载点 (mount point) 还没解除 (unmount)Intent.ACTION_MEDIA_BUTTON;//按下\"Media Button\" 按键时发出的广播,假如有\"Media Button\" 按键的话(硬件按键)Intent.ACTION_MEDIA_CHECKING;//插入外部储存装置，比如SD卡时，系统会检验SD卡，此时发出的广播?Intent.ACTION_MEDIA_EJECT;//已拔掉外部大容量储存设备发出的广播（比如SD卡，或移动硬盘）,不管有没有正确卸载都会发出此广播?//广播：用户想要移除扩展介质（拔掉扩展卡）。Intent.ACTION_MEDIA_MOUNTED;//插入SD卡并且已正确安装（识别）时发出的广播//广播：扩展介质被插入，而且已经被挂载。Intent.ACTION_MEDIA_REMOVED;//外部储存设备已被移除，不管有没正确卸载,都会发出此广播？// 广播：扩展介质被移除。Intent.ACTION_MEDIA_SCANNER_FINISHED;//广播：已经扫描完介质的一个目录Intent.ACTION_MEDIA_SCANNER_SCAN_FILE;//广播:扫描指定文件Intent.ACTION_MEDIA_SCANNER_STARTED;//广播：开始扫描介质的一个目录Intent.ACTION_MEDIA_SHARED;// 广播：扩展介质的挂载被解除 (unmount)，因为它已经作为 USB 大容量存储被共享。Intent.ACTION_MEDIA_UNMOUNTED// 广播：扩展介质存在，但是还没有被挂载 (mount)。Intent.ACTION_PACKAGE_ADDED;//成功的安装APK之后//广播：设备上新安装了一个应用程序包。//一个新应用包已经安装在设备上，数据包括包名（最新安装的包程序不能接收到这个广播） Intent.ACTION_PACKAGE_CHANGED;//一个已存在的应用程序包已经改变，包括包名Intent.ACTION_PACKAGE_DATA_CLEARED;//清除一个应用程序的数据时发出的广播(在设置－－应用管理－－选中某个应用，之后点清除数据时?)//用户已经清除一个包的数据，包括包名（清除包程序不能接收到这个广播）Intent.ACTION_PACKAGE_INSTALL;//触发一个下载并且完成安装时发出的广播，比如在电子市场里下载应用？Intent.ACTION_PACKAGE_REMOVED;//成功的删除某个APK之后发出的广播//一个已存在的应用程序包已经从设备上移除，包括包名（正在被安装的包程序不能接收到这个广播）Intent.ACTION_PACKAGE_REPLACED;//替换一个现有的安装包时发出的广播（不管现在安装的APP比之前的新还是旧，都会发出此广播？）Intent.ACTION_PACKAGE_RESTARTED;//用户重新开始一个包，包的所有进程将被杀死，所有与其联系的运行时间状态应该被移除，包括包名（重新开始包程序不能接收到这个广播）Intent.ACTION_POWER_CONNECTED;//插上外部电源时发出的广播Intent.ACTION_POWER_DISCONNECTED;//已断开外部电源连接时发出的广播Intent.ACTION_REBOOT;//重启设备时的广播Intent.ACTION_SCREEN_OFF;//屏幕被关闭之后的广播Intent.ACTION_SCREEN_ON;//屏幕被打开之后的广播Intent.ACTION_SHUTDOWN;//关闭系统时发出的广播Intent.ACTION_TIMEZONE_CHANGED;//时区发生改变时发出的广播Intent.ACTION_TIME_CHANGED;//时间被设置时发出的广播Intent.ACTION_TIME_TICK;//广播：当前时间已经变化（正常的时间流逝）。//当前时间改变，每分钟都发送，不能通过组件声明来接收，只有通过Context.registerReceiver()方法来注册Intent.ACTION_UID_REMOVED;//一个用户ID已经从系统中移除发出的广播Intent.ACTION_UMS_CONNECTED;//设备已进入USB大容量储存状态时发出的广播？Intent.ACTION_UMS_DISCONNECTED;//设备已从USB大容量储存状态转为正常状态时发出的广播？Intent.ACTION_WALLPAPER_CHANGED;//设备墙纸已改变时发出的广播 更多系统广播请参考： http://www.android-doc.com/reference/android/content/Intent.html 注册广播指定IntentFilter的Action为Intent.ActionBatteryChanged。 1234IntentFilter itFilter = new IntentFilter ();itFilter.AddAction (Intent.ActionBatteryChanged);RegisterReceiver (myBoradcastReceiver, itFilter); 停止广播监听： UnregisterReceiver (myBoradcastReceiver); 运行项目，在模拟器中更改电量会看到对应的输出。 静态注册 学习中有遇到问题，感谢Y-Z-F的热心帮助 广播的静态注册可以通过BroadcastReceiver和IntentFilter特性实现，也可以直接在AndroidManifest中增加&lt; receiver &gt;节点完成注册。 实际测试中使用过android.intent.action.BATTERY_CHANGED和android.intent.action.CONFIGURATION_CHANGED来测试静态注册都无法监听到广播，查询发现有些系统广播不能静态注册，如： android.intent.action.SCREEN_ON android.intent.action.SCREEN_OFF android.intent.action.BATTERY_CHANGED android.intent.action.CONFIGURATION_CHANGED android.intent.action.TIME_TICK 原因： 1、提高效率，这几个是Android的基本事件，太多程序监听会拖慢系统，所以Android不鼓励我们在后台监听这些事件。 2、有序广播优先级问题，静态注册系统广播，系统的优先级大于应用的，系统监听过程中阻止了广播的向下传播。但是动态注册的优先级高于静态注册的优先级，故用动态注册代替静态注册。 3、系统安全考虑 解决办法： 使用动态注册，必须在Activity销毁时掉用UnregisterReceiver，随着Activity的销毁变不能再接收广播，可以通过启动一个Service，在Service内动态注册一个BroadcastReceiver. 参考链接：http://www.th7.cn/Program/Android/201404/190738.shtml 通过特性注册广播,这里注册的是飞行模式的改变： 123[BroadcastReceiver][IntentFilter (new string[]&#123; Intent.ActionAirplaneModeChanged &#125;)]public class CustomBroadcastReceiver : BroadcastReceiver 也可以在AndroidManifest中增加节点注册广播，如果不会写且一定要在AndroidManifest中注册可以先使用特性注册，编译项目，然后进入项目目录依次进入 obj-&gt;debug-&gt;android 找到XS为我们生成的AndroidManifest.xml文件并打开。找到receiver节点复制到项目中AndroidManifest.xml文件中application节点下面。 12345&lt;receiver android:name=\"md5c94a8952452462141c1443b48d775737.CustomBroadcastReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.AIRPLANE_MODE\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; android:name中包含的md5值是根据我们的项目报名生成的,这个值是必须的，如果想直接使用Android原生中省略包名的写法android:name=”.CustomBroadcastReceiver”。必须要对定义的广播接收器增加特性注册。 12[Register (&quot;com.myue.broadcastreceiver（包名）.CustomBroadcastReceiver&quot;)]public class CustomBroadcastReceiver : BroadcastReceiver 不要在广播里执行任何耗时操作,因为在广播中是不允许开辟线程的, 当OnReceiver()方法运行较长时间(超过10秒)还没有结束的话,那么程序会报错(ANR), 广播更多的时候扮演的是一个打开其他组件的角色,比如启动Service、Activity,Notification提示等！ 发送广播当我们想发送一个自己的广播时同样要先注册一个广播接收器，然后调用发送广播的方法SendBroadcast (intent)或者SendOrderedBroadcast(intent),两个方法代表前面提到过的两种广播类型。对于有序广播，我们可以通过IntentFilter设置优先级（priority，范围为－1000～1000之间），值越大优先级越高，优先级高的会先收到广播，并可以设置AbortBroadcast = false;截断广播的继续传递。 定义广播接收器,接受的是我们自己发送的广播： 123456789[BroadcastReceiver][IntentFilter (new string[]&#123; &quot;com.myue.custombroadcastreceiver&quot; &#125;)]public class CustomBroadcastReceiver : BroadcastReceiver&#123; public override void OnReceive (Context context, Intent intent) &#123; Toast.MakeText (context, &quot;Received intent!&quot;, ToastLength.Short).Show (); &#125;&#125; 发送广播代码： 1SendBroadcast (new Intent (&quot;com.myue.custombroadcastreceiver&quot;)); 本文介绍的广播是全局广播，即我们发送的广播其它应用都会接收到，容易引发安全性问题。Android为我们提供了本地广播机制，该机制发送的广播只能在APP内接收到。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"BroadcastReceiver","slug":"BroadcastReceiver","permalink":"http://xamarin.xyz/tags/BroadcastReceiver/"}]},{"title":"Xamarin.Android Service详解","slug":"service3","date":"2016-05-09T17:09:07.000Z","updated":"2017-11-02T15:20:17.000Z","comments":true,"path":"2016/05/10/service3/","link":"","permalink":"http://xamarin.xyz/2016/05/10/service3/","excerpt":"IBinder是远程对象的基本接口，是一个轻量级远程调用机制的核心部分，不仅可以用于远程调用，也可用于进程内调用。该接口定义了与远程对象交互的协议，通常我们不会直接实现这个接口而是继承Binder。IBinder的主要API是transact()，与它对应另一方法是Binder.onTransact()。第一个方法使你可以向远端的IBinder对象发送发出调用，第二个方法使你自己的远程对象能够响应接收到的调用。IBinder的API都是同步执行的，比如transact()直到对方的Binder.onTransact()方法调用完成后才返回。","text":"IBinder是远程对象的基本接口，是一个轻量级远程调用机制的核心部分，不仅可以用于远程调用，也可用于进程内调用。该接口定义了与远程对象交互的协议，通常我们不会直接实现这个接口而是继承Binder。IBinder的主要API是transact()，与它对应另一方法是Binder.onTransact()。第一个方法使你可以向远端的IBinder对象发送发出调用，第二个方法使你自己的远程对象能够响应接收到的调用。IBinder的API都是同步执行的，比如transact()直到对方的Binder.onTransact()方法调用完成后才返回。 通过transact()发送的数据是Parcel，Parcel是一种一般的缓冲区，除了有数据外还带有一些描述它内容的元数据。元数据用于管理IBinder对象的引用，这样就能在缓冲区从一个进程移动到另一个进程时保存这些引用。这样就保证了当一个IBinder被写入到Parcel并发送到另一个进程中，如果另一个进程把同一个IBinder的引用回发到原来的进程，那么这个原来的进程就能接收到发出的那个IBinder的引用。这种机制使IBinder和Binder像唯一标志符那样在进程间管理。 Binder机制还支持进程间的递归调用。例如，进程Ａ执行自己的IBinder的transact()调用进程Ｂ 的Binder，而进程Ｂ在其Binder.onTransact()中又用transact()向进程Ａ发起调用，那么进程Ａ 在等待它发出的调用返回的同时，还会用Binder.onTransact()响应进程Ｂ的transact()。 总之Binder造成的结果就是让我们感觉到跨进程的调用与进程内的调用没什么区别。 当操作远程对象时，你应该查看它们是否有效，有三种方法可以使用： １ transact()方法将在IBinder所在的进程不存在时抛出RemoteException异常。 ２ 如果目标进程不存在，那么调用pingBinder()时返回false。 ３ 可以用linkToDeath()方法向IBinder注册一个IBinder.DeathRecipient，在IBinder代表的进程退出时被调用。 以上介绍摘自：http://blog.csdn.net/niu_gao/article/details/6453218 AIDL使用详解AIDL介绍前面我们介绍过Service➕Messager实现跨进程通信(interprocess communication)，即IPC。为了实现跨进程通信，Android为我们提供了Binder机制，而这种机制使用的接口语言就是：AIDL(Android Interface Definition Language)，AIDL并非真正的编程语言只是定义两个进程间的通信接口而已，Android SDK的 platform-tools目录下的aidl.exe工具会根据AIDL生成符合通信协议的接口代码。该接口内包含一个Stub的内部类，该类中实现了在该类中实现了IBinder接口与自定义的通信接口, 这个类将会作为远程Service的回调类——实现了IBinder接口,所以可作为Service的onBind( )方法的返回值！ 概念讲的可能有点模糊，下面简单的介绍一个使用Android系统服务的例子。 使用系统提供的服务这里介绍的是调用系统服务挂断电话的一个例子，需要说明的是这个Demo并没有达到我们预期的效果，挂断电话需要添加android.permission.MODIFY_PHONE_STATE权限（Permission is only granted to system apps ），由于我们不是系统应用无法使用这个权限，所以挂断电话仍然会抛出异常。在低版本的Android系统的中这个例子应该是没有问题，说明Android系统正越来越安全往一个好的方向发展。 首先准备需要用到的接口描述语言，从服务端拷贝而来，这里不提供可自行Google或百度：Bundle.aidl、ITelephony.aidl、NeighboringCellInfo.aidl主要用到的是ITelephony，因为ITelephony.aidl中有引用另外两个文件所以也要复制到项目里。 在项目中定义一个AIDL文件夹，不是必须的只是为了项目结构。将准备好的三个AIDL文件添加到AIDL文件夹中，选中全部AIDL文件，右键 ——&gt; Build Action ——&gt; AndroidInterfaceDescription.保存并编译项目，如果操作正确应该不会报错。 现在打开项目目录，依次进入obj-&gt;Debug/Release-&gt;aidl 会发现已经为我们生成了三个cs文件对应三个AIDL文件。查看ITelephony.cs文件 可以看到里边包含一个ITelephonyStub内部类。这就是接下来我们要用到的，只是看一下，不需要什么操作，可以直接在项目内使用。 引用using Com.Android.Internal.Telephony; 下面给出项目部分代码： 123456789101112131415161718192021class MyPhoneStateListener:PhoneStateListener&#123; public override void OnCallStateChanged (CallState state, string incomingNumber) &#123; System.Console.WriteLine (incomingNumber); if (incomingNumber.Equals (&quot;110&quot;) &amp;&amp; state == CallState.Ringing) &#123; //挂断电话 var class_ref = JNIEnv.FindClass (&quot;android/os/ServiceManager&quot;); //IBinder getService(String name) var method_id = JNIEnv.GetStaticMethodID (class_ref, &quot;getService&quot;, &quot;(Ljava/lang/String;)Landroid/os/IBinder;&quot;); var binder = Java.Lang.Object.GetObject&lt;IBinder&gt; ( JNIEnv.CallStaticObjectMethod (class_ref, method_id, new JValue (new Java.Lang.String (Activity.TelephonyService))), JniHandleOwnership.TransferLocalRef); var telephony = ITelephonyStub.AsInterface (binder); telephony.EndCall (); &#125; base.OnCallStateChanged (state, incomingNumber); &#125;&#125; 挂断电话具体代码介绍自行百度。Xamarin JNI相关操作请参考：https://developer.xamarin.com/guides/android/advanced_topics/java_integration_overview/working_with_jni/ 自定义AIDLAIDL注意事项（Java代码编写）： 接口名词需要与aidl文件名相同 接口和方法前面不要加访问权限修饰符：public ,private,protected等，也不能用static final! AIDL默认支持的类型包括Java基本类型，String，List，Map，CharSequence，除此之外的其他类型都 需要import声明，对于使用自定义类型作为参数或者返回值，自定义类型需要实现Parcelable接口 自定义类型和AIDL生成的其它接口类型在aidl描述文件中，应该显式import，即便在该类和定义 的包在同一个包中。 服务端1.创建AIDL文件命名为IMyService.AIDL，XS无法直接创建AIDL文件，Visual Studio Code创建文件保存为AIDL添加到项目里即可： 123456package com.myue.service;interface IMyService&#123; //作为传入参数,接口中定义方法时,需要制定新参的传递模式,这里是传入,所以前面有一个in int Add(in int value1,in int value2);&#125; 设置Build Action，编译项目，会生成IMyService.cs文件，包含IMyService接口。 2.自定义Binder类，继承IMyServiceStub和IMyService注意添加using Com.Myue.Service; 123456789public class MyBinder: IMyServiceStub, IMyService&#123; public override int Add (int value1, int value2) &#123; System.Console.WriteLine (&quot;IMyService Add&quot;); return value1 + value2; &#125; &#125; 3.自定义Service，注册为可隐式调用 12345678910111213141516171819202122[Service][IntentFilter (new string[] &#123; &quot;com.myue.myservice&quot; &#125;)]public class MyService: Service&#123; public override void OnCreate () &#123; base.OnCreate (); System.Console.WriteLine (&quot;MyService OnCreate&quot;); &#125; public override IBinder OnBind (Intent intent) &#123; return new MyBinder (); &#125; public override void OnDestroy () &#123; base.OnDestroy (); System.Console.WriteLine (&quot;MyService OnDestroy&quot;); &#125; &#125; 客户端要做的就是参看前面介绍的调用系统服务和使用Bound Service,编写相关代码。即复制服务端AIDL到客户端，并生成接口文件。定义MyServiceConnection，通过IMyServiceStub.AsInterface获取服务代理。 123456789101112131415161718class MyServiceConnection : Java.Lang.Object, IServiceConnection&#123; public MyServiceConnection () &#123; &#125; public void OnServiceConnected (ComponentName name, IBinder service) &#123; IMyServiceStub.AsInterface(service); &#125; public void OnServiceDisconnected (ComponentName name) &#123; &#125;&#125; 自定义AIDL很少使用，以上部分没有编写Demo测试。如有问题请指出 前面提到过AIDL默认支持几种基本数据类型，传递复杂数据类型需要通过自定义实现Parcelable接口，可参考http://www.xamarin.xyz/2016/04/29/activity2/ 中传递对象数据的介绍，这里不在举例。 通过Binder的onTransact完成跨进程通信该部分同样为简单描述，没有编写实际Demo。 服务端实现定义Binder需重写OnTransact方法。操作相关数据通过Parcel返回给客户端。 客户端在IServiceConnection的OnServiceConnected方法内获取Binder,并调用service.Transact ()方法获取数据。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Service","slug":"Service","permalink":"http://xamarin.xyz/tags/Service/"}]},{"title":"Xamarin.Android Service进阶教程","slug":"service2","date":"2016-05-08T03:51:31.000Z","updated":"2017-11-02T15:19:32.810Z","comments":true,"path":"2016/05/08/service2/","link":"","permalink":"http://xamarin.xyz/2016/05/08/service2/","excerpt":"前面介绍Service时已经说过Service是运行在主线程中的，我们需要在一个单独的线程中处理耗时的操作，在Service中自定义线程无疑增加了我们的代码量且可能因为我们不适当的处理引起应用程序的ANR异常，Android为我们提供了IntentService来解决这个问题。IntentService继承与Service提送了一个线程来处理我们的耗时操作，且不需要我们控制、结束Service。多次启动IntentService，每个Service的操作会加入到一个工作队列依次执行.","text":"前面介绍Service时已经说过Service是运行在主线程中的，我们需要在一个单独的线程中处理耗时的操作，在Service中自定义线程无疑增加了我们的代码量且可能因为我们不适当的处理引起应用程序的ANR异常，Android为我们提供了IntentService来解决这个问题。IntentService继承与Service提送了一个线程来处理我们的耗时操作，且不需要我们控制、结束Service。多次启动IntentService，每个Service的操作会加入到一个工作队列依次执行. IntentService的使用与普通Service有些区别，就是在定义Service时，普通的Service必须重写OnBind方法，IntentService则要重写的是OnHandleIntent，在OnHandleIntent方法中编写我们耗时操作的代码。 Bound Service介绍上一篇文章介绍了Service的两种生命周期和常见的使用形势，现在对Bound Service简单的介绍一下。通过bindService方法启动Service主要是为了实现应用应用程序的通信，可以是应用内的也可以是不同应用之间的通信。 Service相同进程内通信通过一个简单的例子介绍如何使用bindService方式启动服务。 自定义Binder子类，实现自己的逻辑代码，作为Service中OnBind的返回。 1234567class MyBinder:Binder&#123; public void Say () &#123; System.Console.WriteLine (&quot;Say What!!!&quot;); &#125;&#125; 实现Service代码,在重写的OnBind方法中返回定义的Binder对象实例。 12345678910111213[Service]class MyService:Service&#123; #region implemented abstract members of Service public override IBinder OnBind (Intent intent) &#123; return new MyBinder (); &#125; #endregion &#125; 此时我门可以尝试调用BindService以绑定启动我们的服务，会发现我们的工作并没有完成，还需要定义一个实现了IServiceConnection接口的类，这个类将作为Service与Activity之通信的桥梁。IServiceConnection接口有两个方法OnServiceConnected和OnServiceDisconnected，如果链接成功回调OnServiceConnected方法，如果异常终止或者其它原因导致Service连接断开则回调OnServiceDisconnected方法，调用UnBindService断开Service不会回调该方法。 123456789101112131415class MyServiceConnection:Java.Lang.Object,IServiceConnection&#123; public void OnServiceConnected (ComponentName name, IBinder service) &#123; System.Console.WriteLine (&quot;OnServiceConnected&quot;); var binder = service as MyBinder; binder.Say (); &#125; public void OnServiceDisconnected (ComponentName name) &#123; System.Console.WriteLine (&quot;OnServiceDisconnected&quot;); &#125; &#125; 此时就可以调用如下代码启动并绑定Service,第三个参数为Flag标识。 12Intent intent = new Intent (this, typeof(MyService));BindService (intent, new MyServiceConnection (), Bind.AutoCreate); 当Service不在需要时应调用UnbindService方法停止服务。该方法传入一个IServiceConnection的对象，这个对象应与启动时传入的对象是同一个对象，否为会抛出Java.Lang.IllegalArgumentException Service not registered 异常 1UnbindService (serviceConnection); 至此实现一个简单的Bound Service例子结束。 有些情况下为了防止重复绑定服务应该有如下修改： The BindService method should be called from the ApplicationContext rather than from the Activity. The SerivceConnection instance should be returned from OnRetainNonConfigurationInstance . The OnRetainNonConfigurationInstance method should set a flag that will only be used to unbind the service when the service is not stopped due to a configuration change. Service不同进程内通信这几简单的介绍Service➕Messenger实现不同进程间通信 inter-process communication (IPC) ,Android Interface Definition Language (AIDL)下一片文章中介绍。 服务端Service做如下修改,注册Service支持隐式启动并返回Messenger提供的Binder： 1234567891011121314151617181920212223242526[Service][IntentFilter(new String[]&#123;&quot;com.xamarin.MyService&quot;&#125;)]class MyService:Service&#123; Messenger messenger; public MyService () &#123; messenger = new Messenger (new handler ()); &#125; public override IBinder OnBind (Intent intent) &#123; return messenger.Binder; &#125; class handler : Handler &#123; public override void HandleMessage (Message msg) &#123; //获取客户端message中的Messenger，用于回调 msg.ReplyTo.Send (Message.Obtain()); &#125; &#125; &#125; 客户端绑定Service也要做相应调整： 定义Intent new Intent (&quot;com.xamarin.MyService&quot;); 实现IServiceConnection的OnServiceConnected方法内通过new Messenger (service)获得Messenger发送消息。 这里涉及到Message的使用，先不做过多介绍。 后续补充，Android 5.0之后会抛出 Service Intent must be explicit: Intent，对应解决办法同时设置Intent的Action和PackageName即可。 具体使用可参考http://my.oschina.net/u/262208/blog/378249 关于Xamarin.Android Service完整使用请参考：https://developer.xamarin.com/guides/android/application_fundamentals/services/part_3_-_viewing_running_services_and_stock_service_example","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Service","slug":"Service","permalink":"http://xamarin.xyz/tags/Service/"}]},{"title":"Xamarin.Android Service入门介绍","slug":"service1","date":"2016-05-06T00:37:27.000Z","updated":"2017-11-02T15:18:34.000Z","comments":true,"path":"2016/05/06/service1/","link":"","permalink":"http://xamarin.xyz/2016/05/06/service1/","excerpt":"Service作为Android四大组件之一,它主要用于在后台处理一些耗时的逻辑，没有UI界面，我们可以在程序退出的情况下，让Service在后台继续保持运行状态。注意Service不是Thread。Android的服务可以分为本地服务（主进程）和远程服务（Remote，独立的进程），本地服务是处理我们自己应用程序的逻辑，远程服务是提供系统服务的Service（AIDL的使用）。本文着重介绍本地服务。","text":"Service作为Android四大组件之一,它主要用于在后台处理一些耗时的逻辑，没有UI界面，我们可以在程序退出的情况下，让Service在后台继续保持运行状态。注意Service不是Thread。Android的服务可以分为本地服务（主进程）和远程服务（Remote，独立的进程），本地服务是处理我们自己应用程序的逻辑，远程服务是提供系统服务的Service（AIDL的使用）。本文着重介绍本地服务。 Service的生命周介绍 以上的生命周期图表示Service两种使用方式：StartService和BindService。 生命周期解析： StartService启动Service首次创建Service实例会回调onCreate方法，该方法在Service的整个生命周期只会调用一次。当我们调用StartService启动Service时会回调onStartCommand方法，此时Service处于运行状态。直到Service被自己或它的调用者停止（stopService），回调进入onDestory方法。 同一个Service无论我们启动多少次，调用一次StopService即可停掉Service，因为没次启动Service会重复调用已经存在的Service对象。 onStartCommand方法返回值介绍：返回类型为StartCommandResult，当系统可用内存过低时，Android可能会停止任何服务，如果我们的服务被停止，该如何重新启动就会根据onStartCommand返回值做出处理。 Sticky 重新启动服务并传入一个空的Intent，如检测更新的服务 RedeliverIntent 重新启动服务，并传入服务停止前最后传入的Intent重新传入，如下载服务 NotSticky 服务不会重新启动 StickyCompatibility Sticky的兼容版本，但不保证服务被kill后一定能重启。 BindService启动ServiceService第一次创建进入onCreate方法，当我们调用BindService方法绑定一个Service时会调用onBind方法。onBind返回一个IBinder对象，调用者可以通过IBinder与Service进行交互。如果再次使用bindService绑定Service,系统不会创建新的Sevice实例,也不会再调用onBind方法,而是直接把IBinder对象传递给其他后来增加的客户端!如果我们想解除与服务的绑定，调用unbindService方法即可，此时onUnbind方法将会被调用。如果Service只绑定了一个客户端，Service回调onDestory方法销毁Service，否则只有所有的客户端与Service解除绑定后，系统才会销毁这个Service。 如果我们使用bindService来绑定一个已经启动的Service,是已经启动的Service!!! 系统只是将Service的内部IBinder对象传递给Activity,并不会将Service的生命周期 与Activity绑定,因此调用unBindService( )方法取消绑定时,Service也不会被销毁！ Service （StartService）使用示例创建服务 继承Service，重写生命周期方法，定义好自己的Service后在AndroidManifest.xml中进行注册，Xamarin.Android 中推荐使用ServiceAttribute完成注册工作。 一个继承Service且有ServiceAttribute修饰的类 123&gt; [Service]&gt; public class DemoService : Service&gt; 在AndroidManifest.xml生成的service节点如下 12&gt; &lt;service android:name=\"demoservice.DemoService\"&gt;&lt;/service&gt;&gt; 启动服务 StartService (new Intent (this, typeof(DemoService))); 需要说明的是启动的服务是运行与主线程中的（the service will run on the main thread），服务要处理耗时的操作应该结合如下代码： 12345&gt; Thread t = new Thread (() =&gt; &#123;&gt; // long running code ...&gt; &#125;);&gt; t.Start();&gt; 停止服务 StopService (new Intent (this, typeof(DemoService))); 当我们多次启动一个服务时，直接调用StopService或者StopSelf是不合理的，应该调用StopSelf (startId:)来停止服务。startId是OnStartCommand方法传入的一个参数，表示服务启动的次数。StopSelf (startId:)中的startId与启动服务时系统生成的startId相同时，才会停止服务，从而确保服务不会过早的被停止。 Service隐式启动（Starting a Service With an Intent Filter） 和启动Activity一样，我们也可以借助IntentFilter实现Service的隐式启动。 如果是操作AndroidManifest.xml，在service节点下怎加一个 节点。 12345&lt;service android:name=\"demoservice.DemoService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.xamarin.DemoService\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; Xamarin.Android中可以通过IntentFilterAttribute实现同样的效果 123[Service][IntentFilter(new String[]&#123;\"com.xamarin.DemoService\"&#125;)]public class DemoService : Service 同样启动和停止服务使用如下代码： 123StartService (new Intent (\"com.xamarin.DemoService\"));StopService (new Intent (\"com.xamarin.DemoService\")); Service与用户交互服务长时间运行于后台，可能会与用户进行交互将一些信息反馈给用户，如文件传输等。 发送通知发送通知代码： 12345var nMgr = (NotificationManager)GetSystemService (NotificationService);var notification = new Notification (Resource.Mipmap.Icon, \"Message from demo service\");var pendingIntent = PendingIntent.GetActivity (this, 0, new Intent (this, typeof(MainActivity)), 0);notification.SetLatestEventInfo (this, \"Demo Service Notification\", \"Message from demo service\", pendingIntent);nMgr.Notify (0, notification); PendingIntent以后在介绍，以上代码点击通知会启动PendingIntent所包含的Activity。 Toast提示Service中使用吐司通知（可以理解为更新UI），由于Service是运行在主线程中，所以可以直接调用如下代码： 1Toast.MakeText (this, \"The demo service has started\", ToastLength.Long).Show(); 当我们服务要处理耗时操作时，应创建一个子线程，如何在Service的字线程中更新UI？不同于Activity，Service并没有为我们提供RunOnUIThread用来在子线程中更新UI，Service中可以使用Handle来完成。 1234var myHandler = new Handler ();myHandler.Post(() =&gt; &#123; Toast.MakeText (this, \"Message from demo service\", ToastLength.Long).Show();&#125;); In addition to a Handler, other options that may be used include Android.App.Application.SynchronizationContext.Post() and System.Threading.SynchronizationContext.Current.Post(). 前台服务前台服务（Foreground Services）不同于普通Service的是，当系统内存过低时，前台服务不会被停止(并不能保证Service 永远不被杀掉，只是提高了他的优先级)，但是使用前台服务时要包含一个Notification，以提醒用户服务运行状态,如音乐播放器。如下代码可以创建一个前台服务： 12345var ongoing = new Notification (Resource.Mipmap.Icon, \"DemoService in foreground\");var pendingIntent = PendingIntent.GetActivity (this, 0, new Intent (this, typeof(MainActivity)), 0);ongoing.SetLatestEventInfo (this, \"DemoService\", \"DemoService is running in the foreground\", pendingIntent);StartForeground ((int)NotificationFlags.ForegroundService, ongoing); 以上代码是写在Service内的，设置一个服务为前台服务，当我们想要停止前台服务调用StopForeground，传入一个bool类型参数，标示是否删除关联的通知。需要说明的是当我们调用StopForeground时，服务并没有被停止，只是该服务不再是前台服务。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Service","slug":"Service","permalink":"http://xamarin.xyz/tags/Service/"}]},{"title":"Android Activity管理机制详解","slug":"activity3","date":"2016-05-02T08:12:50.000Z","updated":"2017-11-02T15:10:10.000Z","comments":true,"path":"2016/05/02/activity3/","link":"","permalink":"http://xamarin.xyz/2016/05/02/activity3/","excerpt":"实际开发中，我们的App是由多个Activity构成的，为了能够管理Activity，Android为我们提供了Task的概念，默认情况下一个应用的所有Activity是管理在一个Task中的。Task是一种Stack类型的数据结构，启动App会创建一个Task，Activity特性设置MainLauncher = true或者AndroidManifest中配置了Main和Launcher的Activity会被压入栈中，新启动的Activity会执行入栈操作，关闭的Activity执行出栈操作。","text":"实际开发中，我们的App是由多个Activity构成的，为了能够管理Activity，Android为我们提供了Task的概念，默认情况下一个应用的所有Activity是管理在一个Task中的。Task是一种Stack类型的数据结构，启动App会创建一个Task，Activity特性设置MainLauncher = true或者AndroidManifest中配置了Main和Launcher的Activity会被压入栈中，新启动的Activity会执行入栈操作，关闭的Activity执行出栈操作。 官方文档给出的一个流程图： Activity启动模式 Activity的启动模式（launchMode）也是Task管理的一部分，这里单独拿出来介绍 Activity总共有四种启动模式：standard(multiple)(默认)，singleTop，singleTask，singleInstance。合理的使用启动模式可以带给用户更好的使用体验。 设置Activity的启动模式在AndroidManifest.xml 标签的一个属性中设置launchMode，如下： 123&lt;activity android:label=\"singleTask launchMode\" android:launchMode=\"singleTask\"&gt; 在Xamarin.Android开发过程中，我们不会过多的操作AndroidManifest.xml文件，设置启动模式通过设置Activity特定的值实现，如下： 1[Activity (Label = &quot;Activity2&quot;,LaunchMode=Android.Content.PM.LaunchMode.SingleTop)] 也可以通过启动Activity时，为Intent设置flag实现： 1intent.AddFlags(ActivityFlags.SingleTop); 启动模式介绍先看一下各个启动模式的总结介绍： 启动模式详解： standard模式 标准启动模式.在这种模式下启动的Activity可以被多次实例化.如果Activity A的启动模式为standard，并且A已经启动，在A中再次启动Activity A，会在A的上面再次启动一个A的实例，即当前的桟中的状态为A–&gt;A。 singleTop模式 如果一个以singleTop模式启动的Activity的实例已经存在于栈顶,当我们再次启动这个Activity时，不会重新创建而是调用onNewIntent方法，重用栈顶的实例。如果A的启动模式为singleTop，并且A的一个实例已经存在于栈顶中， 启动A Activity不会再次创建A的实例，而是调用原来实例的onNewIntent方法，重用原来的实例，保证栈顶只有一个A的实例。 这时任务栈中还是只有一个A的实例。如果A Activity的一个实例已经存在与任务栈中，但是不在栈顶，那么它和standard模式相同，也会创建多个实例。 singleTask模式 A Activity的启动模式设置为singleTask，启动Activity A时，检测当前Task是否有A的实例，没有则创建A的实例压入栈中，如果已经有了A的实例，则调用onNewIntent方法重用该实例，其如果A实例不位于栈顶，则将A之上的Activity对象出栈使A的实例位于栈顶。 尝试设置taskAffinity（后面介绍）的值，出现如图效果： 设置taskAffinity项目运行失败，提示Deployment failed. Internal error.修改taskAffinity为如下形式才可运行：TaskAffinity = “aaa.bbbb” singleTop模式 无论从哪个Task启动Activity都只会创建一个Activity实例,并将它加入新的Task栈,当再次启动该activity的实例时，会重用已存在的任务和实例 测试singleTop运行效果： 通过title区分Activity，可以看到以singleTop模式启动Acvity2当我们按下Home键，重新点击图标启动应用，应用重新启动Activity1，第二种情况我们在任务列表返回应用，返回Activity2，按下Back并没有返回Activity1，而是直接退出应用。 Task的管理 查看Activity的堆栈信息 adb shell dumpsys activity 我们可以使用的Task管理相关的属性如下： taskAffinity launchMode llowTaskReparenting clearTaskOnLaunch alwaysRetainTaskState finishOnTaskLaunch taskAffinity介绍通常一个应用中所有的Activity有相同的affinity，即拥有相同taskAffinity值的Activity值属于同一个Task。 不同应用程序中的Activity可以拥有相同的Affinity，同一个应用程序中不同Activity 也可以设置成不同的Affinity。taskAffinity的使用会有下面两种情况： 1）当传递给StartActivity()的Intent对象包含 FLAG_ACTIVITY_NEW_TASK标记时，系统会为需要启动的Activity寻找与当前Activity不同Task。如果要启动的 Activity的Affinity属性与当前所有的Task的Affinity属性都不相同，系统会新建一个带那个Affinity属性的Task，并将要启动的Activity压到新建的Task栈中；否则将Activity压入那个Affinity属性相同的栈中。 2）allowTaskReparenting属性设置为true 如果一个activity的allowTaskReparenting属性为true， 那么它可以从一个Task移到另外一个有相同Affinity的Task中，更换从属的Task。 如果一个.apk文件从用户角度来看包含了多个”应用程序”，你可能需要对那些 Activity赋不同的Affinity值。 栈的管理当应用长时间置于后台，系统可能会清理应用Task栈中的Activity，当用户返回应用保留的只有应用的启动Activity。通过以下设置改变这种行为！ alwaysRetainTaskState： 如果栈底Activity的这个属性被设置为true，Task中的所有activity将被长时间保存。 clearTaskOnLaunch:如果栈底activity的这个属性被设置为true，一旦用户离开Task， 则 Task栈中的Activity将被清空到只剩下栈底activity。这种情况刚好与 alwaysRetainTaskState相反。即使用户只是短暂地离开，task也会返回到初始状态 （只剩下栈底acitivty）。 finishOnTaskLaunch:与clearTaskOnLaunch相似，但它只对单独的activity起作用，而不是整个Task。它可以结束任何Activity，包括栈底的Activity。 当它设置为true时，当前的Activity只在当前会话期间作为Task的一部分存在， 当用户按下Home键重新点击图标启动应用，它将不存在。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://xamarin.xyz/tags/Activity/"}]},{"title":"Xamarin.Android Activity用例介绍","slug":"activity2","date":"2016-04-29T07:08:21.000Z","updated":"2017-11-02T15:09:20.000Z","comments":true,"path":"2016/04/29/activity2/","link":"","permalink":"http://xamarin.xyz/2016/04/29/activity2/","excerpt":"Activity间传递数据是借助Intent（内部为Bundle）实现的在使用Bundle传递数据时，要注意，Bundle的大小是有限制的小于0.5MB，如果大于这个值 是会报TransactionTooLargeException异常的！！！（未验证）","text":"Activity间传递数据是借助Intent（内部为Bundle）实现的在使用Bundle传递数据时，要注意，Bundle的大小是有限制的小于0.5MB，如果大于这个值 是会报TransactionTooLargeException异常的！！！（未验证） Activiy数据单向传递简单数据传递Activity1传递数据代码： 123Intent intent = new Intent (this, typeof (Activity2));intent.PutExtra (\"key\", \"value\");StartActivity (intent); Activity2接受数据代码： 1var str = Intent.GetStringExtra (\"key\"); 传递对象数据使用Intent传递对象，该对象必须是可被序列化的对象。序列化对象有两种方式：Java.IO.ISerializable和android.os.Parcelable，从命名空间可以看出Serializable是Java提供的，而Parcelable是Google在Android中为我们定义的。在内存使用方面Parcelable比Serializable性能高，而Serializable可将数据持久化方便保存，所以在需要保存或网络传输数据时选择Serializable。 参考链接：Android系统中Parcelable和Serializable的区别 Serializable方式定义传递的对象，注意代码中的注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestModel : Java.Lang.Object, ISerializable &#123; //这里不确定这么定义是否有效 参考下面两个链接 //https://developer.xamarin.com/api/field/Java.Security.Key.SerialVersionUID/ //http://blog.csdn.net/hackingwu/article/details/26148543 public const System.Int64 SerialVersionUID = 6603384152749567611; //必须实现该构造函数 否则抛异常 No constructor found for .ctor(System.IntPtr, Android.Runtime.JniHandleOwnership) public TestModel (IntPtr handle, JniHandleOwnership transfer) : base (handle, transfer) &#123; &#125; public TestModel () &#123; &#125; public string Name &#123; get; set; &#125; //必须的 否则获取到的对象都为默认值 //https://developer.xamarin.com/api/type/Java.IO.ISerializable/ [Export (\"readObject\", Throws = new [] &#123; typeof(Java.IO.IOException), typeof(Java.Lang.ClassNotFoundException) &#125;)] private void ReadObject (ObjectInputStream source) &#123; Name = source.ReadUTF (); &#125; [Export (\"writeObject\", Throws = new [] &#123; typeof(Java.IO.IOException), typeof(Java.Lang.ClassNotFoundException) &#125;)] private void WriteObject (ObjectOutputStream destination) &#123; destination.WriteUTF (Name); &#125; &#125; 传递数据代码： 123456Intent intent = new Intent (this, typeof(Activity2)); intent.PutExtra (\"key\", new TestModel () &#123; Name = \"TestName\" &#125;);StartActivity (intent); 接收数据代码： 1var model = Intent.GetSerializableExtra (\"key\") as TestModel; Parcelable方式Xamarin 官方文档有这样一段说明： Interface for classes whose instances can be written to and restored from a Parcel. Classes implementing the Parcelable interface must also have a non-null static field called CREATOR of a type that implements the IParcelableCreator interface.不光要实现IParcelable接口的方法还要定义一个实现了IParcelableCreator接口的静态字段。首先看一下传递对象的定义： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class TestModel : Java.Lang.Object,IParcelable &#123; public string Name &#123; get; set; &#125; //内容接口描述，默认返回0就可以; public int DescribeContents () &#123; return 0; &#125; //将传递的数据打包到Parcel容器中 public void WriteToParcel (Parcel dest, ParcelableWriteFlags flags) &#123; dest.WriteString (Name); &#125; [ExportField (\"CREATOR\")] public static ParcelableCreator InitializeCreator () &#123; return new ParcelableCreator (); &#125; public class ParcelableCreator : Java.Lang.Object, IParcelableCreator &#123; public Java.Lang.Object CreateFromParcel (Parcel source) &#123; return new TestModel () &#123; Name = source.ReadString () &#125;; &#125; public Java.Lang.Object[] NewArray (int size) &#123; return new Java.Lang.Object [size]; &#125; &#125; &#125; 传递数据代码相同，改变传入的对象即可。 获取数据代码用GetParcelableExtra方法代替GetSerializableExtra Activity之间数据回传1、用StartActivityForResult代替StartActivity启动Activity。 2、在启动的Activity中重写OnActivityResult方法 1234protected override void OnActivityResult (int requestCode, Result resultCode, Intent data)&#123; base.OnActivityResult (requestCode, resultCode, data);&#125; requestCode用来区分由Activity的启动方式，如两个按钮起动Activity并传递不同的数据，在OnActivityResult方法中我们可以通过比较requestCode来区分由哪个按钮起动的Activty返回的数据。 3、在被启动的Activty返回到启动的Activity之前调用SetResult方法指定resultCode和返回的数据。 双击退出程序1234567891011121314151617//定义变量保存点击的时间private long exitTime = 0;public override bool OnKeyDown (Android.Views.Keycode keyCode, Android.Views.KeyEvent e)&#123; //可以C#中(System.DateTime.Now - System.DateTime.Parse (\"1970-1-1\")).TotalMilliseconds 代替JavaSystem.CurrentTimeMillis () if (keyCode == Android.Views.Keycode.Back) &#123; if ((JavaSystem.CurrentTimeMillis () - exitTime) &gt; 2000) &#123; Toast.MakeText (this, \"再按一次退出应用程序\", ToastLength.Short).Show (); exitTime = JavaSystem.CurrentTimeMillis (); &#125; else &#123; //Exit (); &#125; return false; &#125; return base.OnKeyDown (keyCode, e);&#125; 为Activity设置过场动画 在Activity切换时我们可以加上各种跳转动画，如淡入淡出，放大缩小，左右互推等！这里简单介绍如何设置Activity跳转的动画。 准备工作：在Resources目录下创建anim目录，并在anim目录下定义动画效果（先不做介绍） Activity常用过度动画 代码设置在StartActivity或Finish后面加上OverridePendingTransition(enterAnim,exitAnim);enterAnim:进入Activity的动画exitAnim:退出Activity的动画 style设置通过style进行配置是全局的，所有的Activity都会加载这个动画 ①在style.xml中自定义style： 1234567&lt;!-- 默认Activity跳转动画 --&gt;&lt;style name=\"default_animation\" mce_bogus=\"1\" parent=\"@android:style/Animation.Activity\"&gt; &lt;item name=\"android:activityOpenEnterAnimation\"&gt;@anim/default_anim_in&lt;/item&gt; &lt;item name=\"android:activityOpenExitAnimation\"&gt;@anim/anim_stay&lt;/item&gt; &lt;item name=\"android:activityCloseEnterAnimation\"&gt;@anim/anim_stay&lt;/item&gt; &lt;item name=\"android:activityCloseExitAnimation\"&gt;@anim/default_anim_out&lt;/item&gt;&lt;/style&gt; 4个item分别代表: Activity A跳转到Activity B时Activity B进入动画 Activity A跳转到Activity B时Activity A退出动画 Activity B返回Activity A时Activity A的进入动画 Activity B返回Activity A时ActivityB的退出动画 ②AppTheme怎加如下节点: 1&lt;item name=\"android:windowAnimationStyle\"&gt;@style/default_animation&lt;/item&gt; ③AndroidManifest文件中找到application节点，增加主题设置 1android:theme=\"@style/AppTheme\" 定义对话框风格的Activity 通常Activity是占满全屏的，根据需要我们可以将Activity设置成对话框风格的 设置Activity的theme为“@android:style/Theme.Dialog”。","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://xamarin.xyz/tags/Activity/"}]},{"title":"Xamarin.Android Activity入门介绍","slug":"activity1","date":"2016-04-28T06:29:02.000Z","updated":"2017-11-02T15:06:35.000Z","comments":true,"path":"2016/04/28/activity1/","link":"","permalink":"http://xamarin.xyz/2016/04/28/activity1/","excerpt":"本文将对Android四大组件之一的Activity进行简单介绍。Activity是一个应用程序的组件，他在屏幕上提供了一个区域，允许用户在上面做一些交互性的操作， 比如打电话，照相，发送邮件，或者显示一个地图！Activity可以理解成一个绘制用户界面的窗口， 而这个窗口可以填满整个屏幕，也可能比屏幕小或者浮动在其他窗口的上方！","text":"本文将对Android四大组件之一的Activity进行简单介绍。Activity是一个应用程序的组件，他在屏幕上提供了一个区域，允许用户在上面做一些交互性的操作， 比如打电话，照相，发送邮件，或者显示一个地图！Activity可以理解成一个绘制用户界面的窗口， 而这个窗口可以填满整个屏幕，也可能比屏幕小或者浮动在其他窗口的上方！ Activity生命周期介绍 建议自己写Demo查看各个生命周期调用时间。 OnCreate当Activity创建时会调用此方法，是我们必须要重写的方法，该方法传入一个Bundle对象作为参数。如果bundle不为null，说明当前Activity是重新启动。可以通过bundle读取我们之前保存的数据，做相应的数据恢复工作。在这个方法中要执行的操作是： Creating views Initializing variables Binding static data to lists OnStartOnCreate执行结束会掉用OnStart方法，可以根据具体应用情况重写该方法。 OnResume当一个Activity初始化完成准备显示给用户时会掉用OnResume方法。此时Activity进入活动状态。在这个方法中我们要做的是： Ramping up frame rates (a common task in game building) Starting animations Listening for GPS updates Display any relevant alerts or dialogs Wire up external event handlers OnPause当Activity进入后台或者Activity被遮挡时（Dialog风格的Activity）掉用此方法。OnPause方法之行过后Activity可以有两种不同的状态，进入OnResume返回前台或者进入OnStop方法，重写这个方法我们要做的是： Commit unsaved changes to persistent data Destroy or clean up other objects consuming resources Ramp down frame rates and pausing animations Unregister external event handlers or notification handlers (i.e. those that are tied to a service). This must be done to prevent Activity memory leaks. Likewise, if the Activity has displayed any dialogs or alerts, they must be cleaned up with the .Dismiss() method. 最后一条，如果不关闭已经显示的Dialog会抛异常。 OnStopActivity不再显示时调用此方法，此时Activity仍存留在内存中。 OnDestroyActivity销毁调用次方法，此时Activity已经完全从内存中移除，我们应该重写此方法，释放占用的资源。 OnRestart是OnStop状态的Activity重新显示给用户会进入OnRestart方法。如按下Home键应用进入后台，重新打开应用，Activity重新启动。 Activity使用 Android中的四大组件，只要你定义了就必须在AndroidManifest.xml中对这个组件进行声明。 定义Activity我们自定义的Activity一定要继承Activity或其子类（如AppCompatActivity），并重写相关方法。OnCreate是必须重写的，在OnCreate中调用SetContentView方法加载相关联的视图。 声明Activity在AndroidManifest中增加Activity节点。参考文档 Xamarin.Android中我们可以通过声明特性进行组件的声明。 1[Activity (Label = \"activity1\", MainLauncher = true, Icon = \"@mipmap/icon\")] 项目编译时会根据我们声明的特性生成新的AndroidManifest.xml文件 可在项目目录下 /项目名/obj/Debug or Release/android下查看 启动Activity启动方式： 显式启动 12Intent intent = new Intent (this, typeof(Activity2));StartActivity (intent); 1StartActivity(typeof(Activity2)); Intent对象可以在两个Activity间传递数据。 隐式启动 给出Java示例 生命周期中状态的保存Bundle保存状态通过OnSaveInstanceState、OnRestoreInstanceState两个方法管理保存的状态（不是一定会执行的） 以下代码，改变默认创建的Android项目，是一个简单保存状态的例子，可以通过横竖屏切换掉用OnSaveInstanceState、OnRestoreInstanceState方法。（这里提到横竖屏切换，我们可以为一个Activity分别提供不同情况下的布局文件，创建两个布局文件夹：layout-land横屏,layout-port竖屏 然后把两套布局文件丢这两文件夹里，文件名一样，Android就会自行判断加载相应布局） 1234567891011121314151617181920212223242526272829303132333435[Activity (Label = &quot;activity1&quot;, MainLauncher = true, Icon = &quot;@mipmap/icon&quot;)] public class MainActivity : Activity &#123; int count = 1; Button button; protected override void OnCreate (Bundle savedInstanceState) &#123; base.OnCreate (savedInstanceState); // Set our view from the &quot;main&quot; layout resource SetContentView (Resource.Layout.Main); // Get our button from the layout resource, // and attach an event to it button = FindViewById&lt;Button&gt; (Resource.Id.myButton); button.Click += delegate &#123; button.Text = string.Format (&quot;&#123;0&#125; clicks!&quot;, count++); &#125;; &#125; protected override void OnSaveInstanceState (Bundle outState) &#123; base.OnSaveInstanceState (outState); outState.PutInt (&quot;count&quot;, count); &#125; protected override void OnRestoreInstanceState (Bundle savedInstanceState) &#123; base.OnRestoreInstanceState (savedInstanceState); count = savedInstanceState.GetInt (&quot;count&quot;); button.Text = string.Format (&quot;&#123;0&#125; clicks!&quot;, count); &#125; &#125; 事实上我们并不需要在OnSaveInstanceState方法中保存每个view的状态，只要指定view的ID，android系统会自动帮我们保存view的状态，如我们在布局文件中了添加一个EditText视图，并指定ID属性，运行项目，修改EditText的值，切换屏幕方向EditText中的值依然保存。 如图所示，Activity由Resumed状态变为Destroyed状态可能会调用OnSaveInstanceState方法，Created到Resumed可能会调用OnRestoreInstanceState方法。 使用Bundle保存状态的限制 It is not called in all cases. For example, pressing home or back to exit an Activity will not result in OnSaveInstanceState being called. The bundle passed into OnSaveInstanceState is not designed for large objects, such as images. In the case of large objects, saving the object from OnRetainNonConfigurationInstance is preferable, as discussed below. Data saved by using the bundle is serialized, which can lead to delays. 复杂数据的持久化由于Bundle的限制，只适合保存简单的数据值如：int，string等。对于复杂数据的保存我们可以通过重写OnRetainNonConfigurationInstance返回一个Java.Lang.Object，恢复数据时LastNonConfigurationInstance返回保存的数据。这里列出一个Xamarin官网的例子： 1.先定义我们要返回的类型 1234class TweetListWrapper : Java.Lang.Object&#123; public string[] Tweets &#123; get; set; &#125;&#125; 2.Activity中处理数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364TweetListWrapper _savedInstance; protected override void OnCreate (Bundle bundle) &#123; base.OnCreate (bundle); var tweetsWrapper = LastNonConfigurationInstance as TweetListWrapper; if (tweetsWrapper != null) &#123; PopulateTweetList (tweetsWrapper.Tweets); &#125; else &#123; SearchTwitter (&quot;xamarin&quot;); &#125; &#125; public void SearchTwitter (string text) &#123; string searchUrl = String.Format (&quot;http://search.twitter.com/search.json?&quot; + &quot;q=&#123;0&#125;&amp;rpp=10&amp;include_entities=false&amp;&quot; + &quot;result_type=mixed&quot;, text); Console.WriteLine (searchUrl); var httpReq = (HttpWebRequest)HttpWebRequest.Create (new Uri (searchUrl)); httpReq.BeginGetResponse (new AsyncCallback (ResponseCallback), httpReq); &#125; void ResponseCallback (IAsyncResult ar) &#123; var httpReq = (HttpWebRequest)ar.AsyncState; using (var httpRes = (HttpWebResponse)httpReq.EndGetResponse (ar)) &#123; ParseResults (httpRes); &#125; &#125; void ParseResults (HttpWebResponse httpRes) &#123; var s = httpRes.GetResponseStream (); var j = (JsonObject)JsonObject.Load (s); var results = (from result in (JsonArray)j [&quot;results&quot;] let jResult = result as JsonObject select jResult [&quot;text&quot;].ToString ()).ToArray (); RunOnUiThread (() =&gt; &#123; PopulateTweetList (results); &#125;); &#125; [Obsolete (&quot;deprecated&quot;)] public override Java.Lang.Object OnRetainNonConfigurationInstance () &#123; base.OnRetainNonConfigurationInstance (); Console.WriteLine (&quot;OnRetainNonConfigurationInstance&quot;); return _savedInstance; &#125; void PopulateTweetList (string[] results) &#123; ListAdapter = new ArrayAdapter&lt;string&gt; (this, Android.Resource.Layout.SimpleListItem1, results); _savedInstance = new TweetListWrapper&#123; Tweets = results &#125;; &#125; 可以注意到OnRetainNonConfigurationInstance方法已经是过期的，查看文档可以看到： Called by the system, as part of destroying an activity due to a configuration change, when it is known that a new instance will immediately be created for the new configuration. You can return any object you like here, including the activity instance itself, which can later be retrieved by calling Activity.LastNonConfigurationInstance in the new activity instance. If you are targeting Build+VERSION_CODES.Honeycomb or later, consider instead using a Fragment with Fragment.RetainInstance. 我们可以用Fragment.RetainInstance完成同样的事情。 系统提供常用Activity123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//1.拨打电话// 给移动客服10086拨打电话Uri uri = Uri.Parse (&quot;tel:10086&quot;);Intent intent = new Intent (Intent.ActionDial, uri);StartActivity (intent);//2.发送短信// 给10086发送内容为“Hello”的短信Uri uri = Uri.Parse (&quot;smsto:10086&quot;);Intent intent = new Intent (Intent.ActionSendto, uri);intent.PutExtra (&quot;sms_body&quot;, &quot;Hello&quot;);StartActivity (intent);//3.发送彩信（相当于发送带附件的短信）Intent intent = new Intent(Intent.ActionSend);intent.PutExtra(&quot;sms_body&quot;, &quot;Hello&quot;);Uri uri = Uri.Parse(&quot;content://media/external/images/media/23&quot;);intent.PutExtra(Intent.ExtraStream, uri);intent.SetType(&quot;image/png&quot;);StartActivity(intent);//4.打开浏览器:Uri uri = Uri.Parse (&quot;http://www.baidu.com&quot;);Intent intent = new Intent (Intent.ActionView, uri);StartActivity (intent);//5.多媒体播放:Intent intent = new Intent(Intent.ActionView);Uri uri = Uri.Parse(&quot;file:///sdcard/foo.mp3&quot;);intent.SetDataAndType(uri, &quot;audio/mp3&quot;);StartActivity(intent);//6.打开摄像头拍照:// 打开拍照程序Intent intent = new Intent(MediaStore.ActionImageCapture); StartActivityForResult(intent, 0);// 取出照片数据Bundle extras = intent.Extras; Bitmap bitmap = (Bitmap) extras.Get(&quot;data&quot;);//另一种://调用系统相机应用程序，并存储拍下来的照片Intent intent = new Intent(MediaStore.ActionImageCapture); var time = Calendar.GetInstance().TimeInMillis;intent.PutExtra(MediaStore.ExtraOutput, Uri.FromFile(new File(path, time + &quot;.jpg&quot;)));StartActivityForResult(intent, 0);//7.获取并剪切图片// 获取并剪切图片Intent intent = new Intent(Intent.ActionGetContent);intent.SetType(&quot;image/*&quot;);intent.PutExtra(&quot;crop&quot;, &quot;true&quot;); // 开启剪切intent.PutExtra(&quot;aspectX&quot;, 1); // 剪切的宽高比为1：2intent.PutExtra(&quot;aspectY&quot;, 2);intent.PutExtra(&quot;outputX&quot;, 20); // 保存图片的宽和高intent.PutExtra(&quot;outputY&quot;, 40); intent.PutExtra(&quot;output&quot;, Uri.FromFile(new File(&quot;/mnt/sdcard/temp&quot;))); // 保存路径intent.PutExtra(&quot;outputFormat&quot;, &quot;JPEG&quot;);// 返回格式StartActivityForResult(intent, 0);// 剪切特定图片Intent intent = new Intent(&quot;com.android.camera.action.CROP&quot;); intent.SetClassName(&quot;com.android.camera&quot;, &quot;com.android.camera.CropImage&quot;); intent.SetData(Uri.FromFile(new File(&quot;/mnt/sdcard/temp&quot;))); intent.PutExtra(&quot;outputX&quot;, 1); // 剪切的宽高比为1：2intent.PutExtra(&quot;outputY&quot;, 2);intent.PutExtra(&quot;aspectX&quot;, 20); // 保存图片的宽和高intent.PutExtra(&quot;aspectY&quot;, 40);intent.PutExtra(&quot;scale&quot;, true);intent.PutExtra(&quot;noFaceDetection&quot;, true); intent.PutExtra(&quot;output&quot;, Uri.Parse(&quot;file:///mnt/sdcard/temp&quot;)); StartActivityForResult(intent, 0);//8.打开Google Market // 打开Google Market直接进入该程序的详细页面Uri uri = Uri.Parse (&quot;market://details?id=&quot; + &quot;com.demo.app&quot;);Intent intent = new Intent (Intent.ActionView, uri);StartActivity (intent);//9.进入手机设置界面:// 进入无线网络设置界面（其它可以举一反三） Intent intent = new Intent (Android.Provider.Settings.ActionWirelessSettings);StartActivityForResult (intent, 0);//10.安装apk:Uri installUri = Uri.FromParts(&quot;package&quot;, &quot;xxx&quot;, null); Intent it = new Intent(Intent.ACTION_PACKAGE_ADDED, installUri);StartActivity(it);//11.卸载apk:Uri uri = Uri.FromParts(&quot;package&quot;, strPackageName, null); Intent it = new Intent(Intent.ACTION_DELETE, uri); StartActivity(it); //12.进入联系人页面:Intent intent = new Intent ();intent.SetAction (Intent.ActionView);intent.SetData (Android.Provider.ContactsContract.Contacts.ContentUri);StartActivity (intent);//13.查看指定联系人:Uri personUri = ContentUris.WithAppendedId (Android.Provider.ContactsContract.Contacts.ContentUri, id);//id联系人IDIntent intent = new Intent ();intent.SetAction (Intent.ActionView);intent.SetData (personUri);StartActivity (intent);","categories":[{"name":"Android","slug":"Android","permalink":"http://xamarin.xyz/categories/Android/"}],"tags":[{"name":"Activity","slug":"Activity","permalink":"http://xamarin.xyz/tags/Activity/"}]}]}